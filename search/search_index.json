{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Circulax","text":""},{"location":"#a-differentiable-functional-circuit-simulator-based-on-jax","title":"A Differentiable, Functional Circuit Simulator based on JAX","text":"<p>Circulax is a differentiable circuit simulation framework built on JAX, Optimistix and Diffrax. It treats circuit netlists as systems of Ordinary Differential Equations (ODEs), leveraging Diffrax's suite of numerical solvers for transient analysis.</p> <p>By using JAX as its backend, circulax provides:</p> <p>Native Differentiation: Full support for forward and reverse-mode automatic differentiation through the solver, enabling gradient-based parameter optimization and inverse design.</p> <p>Hardware Acceleration: Seamless execution on CPU, GPU, and TPU without code changes.</p> <p>Mixed-Domain Support: Native complex-number handling for simultaneous simulation of electronic and photonic components.</p> <p>Modular Architecture: A functional approach to simulation that integrates directly into machine learning and scientific computing workflows.</p> <p>Standard tools (SPICE, Spectre, Ngspice) rely on established matrix stamping methods and CPU-bound sparse solvers. circulax leverages the JAX ecosystem to offer specific advantages in optimization and hardware utilization:</p> Feature Legacy(SPICE) circulax Model Definition Hardcoded C++ / Verilog-A Simple python functions Derivatives Hardcoded (C) or Compiler-Generated (Verilog-A) Automatic Differentiation (AD) Solver Logic Fixed-step or heuristic-based Adaptive ODE stepping via Diffrax Matrix Solver Monolithic CPU Sparse (KLU) Pluggable (KLUJAX, Dense, or Custom) Hardware Target CPU-bound Agnostic (CPU/GPU/TPU)"},{"location":"#simulator-setup","title":"Simulator setup","text":"<p>circulax strictly separates Physics, Topology, and Analysis, enabling the interchange of solvers or models without netlist modification.</p>"},{"location":"#physics-layer","title":"Physics Layer","text":"<p>Components are defined as simple Python functions wrapped with the <code>@component</code> decorator. This functional interface abstracts away the boilerplate, allowing users to define physics using simple voltage/current/field/flux relationships.</p> <pre><code>from circulax.base_component import component, Signals, States\nimport jax.numpy as jnp\n\n@component(ports=(\"p1\", \"p2\"))\ndef Resistor(signals: Signals, s: States, R: float = 1e3):\n    \"\"\"Ohm's Law: I = V/R\"\"\"\n    # signals.p1, signals.p2 are the nodal voltages\n    i = (signals.p1 - signals.p2) / R\n    # Return (Currents, Charges)\n    return {\"p1\": i, \"p2\": -i}, {}\n\n@component(ports=(\"p1\", \"p2\"))\ndef Capacitor(signals: Signals, s: States, C: float = 1e-12):\n    \"\"\"\n    Q = C * V.\n    Returns Charge (q) so the solver computes I = dq/dt.\n    \"\"\"\n    v_drop = signals.p1 - signals.p2\n    q_val = C * v_drop\n    return {}, {\"p1\": q_val, \"p2\": -q_val}\n</code></pre>"},{"location":"#topology","title":"Topology","text":"<p>The compiler inspects your netlist and your model signatures. It automatically:</p> <ol> <li> <p>Introspects models to determine how many internal variables (currents) they need.</p> </li> <li> <p>Allocates indices in the global state vector.</p> </li> <li> <p>Pre-calculates the Sparse Matrix indices (BCOO format) for batched/parallel assembly.</p> </li> </ol> <pre><code>netlist = [\n    Instance(\"V1\", voltage_source, connections=[1, 0], params={\"V\": 5.0}),\n    Instance(\"R1\", resistor,       connections=[1, 2], params={\"R\": 100.0}),\n]\n# Compiler auto-detects that V1 needs an extra internal variable!\n</code></pre>"},{"location":"#analysis","title":"Analysis","text":"<p>The solver is a generic DAE engine linking Diffrax (Time-stepping) and Optimistix (Root-finding).</p> <ul> <li> <p>Transient: Solves \\(F(y) + \\frac{d}{dt}Q(y) = 0\\) using Implicit Backward Euler (or any other solver compatible with Diffrax).</p> </li> <li> <p>DC Operating Point: Solves \\(F(y) = 0\\) (automatically ignoring \\(Q\\)).</p> </li> <li> <p>Jacobian-Free: The solver builds the system Jacobian on-the-fly using <code>jax.jacfwd</code> allowing for the simulation of arbitrary user-defined non-linearities without manual derivative derivation.The approach results in a more exact and stable simulation.</p> </li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install circulax\n</code></pre>"},{"location":"#simulation-example","title":"Simulation Example","text":"<pre><code>import jax\nimport jax.numpy as jnp\nfrom circulax.components import Resistor, Capacitor, Inductor, VoltageSource\nfrom circulax.compiler import compile_netlist\nimport matplotlib.pyplot as plt\n\njax.config.update(\"jax_enable_x64\", True)\n\nnet_dict = {\n    \"instances\": {\n        \"GND\": {\"component\":\"ground\"},\n        \"V1\": {\"component\":\"source_voltage\", \"settings\":{\"V\": 1.0,\"delay\":0.25E-9}},\n        \"R1\": {\"component\":\"resistor\", \"settings\":{\"R\": 10.0}},\n        \"C1\": {\"component\":\"capacitor\", \"settings\":{\"C\": 1e-11}},\n        \"L1\": {\"component\":\"inductor\", \"settings\":{\"L\": 5e-9}},\n    },\n    \"connections\": {\n        \"GND,p1\": (\"V1,p2\", \"C1,p2\"),\n        \"V1,p1\": \"R1,p1\",\n        \"R1,p2\": \"L1,p1\",\n        \"L1,p2\": \"C1,p1\",\n    },\n}\n\nmodels_map = {\n    'resistor': Resistor,\n    'capacitor': Capacitor,\n    'inductor': Inductor,\n    'source_voltage': VoltageSource,\n    'ground': lambda: 0\n}\n\n# Analyze Circuit\ngroups, sys_size, port_map = compile_netlist(net_dict, models_map)\nlinear_strat = analyze_circuit(groups, sys_size, is_complex=False)\n\n# Solve DC\ny_guess = jnp.zeros(sys_size)\ny_op = linear_strat.solve_dc(groups,y_guess)\n\n# Setup Sim\ntransient_sim = setup_transient(groups=groups, linear_strategy=linear_strat)\nterm = diffrax.ODETerm(lambda t, y, args: jnp.zeros_like(y))\n\n# Run simulation\nt_max = 3E-9\nsaveat = diffrax.SaveAt(ts=jnp.linspace(0, t_max, 500))\nsol = transient_sim(\n    t0=0.0, t1=t_max, dt0=1e-3*t_max,\n    y0=y_op,\n    saveat=saveat, max_steps=100000,\n    progress_meter=diffrax.TqdmProgressMeter(refresh_steps=100)\n)\n\n# Post processing and plotting\nts = sol.ts\nv_src = sol.ys[:, port_map[\"V1,p1\"]]\nv_cap = sol.ys[:, port_map[\"C1,p1\"]]\ni_ind = sol.ys[:, 5]\n\nfig, ax1 = plt.subplots(figsize=(8, 5))\nax1.plot(ts, v_src, 'k--', label='Source V')\nax1.plot(ts, v_cap, 'b-', label='Capacitor V')\nax1.set_xlabel('Time (s)')\nax1.set_ylabel('Voltage (V)')\nax1.legend(loc='upper left')\n\nax2 = ax1.twinx()\nax2.plot(ts, i_ind, 'r:', label='Inductor I')\nax2.set_ylabel('Current (A)')\nax2.legend(loc='upper right')\n\nax2_ticks = ax2.get_yticks()\nax1_ticks = ax1.get_yticks()\nax2.set_yticks(jnp.linspace(ax2_ticks[0], ax2_ticks[-1], len(ax1_ticks)))\nax1.set_yticks(jnp.linspace(ax1_ticks[0], ax1_ticks[-1], len(ax1_ticks)))\n\nplt.title(\"Impulse Response of LCR circuit\")\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"#license","title":"License","text":"<p>Copyright \u00a9 2026, Chris Daunt, Apache-2.0 License</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>Writing Components</li> <li>Examples</li> <li>API Reference</li> </ul>"},{"location":"gen_doc_stubs/","title":"Gen doc stubs","text":"In\u00a0[1]: Copied! <pre># gen_doc_stubs.py\nfrom pathlib import Path\n</pre> # gen_doc_stubs.py from pathlib import Path In\u00a0[2]: Copied! <pre>import mkdocs_gen_files\n</pre> import mkdocs_gen_files In\u00a0[3]: Copied! <pre>this_dir = Path(__file__).parent\n</pre> this_dir = Path(__file__).parent <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[3], line 1\n----&gt; 1 this_dir = Path(__file__).parent\n\nNameError: name '__file__' is not defined</pre> In\u00a0[4]: Copied! <pre>src_root = (this_dir / \"../circulax\").resolve()\n</pre> src_root = (this_dir / \"../circulax\").resolve() <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[4], line 1\n----&gt; 1 src_root = (this_dir / \"../circulax\").resolve()\n\nNameError: name 'this_dir' is not defined</pre> In\u00a0[5]: Copied! <pre>for path in src_root.rglob(\"*.py\"):\n    rel_path = path.relative_to(src_root)\n\n    parts = tuple(rel_path.with_suffix(\"\").parts)\n\n    if parts[-1] == \"__init__\":\n        parts = parts[:-1]\n        doc_path = rel_path.with_name(\"index.md\")\n    elif parts[-1] == \"__main__\":\n        continue\n    else:\n        doc_path = rel_path.with_suffix(\".md\")\n\n    full_parts = (\"circulax\",) + parts\n    identifier = \".\".join(full_parts)\n\n    output_filename = Path(\"references\") / doc_path\n\n    with mkdocs_gen_files.open(output_filename, \"w\") as fd:\n        fd.write(f\"::: {identifier}\")\n\n    mkdocs_gen_files.set_edit_path(output_filename, path)\n</pre> for path in src_root.rglob(\"*.py\"):     rel_path = path.relative_to(src_root)      parts = tuple(rel_path.with_suffix(\"\").parts)      if parts[-1] == \"__init__\":         parts = parts[:-1]         doc_path = rel_path.with_name(\"index.md\")     elif parts[-1] == \"__main__\":         continue     else:         doc_path = rel_path.with_suffix(\".md\")      full_parts = (\"circulax\",) + parts     identifier = \".\".join(full_parts)      output_filename = Path(\"references\") / doc_path      with mkdocs_gen_files.open(output_filename, \"w\") as fd:         fd.write(f\"::: {identifier}\")      mkdocs_gen_files.set_edit_path(output_filename, path) <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[5], line 1\n----&gt; 1 for path in src_root.rglob(\"*.py\"):\n      2     rel_path = path.relative_to(src_root)\n      4     parts = tuple(rel_path.with_suffix(\"\").parts)\n\nNameError: name 'src_root' is not defined</pre>"},{"location":"hooks/","title":"Hooks","text":"In\u00a0[1]: Copied! <pre>\"\"\"MkDocs hooks for SAX-specific preprocessing.\"\"\"\n</pre> \"\"\"MkDocs hooks for SAX-specific preprocessing.\"\"\" Out[1]: <pre>'MkDocs hooks for SAX-specific preprocessing.'</pre> In\u00a0[2]: Copied! <pre>import hashlib\nimport json\nimport re\nimport shutil\nimport subprocess\nimport tempfile\nfrom pathlib import Path\nfrom textwrap import dedent\nfrom typing import Any\n</pre> import hashlib import json import re import shutil import subprocess import tempfile from pathlib import Path from textwrap import dedent from typing import Any In\u00a0[3]: Copied! <pre>STYLE_CODE = \"\"\"\nimport matplotlib.pyplot as plt\nplt.rcParams.update({\n    \"figure.figsize\": (6, 2.5),\n    \"axes.grid\": True,\n    \"lines.color\": \"grey\",\n    \"patch.edgecolor\": \"grey\",\n    \"text.color\": \"grey\",\n    \"axes.facecolor\": \"ffffff00\",\n    \"axes.edgecolor\": \"grey\",\n    \"axes.labelcolor\": \"grey\",\n    \"xtick.color\": \"grey\",\n    \"ytick.color\": \"grey\",\n    \"grid.color\": \"grey\",\n    \"figure.facecolor\": \"ffffff00\",\n    \"figure.edgecolor\": \"ffffff00\",\n    \"savefig.facecolor\": \"ffffff00\",\n    \"savefig.edgecolor\": \"ffffff00\",\n})\n\"\"\"\n</pre> STYLE_CODE = \"\"\" import matplotlib.pyplot as plt plt.rcParams.update({     \"figure.figsize\": (6, 2.5),     \"axes.grid\": True,     \"lines.color\": \"grey\",     \"patch.edgecolor\": \"grey\",     \"text.color\": \"grey\",     \"axes.facecolor\": \"ffffff00\",     \"axes.edgecolor\": \"grey\",     \"axes.labelcolor\": \"grey\",     \"xtick.color\": \"grey\",     \"ytick.color\": \"grey\",     \"grid.color\": \"grey\",     \"figure.facecolor\": \"ffffff00\",     \"figure.edgecolor\": \"ffffff00\",     \"savefig.facecolor\": \"ffffff00\",     \"savefig.edgecolor\": \"ffffff00\", }) \"\"\" In\u00a0[4]: Copied! <pre>def on_page_read_source(page: Any, config: Any, **kwargs: Any) -&gt; str | None:\n    \"\"\"Inject style settings into notebooks before execution.\"\"\"\n    # Only act on Jupyter Notebooks\n    if page.file.src_path.endswith(\".ipynb\"):\n        try:\n            with open(page.file.abs_src_path, encoding=\"utf-8\") as f:\n                nb = json.load(f)\n\n            # Create a new code cell with the style configuration\n            new_cell = {\n                \"cell_type\": \"code\",\n                \"execution_count\": None,\n                # \"remove_cell\" tag helps some themes hide this setup block\n                \"metadata\": {\"tags\": [\"remove_cell\", \"remove_input\"]},\n                \"outputs\": [],\n                \"source\": [line + \"\\n\" for line in STYLE_CODE.splitlines()],\n            }\n\n            # Insert this cell at the very top of the notebook\n            nb[\"cells\"].insert(0, new_cell)\n\n            return json.dumps(nb)\n        except Exception as e:\n            print(f\"Error injecting style into {page.file.src_path}: {e}\")\n            return None\n\n    return None\n</pre> def on_page_read_source(page: Any, config: Any, **kwargs: Any) -&gt; str | None:     \"\"\"Inject style settings into notebooks before execution.\"\"\"     # Only act on Jupyter Notebooks     if page.file.src_path.endswith(\".ipynb\"):         try:             with open(page.file.abs_src_path, encoding=\"utf-8\") as f:                 nb = json.load(f)              # Create a new code cell with the style configuration             new_cell = {                 \"cell_type\": \"code\",                 \"execution_count\": None,                 # \"remove_cell\" tag helps some themes hide this setup block                 \"metadata\": {\"tags\": [\"remove_cell\", \"remove_input\"]},                 \"outputs\": [],                 \"source\": [line + \"\\n\" for line in STYLE_CODE.splitlines()],             }              # Insert this cell at the very top of the notebook             nb[\"cells\"].insert(0, new_cell)              return json.dumps(nb)         except Exception as e:             print(f\"Error injecting style into {page.file.src_path}: {e}\")             return None      return None In\u00a0[5]: Copied! <pre>def on_startup(command: str, dirty: bool, **kwargs: Any) -&gt; None:\n    \"\"\"Called once when the MkDocs build starts.\"\"\"\n</pre> def on_startup(command: str, dirty: bool, **kwargs: Any) -&gt; None:     \"\"\"Called once when the MkDocs build starts.\"\"\" In\u00a0[6]: Copied! <pre>def on_shutdown(**kwargs: Any) -&gt; None:\n    \"\"\"Called once when the MkDocs build ends.\"\"\"\n</pre> def on_shutdown(**kwargs: Any) -&gt; None:     \"\"\"Called once when the MkDocs build ends.\"\"\" In\u00a0[7]: Copied! <pre>def on_serve(server: Any, config: Any, builder: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Called when the MkDocs development server starts.\"\"\"\n</pre> def on_serve(server: Any, config: Any, builder: Any, **kwargs: Any) -&gt; None:     \"\"\"Called when the MkDocs development server starts.\"\"\" In\u00a0[8]: Copied! <pre>def on_config(config: Any, **kwargs: Any) -&gt; Any:\n    \"\"\"Called after config file is loaded but before validation.\"\"\"\n    return config\n</pre> def on_config(config: Any, **kwargs: Any) -&gt; Any:     \"\"\"Called after config file is loaded but before validation.\"\"\"     return config In\u00a0[9]: Copied! <pre>def on_pre_build(config: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Called before the build starts.\"\"\"\n</pre> def on_pre_build(config: Any, **kwargs: Any) -&gt; None:     \"\"\"Called before the build starts.\"\"\" In\u00a0[10]: Copied! <pre>def on_files(files: Any, config: Any, **kwargs: Any) -&gt; Any:\n    \"\"\"Called after files are gathered but before processing.\"\"\"\n    return files\n</pre> def on_files(files: Any, config: Any, **kwargs: Any) -&gt; Any:     \"\"\"Called after files are gathered but before processing.\"\"\"     return files In\u00a0[11]: Copied! <pre>def on_nav(nav: Any, config: Any, files: Any, **kwargs: Any) -&gt; Any:\n    \"\"\"Called after navigation is built.\"\"\"\n    return nav\n</pre> def on_nav(nav: Any, config: Any, files: Any, **kwargs: Any) -&gt; Any:     \"\"\"Called after navigation is built.\"\"\"     return nav In\u00a0[12]: Copied! <pre>def on_env(env: Any, config: Any, files: Any, **kwargs: Any) -&gt; Any:\n    \"\"\"Called after Jinja2 environment is created.\"\"\"\n    return env\n</pre> def on_env(env: Any, config: Any, files: Any, **kwargs: Any) -&gt; Any:     \"\"\"Called after Jinja2 environment is created.\"\"\"     return env In\u00a0[13]: Copied! <pre>def on_post_build(config: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Called after the build is complete.\"\"\"\n</pre> def on_post_build(config: Any, **kwargs: Any) -&gt; None:     \"\"\"Called after the build is complete.\"\"\" In\u00a0[14]: Copied! <pre>def on_pre_template(\n    template: Any, template_name: str, config: Any, **kwargs: Any\n) -&gt; Any:\n    \"\"\"Called before a template is rendered.\"\"\"\n    return template\n</pre> def on_pre_template(     template: Any, template_name: str, config: Any, **kwargs: Any ) -&gt; Any:     \"\"\"Called before a template is rendered.\"\"\"     return template In\u00a0[15]: Copied! <pre>def on_template_context(\n    context: Any, template_name: str, config: Any, **kwargs: Any\n) -&gt; Any:\n    \"\"\"Called after template context is created.\"\"\"\n    return context\n</pre> def on_template_context(     context: Any, template_name: str, config: Any, **kwargs: Any ) -&gt; Any:     \"\"\"Called after template context is created.\"\"\"     return context In\u00a0[16]: Copied! <pre>def on_post_template(\n    output: str, template_name: str, config: Any, **kwargs: Any\n) -&gt; str:\n    \"\"\"Called after template is rendered.\"\"\"\n    return output\n</pre> def on_post_template(     output: str, template_name: str, config: Any, **kwargs: Any ) -&gt; str:     \"\"\"Called after template is rendered.\"\"\"     return output In\u00a0[17]: Copied! <pre>def on_pre_page(page: Any, config: Any, files: Any, **kwargs: Any) -&gt; Any:\n    \"\"\"Called before a page is processed.\"\"\"\n    return page\n</pre> def on_pre_page(page: Any, config: Any, files: Any, **kwargs: Any) -&gt; Any:     \"\"\"Called before a page is processed.\"\"\"     return page <p>def on_page_read_source(page: Any, config: Any, **kwargs: Any) -&gt; str | None: \"\"\"Called to read the raw source of a page.\"\"\" return None</p> In\u00a0[18]: Copied! <pre>def on_page_markdown(\n    markdown: str, page: Any, config: Any, files: Any, **kwargs: Any\n) -&gt; str:\n    \"\"\"Process markdown content before it's converted to HTML.\"\"\"\n    blocks = markdown.split(\"```\")\n\n    for i, block in enumerate(blocks):\n        if i % 2:\n            # This is a code block\n            if (special := _parse_special(block)) is not None:\n                blocks[i] = special\n            else:\n                blocks[i] = f\"```{block}```\"\n            continue\n\n        # This is regular markdown content\n        lines = block.split(\"\\n\")\n        _insert_cross_refs(lines)\n        blocks[i] = \"\\n\".join(lines)\n\n    content = \"\".join(blocks)\n    return content\n</pre> def on_page_markdown(     markdown: str, page: Any, config: Any, files: Any, **kwargs: Any ) -&gt; str:     \"\"\"Process markdown content before it's converted to HTML.\"\"\"     blocks = markdown.split(\"```\")      for i, block in enumerate(blocks):         if i % 2:             # This is a code block             if (special := _parse_special(block)) is not None:                 blocks[i] = special             else:                 blocks[i] = f\"```{block}```\"             continue          # This is regular markdown content         lines = block.split(\"\\n\")         _insert_cross_refs(lines)         blocks[i] = \"\\n\".join(lines)      content = \"\".join(blocks)     return content In\u00a0[19]: Copied! <pre>def on_page_content(  # noqa: C901\n    html: str, page: Any, config: Any, files: Any, **kwargs: Any\n) -&gt; str:\n    \"\"\"Called after markdown is converted to HTML.\"\"\"\n    if \"```{svgbob}\" not in html:\n        return html\n\n    source_parts = []\n    for part in html.split(\"```\"):\n        if not part.startswith(\"{svgbob}\"):\n            continue\n        lines = part.split(\"\\n\")[1:]\n        for i, line in enumerate(lines):\n            lines[i] = \"\".join(re.split(r\"[&lt;&gt;]\", line)[::2])\n        part = dedent(\"\\n\".join(lines))\n        source_parts.append(lines)\n\n    rendered_parts = []\n    for i, part in enumerate(html.split('&lt;div class=\"language-text highlight\"&gt;')):\n        if i &gt; 0:\n            part = f'&lt;div class=\"language-text highlight\"&gt;{part}'\n        first, *rest = part.split(\"&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;\")\n        rest = \"&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;\".join(rest)\n        first = f\"{first}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;\"\n        rendered_parts.append(first)\n        rendered_parts.append(rest)\n\n    for i, part in enumerate(rendered_parts):\n        if not part.startswith('&lt;div class=\"language-text highlight\"&gt;'):\n            continue\n        lines = part.split(\"\\n\")\n        if (svgbob_source := _svgbob_source(lines, source_parts)) is None:\n            continue\n        if (svg := _svgbob_svg(svgbob_source)) is None:\n            continue\n        rendered_parts[i] = svg\n\n    return \"\".join(rendered_parts)\n</pre> def on_page_content(  # noqa: C901     html: str, page: Any, config: Any, files: Any, **kwargs: Any ) -&gt; str:     \"\"\"Called after markdown is converted to HTML.\"\"\"     if \"```{svgbob}\" not in html:         return html      source_parts = []     for part in html.split(\"```\"):         if not part.startswith(\"{svgbob}\"):             continue         lines = part.split(\"\\n\")[1:]         for i, line in enumerate(lines):             lines[i] = \"\".join(re.split(r\"[&lt;&gt;]\", line)[::2])         part = dedent(\"\\n\".join(lines))         source_parts.append(lines)      rendered_parts = []     for i, part in enumerate(html.split('')):         if i &gt; 0:             part = f'{part}'         first, *rest = part.split(\"\")         rest = \"\".join(rest)         first = f\"{first}\"         rendered_parts.append(first)         rendered_parts.append(rest)      for i, part in enumerate(rendered_parts):         if not part.startswith(''):             continue         lines = part.split(\"\\n\")         if (svgbob_source := _svgbob_source(lines, source_parts)) is None:             continue         if (svg := _svgbob_svg(svgbob_source)) is None:             continue         rendered_parts[i] = svg      return \"\".join(rendered_parts) In\u00a0[20]: Copied! <pre>def on_page_context(\n    context: Any, page: Any, config: Any, nav: Any, **kwargs: Any\n) -&gt; Any:\n    \"\"\"Called after page context is created.\"\"\"\n    return context\n</pre> def on_page_context(     context: Any, page: Any, config: Any, nav: Any, **kwargs: Any ) -&gt; Any:     \"\"\"Called after page context is created.\"\"\"     return context In\u00a0[21]: Copied! <pre>def on_post_page(output: str, page: Any, config: Any, **kwargs: Any) -&gt; str:\n    \"\"\"Called after page is fully processed.\"\"\"\n    return output\n</pre> def on_post_page(output: str, page: Any, config: Any, **kwargs: Any) -&gt; str:     \"\"\"Called after page is fully processed.\"\"\"     return output In\u00a0[22]: Copied! <pre>def _parse_special(content: str) -&gt; str | None:\n    \"\"\"Format contents of a special code block differently.\"\"\"\n    lines = content.strip().split(\"\\n\")\n    first = lines[0].strip()\n    rest = lines[1:]\n    if not (first.startswith(\"{\") and first.endswith(\"}\")):\n        return None\n    code_block_type = first[1:-1].strip()\n    if code_block_type == \"svgbob\":\n        source = \"\\n\".join(rest)\n        content_hash = hashlib.md5(source.encode()).hexdigest()\n        svg_content = _svgbob_svg(source)\n        if not svg_content:\n            return None\n        docs_dir = Path(__file__).parent\n        svg_path = docs_dir / \"assets\" / \"svgbob\" / f\"svgbob_{content_hash}.svg\"\n        svg_path.parent.mkdir(exist_ok=True, parents=True)\n        svg_path.write_text(svg_content or \"\")\n        return f\"\\n\\n![{svg_path.name}](/sax/{svg_path.relative_to(docs_dir)})\\n\\n\"\n    return _format_admonition(code_block_type, rest)\n</pre> def _parse_special(content: str) -&gt; str | None:     \"\"\"Format contents of a special code block differently.\"\"\"     lines = content.strip().split(\"\\n\")     first = lines[0].strip()     rest = lines[1:]     if not (first.startswith(\"{\") and first.endswith(\"}\")):         return None     code_block_type = first[1:-1].strip()     if code_block_type == \"svgbob\":         source = \"\\n\".join(rest)         content_hash = hashlib.md5(source.encode()).hexdigest()         svg_content = _svgbob_svg(source)         if not svg_content:             return None         docs_dir = Path(__file__).parent         svg_path = docs_dir / \"assets\" / \"svgbob\" / f\"svgbob_{content_hash}.svg\"         svg_path.parent.mkdir(exist_ok=True, parents=True)         svg_path.write_text(svg_content or \"\")         return f\"\\n\\n![{svg_path.name}](/sax/{svg_path.relative_to(docs_dir)})\\n\\n\"     return _format_admonition(code_block_type, rest) In\u00a0[23]: Copied! <pre>def _format_admonition(admonition_type: str, lines: list[str]) -&gt; str:\n    \"\"\"Format lines as an admonition.\"\"\"\n    if admonition_type == \"hint\":\n        admonition_type = \"info\"\n    ret = f\"!!! {admonition_type}\\n\\n\"\n    for line in lines:\n        ret += f\"    {line.strip()}\\n\"\n    return ret\n</pre> def _format_admonition(admonition_type: str, lines: list[str]) -&gt; str:     \"\"\"Format lines as an admonition.\"\"\"     if admonition_type == \"hint\":         admonition_type = \"info\"     ret = f\"!!! {admonition_type}\\n\\n\"     for line in lines:         ret += f\"    {line.strip()}\\n\"     return ret In\u00a0[24]: Copied! <pre>def _svgbob_svg(source: str) -&gt; str | None:\n    source = source.replace(\"&amp;lt;\", \"&lt;\").replace(\"&amp;gt;\", \"&gt;\")\n    svgbob = shutil.which(\"svgbob_cli\")\n    if not svgbob:\n        print(\"Warning: svgbob_cli is not installed or not found in PATH.\")  # noqa: T201\n        return None\n    content_hash = hashlib.md5(source.encode()).hexdigest()\n    txt_filename = f\"svgbob_{content_hash}.txt\"\n    temp_path = Path(tempfile.gettempdir()).resolve() / \"svgbob\" / txt_filename\n    temp_path.parent.mkdir(exist_ok=True)\n    try:\n        temp_path.write_text(source)\n        return subprocess.check_output(  # noqa: S603\n            [\n                svgbob,\n                \"--background\",\n                \"#00000000\",\n                \"--stroke-color\",\n                \"grey\",\n                \"--fill-color\",\n                \"grey\",\n                str(temp_path),\n            ]\n        ).decode()\n    except Exception as e:  # noqa: BLE001\n        print(f\"Warning: Error generating SVG with svgbob: {e}\")  # noqa: T201\n        return None\n    finally:\n        temp_path.unlink()\n</pre> def _svgbob_svg(source: str) -&gt; str | None:     source = source.replace(\"&lt;\", \"&lt;\").replace(\"&gt;\", \"&gt;\")     svgbob = shutil.which(\"svgbob_cli\")     if not svgbob:         print(\"Warning: svgbob_cli is not installed or not found in PATH.\")  # noqa: T201         return None     content_hash = hashlib.md5(source.encode()).hexdigest()     txt_filename = f\"svgbob_{content_hash}.txt\"     temp_path = Path(tempfile.gettempdir()).resolve() / \"svgbob\" / txt_filename     temp_path.parent.mkdir(exist_ok=True)     try:         temp_path.write_text(source)         return subprocess.check_output(  # noqa: S603             [                 svgbob,                 \"--background\",                 \"#00000000\",                 \"--stroke-color\",                 \"grey\",                 \"--fill-color\",                 \"grey\",                 str(temp_path),             ]         ).decode()     except Exception as e:  # noqa: BLE001         print(f\"Warning: Error generating SVG with svgbob: {e}\")  # noqa: T201         return None     finally:         temp_path.unlink() In\u00a0[25]: Copied! <pre>def _svgbob_source(\n    rendered_lines: list[str], source_parts: list[list[str]]\n) -&gt; str | None:\n    for source_lines in source_parts:\n        if all(\n            sl.strip() in rl\n            for sl, rl in zip(source_lines, rendered_lines, strict=False)\n        ):\n            return \"\\n\".join(source_lines)\n    return None\n</pre> def _svgbob_source(     rendered_lines: list[str], source_parts: list[list[str]] ) -&gt; str | None:     for source_lines in source_parts:         if all(             sl.strip() in rl             for sl, rl in zip(source_lines, rendered_lines, strict=False)         ):             return \"\\n\".join(source_lines)     return None In\u00a0[26]: Copied! <pre>def _insert_cross_refs(lines: list[str]) -&gt; None:\n    \"\"\"Insert cross-references in the markdown lines.\"\"\"\n</pre> def _insert_cross_refs(lines: list[str]) -&gt; None:     \"\"\"Insert cross-references in the markdown lines.\"\"\""},{"location":"writing_components/","title":"Writing Components","text":""},{"location":"writing_components/#writing-components","title":"Writing Components","text":"<p>Circulax uses a functional, JAX-first approach to component definition. Instead of inheriting from complex base classes, you define components as pure Python functions decorated with specific handlers.</p> <p>This architecture ensures your components are automatically compatible with JIT compilation (jax.jit), vectorization (jax.vmap), and back-propagation (jax.grad).</p>"},{"location":"writing_components/#the-core-concept","title":"The Core Concept","text":"<p>Every component in circulax is a function that calculates the instantaneous balance equations for a specific node or state. The function signature generally looks like this:</p> <pre><code>def MyComponent(signals, s, [t], **params):\n    # 1. Calculate physics\n    # 2. Return (Flows, Storage)\n</code></pre>"},{"location":"writing_components/#arguments","title":"Arguments","text":"<p>1) <code>signals</code> (Ports): A NamedTuple containing the potential (Voltage) at every port defined in the decorator. Accessed via dot notation (e.g., signals.p, signals.gate).</p> <p>2) <code>s</code> (States): A NamedTuple containing internal state variables (e.g., current through an inductor, internal node voltages).</p> <p>3) <code>t</code> (Time): Optional. Only present if you use the @source decorator.</p> <p>4) <code>**params</code>: Keyword arguments defining the physical properties (Resistance, Length, Refractive Index).</p>"},{"location":"writing_components/#return-values","title":"Return Values","text":"<p>The function must return a tuple of two dictionaries: <code>(f_dict, q_dict)</code>.</p> <ul> <li> <p><code>f_dict</code> (The Flow/Balance Vector):</p> <ul> <li> <p>For Ports: Represents the \"Flow\" (Current) entering the node.</p> </li> <li> <p>For States: Represents the algebraic constraint (should sum to 0).</p> </li> </ul> </li> <li> <p><code>q_dict</code> (The Storage Vector):</p> <ul> <li> <p>Represents the time-dependent quantity (Charge, Flux) stored in a variable.</p> </li> <li> <p>The solver computes \\(\\frac{d}{dt}(q\\_dict)\\).</p> </li> </ul> </li> </ul>"},{"location":"writing_components/#electronic-components-time-invariant","title":"Electronic Components (Time-Invariant)","text":"<p>Most passive components (Resistors, Transistors, Diodes) do not depend explicitly on time t. For these, use the <code>@component</code> decorator.</p>"},{"location":"writing_components/#example-a-simple-resistor","title":"Example: A Simple Resistor","text":"<pre><code>import jax.numpy as jnp\nfrom circulax.base_component import component, Signals, States\n\n@component(ports=(\"p\", \"n\"))\ndef Resistor(signals: Signals, s: States, R: float = 1e3):\n    \"\"\"\n    Ohm's Law: I = V / R\n    \"\"\"\n    # 1. Calculate the physics\n    v_drop = signals.p - signals.n\n    i = v_drop / (R + 1e-12)  # Add epsilon for stability\n\n    # 2. Assign currents to ports\n    # Current leaves 'p' and enters 'n' (Passive convention)\n    f_dict = {\n        \"p\": i,\n        \"n\": -i\n    }\n\n    # Resistors have no memory (no d/dt terms)\n    q_dict = {}\n\n    return f_dict, q_dict\n</code></pre>"},{"location":"writing_components/#example-a-capacitor-time-derivative","title":"Example: A Capacitor (Time-Derivative)","text":"<p>For reactive components, use the second return dictionary (q_dict) to define what is being differentiated.</p> <pre><code>@component(ports=(\"p\", \"n\"))\ndef Capacitor(signals: Signals, s: States, C: float = 1e-6):\n    \"\"\"\n    I = C * dV/dt  =&gt;  I = dQ/dt\n    \"\"\"\n    v_drop = signals.p - signals.n\n\n    # We define Charge (q)\n    q_val = C * v_drop\n\n    # The solver treats q_dict as the \"Mass Matrix\" side.\n    # The entries in q_dict are differentiated with respect to time.\n    # p: I_p = d(q_val)/dt\n    return {}, {\"p\": q_val, \"n\": -q_val}\n</code></pre>"},{"location":"writing_components/#time-dependent-sources","title":"Time-Dependent Sources","text":"<p>If your component varies with time (e.g., AC source, Pulse generator), use the @source decorator. This injects t as the third argument.</p> <p>Example: AC Voltage Source</p> <p>Voltage sources require an Internal State variable (i_src) to represent the current flowing through the source. This is because the voltage is fixed, so the current is the unknown variable the solver must find.</p> <p>from circulax.base_component import source</p> <pre><code>@source(ports=(\"p\", \"n\"), states=(\"i_src\",))\ndef ACSource(signals: Signals, s: States, t: float, V: float = 1.0, freq: float = 60.0):\n    # 1. Calculate Target Voltage based on time 't'\n    target_v = V * jnp.sin(2 * jnp.pi * freq * t)\n\n    # 2. Define the Constraint Equation\n    # We want: (vp - vn) = target_v\n    # Therefore: (vp - vn) - target_v = 0\n    constraint = (signals.p - signals.n) - target_v\n\n    return {\n        # KCL: The unknown current 'i_src' leaves p and enters n\n        \"p\": s.i_src,\n        \"n\": -s.i_src,\n\n        # Constraint: The solver adjusts 'i_src' until this equation equals 0\n        \"i_src\": constraint\n    }, {}\n</code></pre>"},{"location":"writing_components/#photonic-components-frequency-domain","title":"Photonic Components (Frequency Domain)","text":"<p>Circulax can simulate photonic circuits by treating them as complex-valued resistor networks. You typically start with an S-Matrix, convert it to an Admittance (Y) Matrix, and calculate currents via \\(I = Y \\cdot V\\).</p> <p>Example: Optical Waveguide</p> <pre><code>from circulax.s_transforms import s_to_y\n\n@component(ports=(\"in\", \"out\"))\ndef Waveguide(signals: Signals, s: States, length_um: float = 100.0, neff: float = 2.4, wl: float = 1.55):\n    # 1. Physics: Calculate Phase Shift\n    # Note: Use jnp (JAX numpy) for all math\n    phi = 2.0 * jnp.pi * neff * length_um / wl\n\n    # 2. Construct S-Matrix (Transmission)\n    # T = exp(-j * phi)\n    T = jnp.exp(-1j * phi)\n\n    # S = [[0, T],\n    #      [T, 0]]\n    S = jnp.array([\n        [0.0, T],\n        [T, 0.0]\n    ], dtype=jnp.complex128)\n\n    # 3. Convert to Admittance (Y)\n    Y = s_to_y(S)\n\n    # 4. Calculate Currents: I = Y @ V\n    # IMPORTANT: Cast inputs to complex128!\n    v_vec = jnp.array([signals.in, signals.out], dtype=jnp.complex128)\n    i_vec = Y @ v_vec\n\n    return {\"in\": i_vec[0], \"out\": i_vec[1]}, {}\n</code></pre>"},{"location":"writing_components/#integration-with-sax","title":"Integration with SAX","text":"<p>If you have existing models written for SAX, you can reuse them directly without rewriting physics logic using the @sax_component decorator.</p> <pre><code>from circulax.sax_integration import sax_component\n\n# 1. Define or Import a pure SAX model\ndef sax_coupler(coupling=0.5):\n    kappa = coupling**0.5\n    tau = (1 - coupling)**0.5\n    return {\n        (\"in0\", \"out0\"): tau,\n        (\"in0\", \"out1\"): 1j*kappa,\n        (\"in1\", \"out0\"): 1j*kappa,\n        (\"in1\", \"out1\"): tau\n    }\n\n# 2. Convert to circulax Component\n# This automatically detects ports ('in0', 'in1', 'out0', 'out1')\nCoupler = sax_component(sax_coupler)\n</code></pre>"},{"location":"writing_components/#advanced-under-the-hood","title":"Advanced: Under the Hood","text":"<p>For advanced users familiar with JAX and Equinox, it is helpful to understand what the @component decorator actually does.</p> <p>It does not simply wrap your function. Instead, it dynamically generates a new class that inherits from equinox.Module.</p> <p>The Transformation Process</p> <p>When you write:</p> <pre><code>@component(ports=(\"a\", \"b\"))\ndef MyResistor(signals, s, R=100.0):\n</code></pre> <p>The decorator performs the following steps:</p> <p>Introspection: It analyzes the function signature to identify parameters (R) and their default values (100.0).</p> <p>Class Generation: It constructs a new eqx.Module class named MyResistor.</p> <p>Field Registration: The parameters (R) become fields of this class. This allows JAX to differentiate with respect to R automatically.</p> <p>Static Optimization: It creates a static _fast_physics method that unrolls dictionary lookups into raw array operations. This is what the solver calls inside <code>jax.jit</code> or <code>jax.vmap</code>.</p>"},{"location":"examples/LCR/","title":"LCR","text":"In\u00a0[1]: Copied! <pre>import diffrax\nimport jax\nimport jax.numpy as jnp\nimport matplotlib.pyplot as plt\n\nfrom circulax.compiler import compile_netlist\nfrom circulax.components.electronic import Capacitor, Inductor, Resistor, VoltageSource\nfrom circulax.solvers import analyze_circuit, setup_transient\n</pre> import diffrax import jax import jax.numpy as jnp import matplotlib.pyplot as plt  from circulax.compiler import compile_netlist from circulax.components.electronic import Capacitor, Inductor, Resistor, VoltageSource from circulax.solvers import analyze_circuit, setup_transient In\u00a0[2]: Copied! <pre>net_dict = {\n    \"instances\": {\n        \"GND\": {\"component\": \"ground\"},\n        \"V1\": {\"component\": \"source_voltage\", \"settings\": {\"V\": 1.0, \"delay\": 0.25e-9}},\n        \"R1\": {\"component\": \"resistor\", \"settings\": {\"R\": 10.0}},\n        \"C1\": {\"component\": \"capacitor\", \"settings\": {\"C\": 1e-11}},\n        \"L1\": {\"component\": \"inductor\", \"settings\": {\"L\": 5e-9}},\n    },\n    \"connections\": {\n        \"GND,p1\": (\"V1,p2\", \"C1,p2\"),\n        \"V1,p1\": \"R1,p1\",\n        \"R1,p2\": \"L1,p1\",\n        \"L1,p2\": \"C1,p1\",\n    },\n}\n</pre> net_dict = {     \"instances\": {         \"GND\": {\"component\": \"ground\"},         \"V1\": {\"component\": \"source_voltage\", \"settings\": {\"V\": 1.0, \"delay\": 0.25e-9}},         \"R1\": {\"component\": \"resistor\", \"settings\": {\"R\": 10.0}},         \"C1\": {\"component\": \"capacitor\", \"settings\": {\"C\": 1e-11}},         \"L1\": {\"component\": \"inductor\", \"settings\": {\"L\": 5e-9}},     },     \"connections\": {         \"GND,p1\": (\"V1,p2\", \"C1,p2\"),         \"V1,p1\": \"R1,p1\",         \"R1,p2\": \"L1,p1\",         \"L1,p2\": \"C1,p1\",     }, } In\u00a0[4]: Copied! <pre>from circulax.netlist import draw_circuit_graph\n\ndraw_circuit_graph(netlist=net_dict);\n</pre> from circulax.netlist import draw_circuit_graph  draw_circuit_graph(netlist=net_dict); In\u00a0[5]: Copied! <pre>jax.config.update(\"jax_enable_x64\", True)\n\n\nmodels_map = {\n    \"resistor\": Resistor,\n    \"capacitor\": Capacitor,\n    \"inductor\": Inductor,\n    \"source_voltage\": VoltageSource,\n    \"ground\": lambda: 0,\n}\n\nprint(\"Compiling...\")\ngroups, sys_size, port_map = compile_netlist(net_dict, models_map)\n\nprint(port_map)\n\nprint(f\"Total System Size: {sys_size}\")\nfor g_name, g in groups.items():\n    print(f\"Group: {g_name}\")\n    print(f\"  Count: {g.var_indices.shape[0]}\")\n    print(f\"  Var Indices Shape: {g.var_indices.shape}\")\n    print(f\"  Sample Var Indices:{g.var_indices}\")\n    print(f\"  Jacobian Rows Length: {len(g.jac_rows)}\")\n\nprint(\"2. Solving DC Operating Point...\")\nlinear_strat = analyze_circuit(groups, sys_size, is_complex=False)\n\ny_guess = jnp.zeros(sys_size)\ny_op = linear_strat.solve_dc(groups, y_guess)\n\ntransient_sim = setup_transient(groups=groups, linear_strategy=linear_strat)\nterm = diffrax.ODETerm(lambda t, y, args: jnp.zeros_like(y))\n\n\nt_max = 3e-9\nsaveat = diffrax.SaveAt(ts=jnp.linspace(0, t_max, 500))\nprint(\"3. Running Simulation...\")\nsol = transient_sim(\n    t0=0.0,\n    t1=t_max,\n    dt0=1e-3 * t_max,\n    y0=y_op,\n    saveat=saveat,\n    max_steps=100000,\n    progress_meter=diffrax.TqdmProgressMeter(refresh_steps=100),\n)\n\nts = sol.ts\nv_src = sol.ys[:, port_map[\"V1,p1\"]]\nv_cap = sol.ys[:, port_map[\"C1,p1\"]]\ni_ind = sol.ys[:, 5]\n\nprint(\"4. Plotting...\")\nfig, ax1 = plt.subplots(figsize=(8, 5))\nax1.plot(ts, v_src, \"k--\", label=\"Source V\")\nax1.plot(ts, v_cap, \"b-\", label=\"Capacitor V\")\nax1.set_xlabel(\"Time (s)\")\nax1.set_ylabel(\"Voltage (V)\")\nax1.legend(loc=\"upper left\")\n\nax2 = ax1.twinx()\nax2.plot(ts, i_ind, \"r:\", label=\"Inductor I\")\nax2.set_ylabel(\"Current (A)\")\nax2.legend(loc=\"upper right\")\n\nax2_ticks = ax2.get_yticks()\nax1_ticks = ax1.get_yticks()\nax2.set_yticks(jnp.linspace(ax2_ticks[0], ax2_ticks[-1], len(ax1_ticks)))\nax1.set_yticks(jnp.linspace(ax1_ticks[0], ax1_ticks[-1], len(ax1_ticks)))\n\nplt.title(\"Impulse Response of LCR circuit\")\nplt.grid(True)\nplt.show()\n</pre> jax.config.update(\"jax_enable_x64\", True)   models_map = {     \"resistor\": Resistor,     \"capacitor\": Capacitor,     \"inductor\": Inductor,     \"source_voltage\": VoltageSource,     \"ground\": lambda: 0, }  print(\"Compiling...\") groups, sys_size, port_map = compile_netlist(net_dict, models_map)  print(port_map)  print(f\"Total System Size: {sys_size}\") for g_name, g in groups.items():     print(f\"Group: {g_name}\")     print(f\"  Count: {g.var_indices.shape[0]}\")     print(f\"  Var Indices Shape: {g.var_indices.shape}\")     print(f\"  Sample Var Indices:{g.var_indices}\")     print(f\"  Jacobian Rows Length: {len(g.jac_rows)}\")  print(\"2. Solving DC Operating Point...\") linear_strat = analyze_circuit(groups, sys_size, is_complex=False)  y_guess = jnp.zeros(sys_size) y_op = linear_strat.solve_dc(groups, y_guess)  transient_sim = setup_transient(groups=groups, linear_strategy=linear_strat) term = diffrax.ODETerm(lambda t, y, args: jnp.zeros_like(y))   t_max = 3e-9 saveat = diffrax.SaveAt(ts=jnp.linspace(0, t_max, 500)) print(\"3. Running Simulation...\") sol = transient_sim(     t0=0.0,     t1=t_max,     dt0=1e-3 * t_max,     y0=y_op,     saveat=saveat,     max_steps=100000,     progress_meter=diffrax.TqdmProgressMeter(refresh_steps=100), )  ts = sol.ts v_src = sol.ys[:, port_map[\"V1,p1\"]] v_cap = sol.ys[:, port_map[\"C1,p1\"]] i_ind = sol.ys[:, 5]  print(\"4. Plotting...\") fig, ax1 = plt.subplots(figsize=(8, 5)) ax1.plot(ts, v_src, \"k--\", label=\"Source V\") ax1.plot(ts, v_cap, \"b-\", label=\"Capacitor V\") ax1.set_xlabel(\"Time (s)\") ax1.set_ylabel(\"Voltage (V)\") ax1.legend(loc=\"upper left\")  ax2 = ax1.twinx() ax2.plot(ts, i_ind, \"r:\", label=\"Inductor I\") ax2.set_ylabel(\"Current (A)\") ax2.legend(loc=\"upper right\")  ax2_ticks = ax2.get_yticks() ax1_ticks = ax1.get_yticks() ax2.set_yticks(jnp.linspace(ax2_ticks[0], ax2_ticks[-1], len(ax1_ticks))) ax1.set_yticks(jnp.linspace(ax1_ticks[0], ax1_ticks[-1], len(ax1_ticks)))  plt.title(\"Impulse Response of LCR circuit\") plt.grid(True) plt.show() <pre>Compiling...\n{'L1,p2': 1, 'C1,p1': 1, 'GND,p1': 0, 'V1,p2': 0, 'C1,p2': 0, 'R1,p2': 2, 'L1,p1': 2, 'V1,p1': 3, 'R1,p1': 3}\nTotal System Size: 6\nGroup: source_voltage\n  Count: 1\n  Var Indices Shape: (1, 3)\n  Sample Var Indices:[[3 0 4]]\n  Jacobian Rows Length: 1\nGroup: resistor\n  Count: 1\n  Var Indices Shape: (1, 2)\n  Sample Var Indices:[[3 2]]\n  Jacobian Rows Length: 1\nGroup: capacitor\n  Count: 1\n  Var Indices Shape: (1, 2)\n  Sample Var Indices:[[1 0]]\n  Jacobian Rows Length: 1\nGroup: inductor\n  Count: 1\n  Var Indices Shape: (1, 3)\n  Sample Var Indices:[[2 1 5]]\n  Jacobian Rows Length: 1\n2. Solving DC Operating Point...\n</pre> <pre>3. Running Simulation...\n</pre> <pre>\r0.00%|          | [00:00&lt;?, ?%/s]</pre> <pre>\r0.10%|          | [00:00&lt;00:03, 27.53%/s]</pre> <pre>\r10.10%|\u2588         | [00:00&lt;00:00, 1598.58%/s]</pre> <pre>\r20.10%|\u2588\u2588        | [00:00&lt;00:00, 2123.51%/s]</pre> <pre>\r30.10%|\u2588\u2588\u2588       | [00:00&lt;00:00, 2498.68%/s]</pre> <pre>\r40.10%|\u2588\u2588\u2588\u2588      | [00:00&lt;00:00, 2676.89%/s]</pre> <pre>\r50.10%|\u2588\u2588\u2588\u2588\u2588     | [00:00&lt;00:00, 2784.20%/s]</pre> <pre>\r60.10%|\u2588\u2588\u2588\u2588\u2588\u2588    | [00:00&lt;00:00, 2882.17%/s]</pre> <pre>\r70.10%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | [00:00&lt;00:00, 2992.79%/s]</pre> <pre>\r80.10%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  | [00:00&lt;00:00, 3089.01%/s]</pre> <pre>\r90.10%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | [00:00&lt;00:00, 3175.53%/s]</pre> <pre>\r100.00%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| [00:00&lt;00:00, 3213.04%/s]</pre> <pre>\n</pre> <pre>4. Plotting...\n</pre>"},{"location":"examples/LCR/#lrc-circuit","title":"LRC Circuit\u00b6","text":""},{"location":"examples/LCR/#introduction","title":"Introduction\u00b6","text":"<p>In this example, we simulate a classical Series RLC Circuit operating in the Gigahertz (RF) regime. The circuit consists of a voltage source, a resistor ($10\\Omega$), an inductor ($5\\text{nH}$), and a capacitor ($10\\text{pF}$) connected in series.</p> <p>The behavior of the circuit is determined by the relationship between the resistance ($R$) and the critical damping resistance, defined as $ R_{c} = 2\\sqrt{L/C}$</p> <p>For this specific configuration:</p> <ul> <li>Critical Resistance ($R_c$): $2\\sqrt{L/C} \\approx 44.7\\Omega$.</li> <li>Actual Resistance ($R$): $10\\Omega$.</li> </ul> <p>Since $R &lt; R_c$, the system is underdamped. When the voltage source is activated, energy oscillates\u2014or \"sloshes\"\u2014between the inductor\u2019s magnetic field and the capacitor\u2019s electric field. This creates a characteristic \"ringing\" effect (transient oscillation) that gradually decays as the resistor dissipates the energy as heat.</p>"},{"location":"examples/LCR/#visualize-the-nodes","title":"Visualize the nodes\u00b6","text":""},{"location":"examples/LC_ladder/","title":"LC ladder","text":"In\u00a0[1]: Copied! <pre>import time\n\nimport diffrax\nimport jax\nimport jax.numpy as jnp\nimport matplotlib.pyplot as plt\n\nfrom circulax.compiler import compile_netlist\nfrom circulax.components.electronic import (\n    Capacitor,\n    Inductor,\n    Resistor,\n    SmoothPulse,\n)\nfrom circulax.solvers import analyze_circuit, setup_transient\n\njax.config.update(\"jax_enable_x64\", True)\n</pre> import time  import diffrax import jax import jax.numpy as jnp import matplotlib.pyplot as plt  from circulax.compiler import compile_netlist from circulax.components.electronic import (     Capacitor,     Inductor,     Resistor,     SmoothPulse, ) from circulax.solvers import analyze_circuit, setup_transient  jax.config.update(\"jax_enable_x64\", True) In\u00a0[2]: Copied! <pre>N_SECTIONS = 1000\nT_MAX = 5 * N_SECTIONS * 0.5e-9\nFREQ = 5.0 / T_MAX\nR_SOURCE = 50.0\nR_LOAD = 50.0\n</pre> N_SECTIONS = 1000 T_MAX = 5 * N_SECTIONS * 0.5e-9 FREQ = 5.0 / T_MAX R_SOURCE = 50.0 R_LOAD = 50.0 In\u00a0[3]: Copied! <pre>def create_lc_ladder(n_sections):\n    \"\"\"\n    Generates a netlist for an L-C transmission line.\n    V_in -&gt; R_source -&gt; [L-C] -&gt; [L-C] ... -&gt; R_load -&gt; GND\n    \"\"\"\n    net = {\n        \"instances\": {\n            \"GND\": {\"component\": \"ground\"},\n            \"Vin\": {\n                \"component\": \"voltage_source\",\n                \"settings\": {\"V\": 1.0, \"delay\": 2e-9, \"tr\": 1e-11},\n            },  # Step at 1ns\n            # \"Vin\": {\"component\": \"voltage_source\", \"settings\": {\"V\": 1.0, \"freq\":FREQ}}, # Step at 1ns\n            \"Rs\": {\"component\": \"resistor\", \"settings\": {\"R\": R_SOURCE}},\n            \"Rl\": {\"component\": \"resistor\", \"settings\": {\"R\": R_LOAD}},\n        },\n        \"connections\": {},\n    }\n\n    # 1. Input Stage: GND -&gt; Vin -&gt; Rs -&gt; Node_0\n    net[\"connections\"][\"GND,p1\"] = (\"Vin,p2\", \"Rl,p2\")  # Ground input and load\n    net[\"connections\"][\"Vin,p1\"] = \"Rs,p1\"\n\n    previous_node = \"Rs,p2\"\n\n    # 2. Ladder Generation\n    for i in range(n_sections):\n        l_name = f\"L_{i}\"\n        c_name = f\"C_{i}\"\n        # node_inter = f\"n_{i}\"  # Node between L and C\n\n        # Add Components\n        # L=10nH, C=4pF -&gt; Z0 = sqrt(L/C) = 50 Ohms.\n        # Delay per stage = sqrt(LC) = 200ps.\n        net[\"instances\"][l_name] = {\"component\": \"inductor\", \"settings\": {\"L\": 10e-9}}\n        net[\"instances\"][c_name] = {\"component\": \"capacitor\", \"settings\": {\"C\": 4e-12}}\n\n        # Connections\n        # Prev -&gt; L -&gt; Inter -&gt; C -&gt; GND\n        # Prev -&gt; L -&gt; Inter -&gt; Next L...\n\n        # Connect L: Previous Node -&gt; Inter Node\n        net[\"connections\"][f\"{l_name},p1\"] = previous_node\n        net[\"connections\"][f\"{l_name},p2\"] = f\"{c_name},p1\"  # Connect L to C\n\n        # Connect C: Inter Node -&gt; GND\n        net[\"connections\"][\"GND,p1\"] = (*net[\"connections\"][\"GND,p1\"], f\"{c_name},p2\")\n\n        # Advance\n        previous_node = (\n            f\"{l_name},p2\"  # The node after the inductor is the input to the next\n        )\n\n    # 3. Termination\n    net[\"connections\"][\"Rl,p1\"] = previous_node\n\n    return net\n</pre> def create_lc_ladder(n_sections):     \"\"\"     Generates a netlist for an L-C transmission line.     V_in -&gt; R_source -&gt; [L-C] -&gt; [L-C] ... -&gt; R_load -&gt; GND     \"\"\"     net = {         \"instances\": {             \"GND\": {\"component\": \"ground\"},             \"Vin\": {                 \"component\": \"voltage_source\",                 \"settings\": {\"V\": 1.0, \"delay\": 2e-9, \"tr\": 1e-11},             },  # Step at 1ns             # \"Vin\": {\"component\": \"voltage_source\", \"settings\": {\"V\": 1.0, \"freq\":FREQ}}, # Step at 1ns             \"Rs\": {\"component\": \"resistor\", \"settings\": {\"R\": R_SOURCE}},             \"Rl\": {\"component\": \"resistor\", \"settings\": {\"R\": R_LOAD}},         },         \"connections\": {},     }      # 1. Input Stage: GND -&gt; Vin -&gt; Rs -&gt; Node_0     net[\"connections\"][\"GND,p1\"] = (\"Vin,p2\", \"Rl,p2\")  # Ground input and load     net[\"connections\"][\"Vin,p1\"] = \"Rs,p1\"      previous_node = \"Rs,p2\"      # 2. Ladder Generation     for i in range(n_sections):         l_name = f\"L_{i}\"         c_name = f\"C_{i}\"         # node_inter = f\"n_{i}\"  # Node between L and C          # Add Components         # L=10nH, C=4pF -&gt; Z0 = sqrt(L/C) = 50 Ohms.         # Delay per stage = sqrt(LC) = 200ps.         net[\"instances\"][l_name] = {\"component\": \"inductor\", \"settings\": {\"L\": 10e-9}}         net[\"instances\"][c_name] = {\"component\": \"capacitor\", \"settings\": {\"C\": 4e-12}}          # Connections         # Prev -&gt; L -&gt; Inter -&gt; C -&gt; GND         # Prev -&gt; L -&gt; Inter -&gt; Next L...          # Connect L: Previous Node -&gt; Inter Node         net[\"connections\"][f\"{l_name},p1\"] = previous_node         net[\"connections\"][f\"{l_name},p2\"] = f\"{c_name},p1\"  # Connect L to C          # Connect C: Inter Node -&gt; GND         net[\"connections\"][\"GND,p1\"] = (*net[\"connections\"][\"GND,p1\"], f\"{c_name},p2\")          # Advance         previous_node = (             f\"{l_name},p2\"  # The node after the inductor is the input to the next         )      # 3. Termination     net[\"connections\"][\"Rl,p1\"] = previous_node      return net In\u00a0[5]: Copied! <pre>models_map = {\n    \"resistor\": Resistor,\n    \"capacitor\": Capacitor,\n    \"inductor\": Inductor,\n    \"voltage_source\": SmoothPulse,\n    \"ground\": lambda: 0,\n}\n\n\nprint(f\"Generating {N_SECTIONS}-stage LC Ladder...\")\nnet_dict = create_lc_ladder(N_SECTIONS)\n\nt0_compile = time.time()\ngroups, sys_size, port_map = compile_netlist(net_dict, models_map)\nprint(f\"Compilation finished in {time.time() - t0_compile:.4f}s\")\nprint(f\"System Matrix Size: {sys_size}x{sys_size} ({sys_size**2} elements)\")\n\nlinear_strat = analyze_circuit(groups, sys_size, is_complex=False)\n\nprint(\"Solving DC Operating Point...\")\ny0 = linear_strat.solve_dc(groups, jnp.zeros(sys_size))\n\ntransient_sim = setup_transient(groups=groups, linear_strategy=linear_strat)\n\nprint(\"Running Transient Simulation...\")\n\nterm = diffrax.ODETerm(lambda t, y, args: jnp.zeros_like(y))\n\nstep_controller = diffrax.PIDController(\n    rtol=1e-3,\n    atol=1e-4,\n    pcoeff=0.2,\n    icoeff=0.5,\n    dcoeff=0.0,\n    force_dtmin=True,\n    dtmin=1e-14,\n    dtmax=1e-9,\n    error_order=2,\n)\n\nt0_sim = time.time()\nsol = transient_sim(\n    t0=0.0,\n    t1=T_MAX,\n    dt0=1e-11,\n    y0=y0,\n    stepsize_controller=step_controller,\n    max_steps=1000000,\n    saveat=diffrax.SaveAt(ts=jnp.linspace(0, T_MAX, 200)),\n    progress_meter=diffrax.TqdmProgressMeter(refresh_steps=100),\n)\n\nif sol.result == diffrax.RESULTS.successful:\n    print(\"   \u2705 Simulation Successful\")\n\n    t_end_sim = time.time()\n    print(f\"Simulation completed in {t_end_sim - t0_sim:.4f}s\")\n    print(f\"Total Steps: {sol.stats['num_steps']}\")\n\n    node_out_idx = port_map[\"Rl,p1\"]\n    node_in_idx = port_map[\"Rs,p2\"]\n\n    ts = sol.ts * 1e9\n    v_in = sol.ys[:, node_in_idx]\n    v_out = sol.ys[:, node_out_idx]\n\n    plt.figure(figsize=(10, 6))\n    plt.plot(ts, v_in, \"r--\", alpha=0.6, label=\"Line Input (Rs,p2)\")\n    plt.plot(ts, v_out, \"b-\", linewidth=1.5, label=f\"Output (Stage {N_SECTIONS})\")\n\n    plt.title(f\"LC Ladder Propagation Delay ({N_SECTIONS} Sections)\")\n    plt.xlabel(\"Time (ns)\")\n    plt.ylabel(\"Voltage (V)\")\n    plt.legend(loc=\"upper left\")\n    plt.grid(True)\n\n    theory_delay = N_SECTIONS * jnp.sqrt(10e-9 * 4e-12) * 1e9\n    plt.axvline(\n        theory_delay + 1.0, color=\"green\", linestyle=\":\", label=\"Theoretical Arrival\"\n    )\n    plt.legend()\n\n    plt.show()\nelse:\n    print(\"   \u274c Simulation Failed\")\n    print(f\"   Result Code: {sol.result}\")\n</pre> models_map = {     \"resistor\": Resistor,     \"capacitor\": Capacitor,     \"inductor\": Inductor,     \"voltage_source\": SmoothPulse,     \"ground\": lambda: 0, }   print(f\"Generating {N_SECTIONS}-stage LC Ladder...\") net_dict = create_lc_ladder(N_SECTIONS)  t0_compile = time.time() groups, sys_size, port_map = compile_netlist(net_dict, models_map) print(f\"Compilation finished in {time.time() - t0_compile:.4f}s\") print(f\"System Matrix Size: {sys_size}x{sys_size} ({sys_size**2} elements)\")  linear_strat = analyze_circuit(groups, sys_size, is_complex=False)  print(\"Solving DC Operating Point...\") y0 = linear_strat.solve_dc(groups, jnp.zeros(sys_size))  transient_sim = setup_transient(groups=groups, linear_strategy=linear_strat)  print(\"Running Transient Simulation...\")  term = diffrax.ODETerm(lambda t, y, args: jnp.zeros_like(y))  step_controller = diffrax.PIDController(     rtol=1e-3,     atol=1e-4,     pcoeff=0.2,     icoeff=0.5,     dcoeff=0.0,     force_dtmin=True,     dtmin=1e-14,     dtmax=1e-9,     error_order=2, )  t0_sim = time.time() sol = transient_sim(     t0=0.0,     t1=T_MAX,     dt0=1e-11,     y0=y0,     stepsize_controller=step_controller,     max_steps=1000000,     saveat=diffrax.SaveAt(ts=jnp.linspace(0, T_MAX, 200)),     progress_meter=diffrax.TqdmProgressMeter(refresh_steps=100), )  if sol.result == diffrax.RESULTS.successful:     print(\"   \u2705 Simulation Successful\")      t_end_sim = time.time()     print(f\"Simulation completed in {t_end_sim - t0_sim:.4f}s\")     print(f\"Total Steps: {sol.stats['num_steps']}\")      node_out_idx = port_map[\"Rl,p1\"]     node_in_idx = port_map[\"Rs,p2\"]      ts = sol.ts * 1e9     v_in = sol.ys[:, node_in_idx]     v_out = sol.ys[:, node_out_idx]      plt.figure(figsize=(10, 6))     plt.plot(ts, v_in, \"r--\", alpha=0.6, label=\"Line Input (Rs,p2)\")     plt.plot(ts, v_out, \"b-\", linewidth=1.5, label=f\"Output (Stage {N_SECTIONS})\")      plt.title(f\"LC Ladder Propagation Delay ({N_SECTIONS} Sections)\")     plt.xlabel(\"Time (ns)\")     plt.ylabel(\"Voltage (V)\")     plt.legend(loc=\"upper left\")     plt.grid(True)      theory_delay = N_SECTIONS * jnp.sqrt(10e-9 * 4e-12) * 1e9     plt.axvline(         theory_delay + 1.0, color=\"green\", linestyle=\":\", label=\"Theoretical Arrival\"     )     plt.legend()      plt.show() else:     print(\"   \u274c Simulation Failed\")     print(f\"   Result Code: {sol.result}\") <pre>Generating 1000-stage LC Ladder...\n</pre> <pre>Compilation finished in 0.6932s\nSystem Matrix Size: 2004x2004 (4016016 elements)\nSolving DC Operating Point...\n</pre> <pre>Running Transient Simulation...\n</pre> <pre>\r0.00%|          | [00:00&lt;?, ?%/s]</pre> <pre>\r0.00%|          | [00:00&lt;?, ?%/s]</pre> <pre>\r0.13%|          | [00:00&lt;01:20,  1.25%/s]</pre> <pre>\r0.13%|          | [00:00&lt;01:20,  1.25%/s]</pre> <pre>\r0.43%|          | [00:00&lt;00:45,  2.17%/s]</pre> <pre>\r0.43%|          | [00:00&lt;00:45,  2.17%/s]</pre> <pre>\r1.02%|          | [00:00&lt;00:26,  3.71%/s]</pre> <pre>\r1.02%|          | [00:00&lt;00:26,  3.71%/s]</pre> <pre>\r1.94%|\u258f         | [00:00&lt;00:17,  5.72%/s]</pre> <pre>\r1.94%|\u258f         | [00:00&lt;00:17,  5.72%/s]</pre> <pre>\r3.24%|\u258e         | [00:00&lt;00:11,  8.17%/s]</pre> <pre>\r3.24%|\u258e         | [00:00&lt;00:11,  8.17%/s]</pre> <pre>\r4.96%|\u258d         | [00:00&lt;00:08, 10.92%/s]</pre> <pre>\r4.96%|\u258d         | [00:00&lt;00:08, 10.92%/s]</pre> <pre>\r7.14%|\u258b         | [00:00&lt;00:06, 14.20%/s]</pre> <pre>\r7.14%|\u258b         | [00:00&lt;00:06, 14.20%/s]</pre> <pre>\r10.80%|\u2588         | [00:00&lt;00:06, 14.20%/s]</pre> <pre>\r14.80%|\u2588\u258d        | [00:00&lt;00:02, 29.21%/s]</pre> <pre>\r14.80%|\u2588\u258d        | [00:00&lt;00:02, 29.21%/s]</pre> <pre>\r18.80%|\u2588\u2589        | [00:00&lt;00:02, 29.21%/s]</pre> <pre>\r22.80%|\u2588\u2588\u258e       | [00:00&lt;00:01, 41.88%/s]</pre> <pre>\r22.80%|\u2588\u2588\u258e       | [00:00&lt;00:01, 41.88%/s]</pre> <pre>\r26.80%|\u2588\u2588\u258b       | [00:01&lt;00:01, 41.88%/s]</pre> <pre>\r30.80%|\u2588\u2588\u2588       | [00:01&lt;00:01, 50.65%/s]</pre> <pre>\r30.80%|\u2588\u2588\u2588       | [00:01&lt;00:01, 50.65%/s]</pre> <pre>\r34.80%|\u2588\u2588\u2588\u258d      | [00:01&lt;00:01, 50.65%/s]</pre> <pre>\r38.80%|\u2588\u2588\u2588\u2589      | [00:01&lt;00:01, 56.13%/s]</pre> <pre>\r38.80%|\u2588\u2588\u2588\u2589      | [00:01&lt;00:01, 56.13%/s]</pre> <pre>\r42.80%|\u2588\u2588\u2588\u2588\u258e     | [00:01&lt;00:01, 56.13%/s]</pre> <pre>\r46.80%|\u2588\u2588\u2588\u2588\u258b     | [00:01&lt;00:00, 60.82%/s]</pre> <pre>\r46.80%|\u2588\u2588\u2588\u2588\u258b     | [00:01&lt;00:00, 60.82%/s]</pre> <pre>\r50.80%|\u2588\u2588\u2588\u2588\u2588     | [00:01&lt;00:00, 60.82%/s]</pre> <pre>\r54.80%|\u2588\u2588\u2588\u2588\u2588\u258d    | [00:01&lt;00:00, 64.31%/s]</pre> <pre>\r54.80%|\u2588\u2588\u2588\u2588\u2588\u258d    | [00:01&lt;00:00, 64.31%/s]</pre> <pre>\r58.80%|\u2588\u2588\u2588\u2588\u2588\u2589    | [00:01&lt;00:00, 64.31%/s]</pre> <pre>\r62.80%|\u2588\u2588\u2588\u2588\u2588\u2588\u258e   | [00:01&lt;00:00, 64.47%/s]</pre> <pre>\r62.80%|\u2588\u2588\u2588\u2588\u2588\u2588\u258e   | [00:01&lt;00:00, 64.47%/s]</pre> <pre>\r66.80%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | [00:01&lt;00:00, 64.47%/s]</pre> <pre>\r70.80%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | [00:01&lt;00:00, 66.74%/s]</pre> <pre>\r70.80%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | [00:01&lt;00:00, 66.74%/s]</pre> <pre>\r74.80%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d  | [00:01&lt;00:00, 66.74%/s]</pre> <pre>\r78.80%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | [00:01&lt;00:00, 68.02%/s]</pre> <pre>\r78.80%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | [00:01&lt;00:00, 68.02%/s]</pre> <pre>\r82.80%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e | [00:01&lt;00:00, 68.02%/s]</pre> <pre>\r86.80%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | [00:01&lt;00:00, 68.40%/s]</pre> <pre>\r86.80%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | [00:01&lt;00:00, 68.40%/s]</pre> <pre>\r90.80%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | [00:01&lt;00:00, 68.40%/s]</pre> <pre>\r94.80%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| [00:02&lt;00:00, 68.37%/s]</pre> <pre>\r94.80%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| [00:02&lt;00:00, 68.37%/s]</pre> <pre>\r98.80%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| [00:02&lt;00:00, 68.37%/s]</pre> <pre>\r100.00%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| [00:02&lt;00:00, 47.64%/s]</pre> <pre>\n</pre> <pre>   \u2705 Simulation Successful\nSimulation completed in 3.9896s\nTotal Steps: 3031\n</pre>"},{"location":"examples/LC_ladder/#lc-ladder","title":"LC Ladder\u00b6","text":""},{"location":"examples/LC_ladder/#introduction","title":"Introduction\u00b6","text":"<p>To stress-test the solver's performance on large-scale systems, we simulate a Lumped-Element Transmission Line. By cascading $N$ identical L-C sections, we approximate a continuous transmission line using a finite difference method.This simulation serves two critical benchmarking purposes:</p> <p>Sparse Linear Algebra: With $N=1000$ sections, the system generates a Jacobian matrix of size $2000 \\times 2000$. However, the connectivity is strictly local (node $i$ only connects to $i-1$ and $i+1$). This results in a banded sparse matrix, allowing us to verify if the underlying KLU/sparse solver is effectively optimizing for sparsity.</p> <p>Wave Propagation: The circuit models a signal propagating with a delay of $t_d = \\sqrt{LC}$ per stage. We can validate the solver's time-stepping accuracy by measuring the total propagation delay against the theoretical value $T_{total} = N \\times \\sqrt{LC}$.</p>"},{"location":"examples/LC_ladder/#circuit-parameters","title":"Circuit Parameters\u00b6","text":"<p>Inductance ($L$): $10\\text{nH}$</p> <p>Capacitance ($C$): $4\\text{pF}$</p> <p>Characteristic Impedance ($Z_0$): $\\sqrt{L/C} = 50\\Omega$</p> <p>Termination: If $R_{load} = Z_0$, reflections should be minimized. If $R_{load} \\neq Z_0$, we expect distinct reflection patterns.</p>"},{"location":"examples/diode_clipper/","title":"Diode clipper","text":"In\u00a0[1]: Copied! <pre>import time\n\nimport diffrax\nimport jax\nimport jax.numpy as jnp\nimport matplotlib.pyplot as plt\n\nfrom circulax.compiler import compile_netlist\nfrom circulax.components.electronic import Diode, Resistor, VoltageSourceAC\nfrom circulax.solvers import analyze_circuit, setup_transient\n\njax.config.update(\"jax_enable_x64\", True)\n</pre> import time  import diffrax import jax import jax.numpy as jnp import matplotlib.pyplot as plt  from circulax.compiler import compile_netlist from circulax.components.electronic import Diode, Resistor, VoltageSourceAC from circulax.solvers import analyze_circuit, setup_transient  jax.config.update(\"jax_enable_x64\", True) In\u00a0[2]: Copied! <pre>vpp = 2.0\nnet_dict = {\n    \"instances\": {\n        \"GND\": {\"component\": \"ground\"},\n        \"Vin\": {\n            \"component\": \"source_voltage\",\n            \"settings\": {\n                \"V\": vpp,\n                \"freq\": 1e3,\n            },\n        },\n        \"R1\": {\"component\": \"resistor\", \"settings\": {\"R\": 1000.0}},\n        \"D1\": {\n            \"component\": \"diode\",\n            \"settings\": {\n                \"Is\": 1e-14,\n            },\n        },\n        \"D2\": {\n            \"component\": \"diode\",\n            \"settings\": {\n                \"Is\": 1e-14,\n            },\n        },\n    },\n    \"connections\": {\n        \"GND,p1\": (\"Vin,p2\", \"D1,p2\", \"D2,p1\"),\n        \"Vin,p1\": \"R1,p1\",\n        \"R1,p2\": (\"D1,p1\", \"D2,p2\"),\n    },\n}\n</pre> vpp = 2.0 net_dict = {     \"instances\": {         \"GND\": {\"component\": \"ground\"},         \"Vin\": {             \"component\": \"source_voltage\",             \"settings\": {                 \"V\": vpp,                 \"freq\": 1e3,             },         },         \"R1\": {\"component\": \"resistor\", \"settings\": {\"R\": 1000.0}},         \"D1\": {             \"component\": \"diode\",             \"settings\": {                 \"Is\": 1e-14,             },         },         \"D2\": {             \"component\": \"diode\",             \"settings\": {                 \"Is\": 1e-14,             },         },     },     \"connections\": {         \"GND,p1\": (\"Vin,p2\", \"D1,p2\", \"D2,p1\"),         \"Vin,p1\": \"R1,p1\",         \"R1,p2\": (\"D1,p1\", \"D2,p2\"),     }, } In\u00a0[4]: Copied! <pre>models_map = {\n    \"resistor\": Resistor,\n    \"diode\": Diode,\n    \"source_voltage\": VoltageSourceAC,\n    \"ground\": lambda: 0,\n}\n\nprint(\"1. Compiling Circuit...\")\ngroups, num_vars, port_map = compile_netlist(net_dict, models_map)\nprint(f\"   System Size: {num_vars} variables\")\nprint(f\"   Port Map: {port_map}\")\n\n\nprint(\"2. Initializing Solver Strategy...\")\nlinear_strat = analyze_circuit(groups=groups, num_vars=num_vars, backend=\"klu_split\")\n\nprint(\"3. Solving DC Operating Point...\")\ny_guess = jnp.zeros(num_vars)\ny_dc = linear_strat.solve_dc(groups, y_guess)\nprint(f\"   DC Solution (First 5): {y_dc[:5]}\")\n\nprint(\"4. Running Transient Simulation...\")\n\n\ntransient_sim = setup_transient(groups, linear_strategy=linear_strat)\n\nt_max = 2e-3\nsaveat = diffrax.SaveAt(ts=jnp.linspace(0, t_max, 300))\n\nstep_controller = diffrax.PIDController(\n    rtol=1e-3,\n    atol=1e-6,\n    pcoeff=0.2,\n    icoeff=0.5,\n    dcoeff=0.4,\n    force_dtmin=True,\n    dtmin=1e-8,\n    dtmax=1e-5,\n    error_order=2,\n)\n\nstart = time.time()\nsol = transient_sim(\n    t0=0,\n    t1=t_max,\n    dt0=1e-6 * t_max,\n    y0=y_dc,\n    saveat=saveat,\n    stepsize_controller=step_controller,\n)\nstop = time.time()\n\nif sol.result == diffrax.RESULTS.successful:\n    print(\"   \u2705 Simulation Successful\")\n    print(\n        f\"Performed {sol.stats['num_steps']} steps performed in {stop - start:.2f} seconds\"\n    )\n    ts = sol.ts\n    v_in = sol.ys[:, port_map[\"Vin,p1\"]]\n    v_out = sol.ys[:, port_map[\"R1,p2\"]]\n\n    plt.figure(figsize=(8, 4))\n    plt.plot(ts * 1000, v_in, \"k--\", alpha=0.5, label=f\"Input ({vpp} V Sine)\")\n    plt.plot(ts * 1000, v_out, \"r-\", linewidth=2, label=\"Output (Clipped)\")\n    plt.title(\"Diode Limiter: Hard Non-Linearity Test\")\n    plt.xlabel(\"Time (ms)\")\n    plt.ylabel(\"Voltage (V)\")\n    plt.legend()\n    plt.grid(True)\n    plt.show()\nelse:\n    print(\"   \u274c Simulation Failed\")\n    print(f\"   Result Code: {sol.result}\")\n</pre> models_map = {     \"resistor\": Resistor,     \"diode\": Diode,     \"source_voltage\": VoltageSourceAC,     \"ground\": lambda: 0, }  print(\"1. Compiling Circuit...\") groups, num_vars, port_map = compile_netlist(net_dict, models_map) print(f\"   System Size: {num_vars} variables\") print(f\"   Port Map: {port_map}\")   print(\"2. Initializing Solver Strategy...\") linear_strat = analyze_circuit(groups=groups, num_vars=num_vars, backend=\"klu_split\")  print(\"3. Solving DC Operating Point...\") y_guess = jnp.zeros(num_vars) y_dc = linear_strat.solve_dc(groups, y_guess) print(f\"   DC Solution (First 5): {y_dc[:5]}\")  print(\"4. Running Transient Simulation...\")   transient_sim = setup_transient(groups, linear_strategy=linear_strat)  t_max = 2e-3 saveat = diffrax.SaveAt(ts=jnp.linspace(0, t_max, 300))  step_controller = diffrax.PIDController(     rtol=1e-3,     atol=1e-6,     pcoeff=0.2,     icoeff=0.5,     dcoeff=0.4,     force_dtmin=True,     dtmin=1e-8,     dtmax=1e-5,     error_order=2, )  start = time.time() sol = transient_sim(     t0=0,     t1=t_max,     dt0=1e-6 * t_max,     y0=y_dc,     saveat=saveat,     stepsize_controller=step_controller, ) stop = time.time()  if sol.result == diffrax.RESULTS.successful:     print(\"   \u2705 Simulation Successful\")     print(         f\"Performed {sol.stats['num_steps']} steps performed in {stop - start:.2f} seconds\"     )     ts = sol.ts     v_in = sol.ys[:, port_map[\"Vin,p1\"]]     v_out = sol.ys[:, port_map[\"R1,p2\"]]      plt.figure(figsize=(8, 4))     plt.plot(ts * 1000, v_in, \"k--\", alpha=0.5, label=f\"Input ({vpp} V Sine)\")     plt.plot(ts * 1000, v_out, \"r-\", linewidth=2, label=\"Output (Clipped)\")     plt.title(\"Diode Limiter: Hard Non-Linearity Test\")     plt.xlabel(\"Time (ms)\")     plt.ylabel(\"Voltage (V)\")     plt.legend()     plt.grid(True)     plt.show() else:     print(\"   \u274c Simulation Failed\")     print(f\"   Result Code: {sol.result}\") <pre>1. Compiling Circuit...\n</pre> <pre>   System Size: 4 variables\n   Port Map: {'D1,p1': 1, 'D2,p2': 1, 'R1,p2': 1, 'GND,p1': 0, 'Vin,p2': 0, 'D1,p2': 0, 'D2,p1': 0, 'R1,p1': 2, 'Vin,p1': 2}\n2. Initializing Solver Strategy...\n3. Solving DC Operating Point...\n</pre> <pre>   DC Solution (First 5): [0. 0. 0. 0.]\n4. Running Transient Simulation...\n</pre> <pre>   \u2705 Simulation Successful\nPerformed 591 steps performed in 1.59 seconds\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/diode_clipper/#diode-clipper","title":"Diode Clipper\u00b6","text":""},{"location":"examples/diode_clipper/#introduction","title":"Introduction\u00b6","text":"<p>In this example, we will simulate a classic Diode Clipper (Limiter) circuit. This circuit is a fundamental building block in analog signal processing, used to protect sensitive components from voltage spikes or to shape waveforms by \"clipping\" signal peaks.</p> <p>From a simulation perspective, the Diode Clipper serves as a critical benchmark for testing non-linear solvers. As the input voltage crosses the diode's forward-bias threshold, the component's impedance changes rapidly\u2014spanning orders of magnitude from \"off\" to \"on.\" This behavior creates a stiff system of differential equations, requiring a robust, adaptive step-size controller to maintain numerical stability.</p>"},{"location":"examples/diode_clipper/#defining-the-netlist","title":"Defining the Netlist\u00b6","text":""},{"location":"examples/mos_diff_pair/","title":"Mos diff pair","text":"In\u00a0[1]: Copied! <pre>import time\n\nimport equinox as eqx\nimport jax\nimport jax.numpy as jnp\nimport matplotlib.pyplot as plt\n\nfrom circulax.compiler import compile_netlist\nfrom circulax.components.electronic import NMOS, CurrentSource, Resistor, VoltageSource\nfrom circulax.solvers import analyze_circuit\n</pre> import time  import equinox as eqx import jax import jax.numpy as jnp import matplotlib.pyplot as plt  from circulax.compiler import compile_netlist from circulax.components.electronic import NMOS, CurrentSource, Resistor, VoltageSource from circulax.solvers import analyze_circuit In\u00a0[2]: Copied! <pre>net_dict = {\n    \"instances\": {\n        \"GND\": {\"component\": \"ground\"},\n        \"VDD\": {\"component\": \"source_dc\", \"settings\": {\"V\": 5.0}},\n        \"Iss\": {\"component\": \"current_src\", \"settings\": {\"I\": 1e-3}},\n        \"RD1\": {\"component\": \"resistor\", \"settings\": {\"R\": 2000}},\n        \"RD2\": {\"component\": \"resistor\", \"settings\": {\"R\": 2000}},\n        \"M1\": {\"component\": \"nmos\", \"settings\": {\"W\": 50e-6, \"L\": 1e-6}},\n        \"M2\": {\"component\": \"nmos\", \"settings\": {\"W\": 50e-6, \"L\": 1e-6}},\n        \"Vin1\": {\"component\": \"source_dc\", \"settings\": {\"V\": 1.5}},\n        \"Vin2\": {\"component\": \"source_dc\", \"settings\": {\"V\": 2.5}},\n    },\n    \"connections\": {\n        \"GND,p1\": (\"VDD,p2\", \"Vin1,p2\", \"Vin2,p2\", \"Iss,p2\"),\n        \"Iss,p1\": (\"M1,s\", \"M2,s\"),\n        \"M1,d\": \"RD1,p2\",\n        \"M2,d\": \"RD2,p2\",\n        \"RD1,p1\": \"VDD,p1\",\n        \"RD2,p1\": \"VDD,p1\",\n        \"Vin1,p1\": \"M1,g\",\n        \"Vin2,p1\": \"M2,g\",\n    },\n}\n</pre> net_dict = {     \"instances\": {         \"GND\": {\"component\": \"ground\"},         \"VDD\": {\"component\": \"source_dc\", \"settings\": {\"V\": 5.0}},         \"Iss\": {\"component\": \"current_src\", \"settings\": {\"I\": 1e-3}},         \"RD1\": {\"component\": \"resistor\", \"settings\": {\"R\": 2000}},         \"RD2\": {\"component\": \"resistor\", \"settings\": {\"R\": 2000}},         \"M1\": {\"component\": \"nmos\", \"settings\": {\"W\": 50e-6, \"L\": 1e-6}},         \"M2\": {\"component\": \"nmos\", \"settings\": {\"W\": 50e-6, \"L\": 1e-6}},         \"Vin1\": {\"component\": \"source_dc\", \"settings\": {\"V\": 1.5}},         \"Vin2\": {\"component\": \"source_dc\", \"settings\": {\"V\": 2.5}},     },     \"connections\": {         \"GND,p1\": (\"VDD,p2\", \"Vin1,p2\", \"Vin2,p2\", \"Iss,p2\"),         \"Iss,p1\": (\"M1,s\", \"M2,s\"),         \"M1,d\": \"RD1,p2\",         \"M2,d\": \"RD2,p2\",         \"RD1,p1\": \"VDD,p1\",         \"RD2,p1\": \"VDD,p1\",         \"Vin1,p1\": \"M1,g\",         \"Vin2,p1\": \"M2,g\",     }, } In\u00a0[4]: Copied! <pre>def update_param_value(groups, group_name, instance_name, param_key, new_value):\n    g = groups[group_name]\n\n    instance_idx = g.index_map[instance_name]\n\n    batched_comp = g.params\n    current_vals = getattr(batched_comp, param_key)\n\n    new_vals = current_vals.at[instance_idx].set(new_value)\n\n    new_batched_comp = eqx.tree_at(\n        lambda c: getattr(c, param_key), batched_comp, new_vals\n    )\n    new_g = eqx.tree_at(lambda g: g.params, g, new_batched_comp)\n\n    new_groups = groups.copy()\n    new_groups[group_name] = new_g\n    return new_groups\n\n\njax.config.update(\"jax_enable_x64\", True)\n\nmodels_map = {\n    \"nmos\": NMOS,\n    \"resistor\": Resistor,\n    \"source_dc\": VoltageSource,\n    \"current_src\": CurrentSource,\n    \"ground\": lambda: 0,\n}\n\nprint(\"1. Compiling...\")\ngroups, sys_size, port_map = compile_netlist(net_dict, models_map)\n\nlinear_strat = analyze_circuit(groups, sys_size, is_complex=False)\n\n\n@jax.jit\ndef scan_step(y_prev, v_in_val):\n    new_groups = update_param_value(groups, \"source_dc\", \"Vin1\", \"V\", v_in_val)\n    y_sol = linear_strat.solve_dc(new_groups, y_guess=y_prev)\n    return y_sol, y_sol\n\n\nsweep_voltages = jnp.linspace(1.5, 3.5, 1000)\n\nprint(f\"2. Running Sweep ({len(sweep_voltages)} points)...\")\nprint(\"Sweeping DC Operating Point (with Continuation)...\")\nstart_time = time.time()\n\ny_current = jnp.zeros(sys_size)\n# Using JAX scan, the previous solution is used as a guess for the sequential root solve\nfinal_y, solutions = jax.lax.scan(scan_step, y_current, sweep_voltages)\n\ntotal = time.time() - start_time\nprint(f\"Simulation Time: {total:.3f}s\")\n\nidx_out1 = port_map[\"RD1,p2\"]\nidx_out2 = port_map[\"RD2,p2\"]\n\nv_out1 = solutions[:, idx_out1]\nv_out2 = solutions[:, idx_out2]\n\nplt.figure(figsize=(10, 6))\nplt.plot(sweep_voltages, v_out1, \"r-\", linewidth=2, label=\"V_out1 (Inv)\")\nplt.plot(sweep_voltages, v_out2, \"b-\", linewidth=2, label=\"V_out2 (Non-Inv)\")\n\nplt.axvline(2.5, color=\"k\", linestyle=\":\", label=\"V_ref (2.5V)\")\nplt.axhline(5.0, color=\"gray\", linestyle=\"--\", alpha=0.5, label=\"VDD\")\nplt.axhline(\n    5.0 - (1e-3 * 2000), color=\"gray\", linestyle=\"--\", alpha=0.5, label=\"Min Swing\"\n)\n\nplt.title(\"Diff Pair DC Transfer (Sequential Loop)\")\nplt.xlabel(\"Input Voltage Vin1 (V)\")\nplt.ylabel(\"Output Voltage (V)\")\nplt.legend()\nplt.grid(True)\nplt.show()\n</pre> def update_param_value(groups, group_name, instance_name, param_key, new_value):     g = groups[group_name]      instance_idx = g.index_map[instance_name]      batched_comp = g.params     current_vals = getattr(batched_comp, param_key)      new_vals = current_vals.at[instance_idx].set(new_value)      new_batched_comp = eqx.tree_at(         lambda c: getattr(c, param_key), batched_comp, new_vals     )     new_g = eqx.tree_at(lambda g: g.params, g, new_batched_comp)      new_groups = groups.copy()     new_groups[group_name] = new_g     return new_groups   jax.config.update(\"jax_enable_x64\", True)  models_map = {     \"nmos\": NMOS,     \"resistor\": Resistor,     \"source_dc\": VoltageSource,     \"current_src\": CurrentSource,     \"ground\": lambda: 0, }  print(\"1. Compiling...\") groups, sys_size, port_map = compile_netlist(net_dict, models_map)  linear_strat = analyze_circuit(groups, sys_size, is_complex=False)   @jax.jit def scan_step(y_prev, v_in_val):     new_groups = update_param_value(groups, \"source_dc\", \"Vin1\", \"V\", v_in_val)     y_sol = linear_strat.solve_dc(new_groups, y_guess=y_prev)     return y_sol, y_sol   sweep_voltages = jnp.linspace(1.5, 3.5, 1000)  print(f\"2. Running Sweep ({len(sweep_voltages)} points)...\") print(\"Sweeping DC Operating Point (with Continuation)...\") start_time = time.time()  y_current = jnp.zeros(sys_size) # Using JAX scan, the previous solution is used as a guess for the sequential root solve final_y, solutions = jax.lax.scan(scan_step, y_current, sweep_voltages)  total = time.time() - start_time print(f\"Simulation Time: {total:.3f}s\")  idx_out1 = port_map[\"RD1,p2\"] idx_out2 = port_map[\"RD2,p2\"]  v_out1 = solutions[:, idx_out1] v_out2 = solutions[:, idx_out2]  plt.figure(figsize=(10, 6)) plt.plot(sweep_voltages, v_out1, \"r-\", linewidth=2, label=\"V_out1 (Inv)\") plt.plot(sweep_voltages, v_out2, \"b-\", linewidth=2, label=\"V_out2 (Non-Inv)\")  plt.axvline(2.5, color=\"k\", linestyle=\":\", label=\"V_ref (2.5V)\") plt.axhline(5.0, color=\"gray\", linestyle=\"--\", alpha=0.5, label=\"VDD\") plt.axhline(     5.0 - (1e-3 * 2000), color=\"gray\", linestyle=\"--\", alpha=0.5, label=\"Min Swing\" )  plt.title(\"Diff Pair DC Transfer (Sequential Loop)\") plt.xlabel(\"Input Voltage Vin1 (V)\") plt.ylabel(\"Output Voltage (V)\") plt.legend() plt.grid(True) plt.show() <pre>1. Compiling...\n</pre> <pre>2. Running Sweep (1000 points)...\nSweeping DC Operating Point (with Continuation)...\n</pre> <pre>Simulation Time: 0.504s\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/mos_diff_pair/#mos-differential-pair","title":"MOS Differential Pair\u00b6","text":""},{"location":"examples/mos_diff_pair/#introduction","title":"Introduction\u00b6","text":"<p>In this section, we analyze the MOS Differential Pair, the fundamental input stage of operational amplifiers and logic gates. The circuit consists of two matched NMOS transistors ($M_1, M_2$) sharing a common \"tail\" current source ($I_{SS}$).We will perform a DC Transfer Analysis, sweeping the input voltage $V_{in1}$ from $1.5V$ to $3.5V$ while holding $V_{in2}$ constant at $2.5V$. This simulation reveals how the tail current steers between the two branches, creating the characteristic sigmoidal differential output.</p> <p>Simulating a sweep in JAX requires a different mindset than standard Python loops:</p> <ul> <li><p>Immutability: JAX arrays and circuit objects are immutable. We cannot simply do circuit.R1.value = 10. Instead, we define a functional update_param_value helper that returns a new circuit definition with the modified parameter.</p> </li> <li><p>Sequential Continuation (jax.lax.scan): Unlike a Monte Carlo simulation where every run is independent (perfect for vmap), a DC sweep works best when sequential. By using <code>jax.lax.scan</code>, we feed the solution of the previous voltage step (y_prev) as the initial guess for the current step. This \"homotopy\" or continuation method drastically improves convergence stability for non-linear components like MOSFETs.</p> </li> <li><p>Compilation: The entire sweep loop is compiled into a single XLA kernel, executing thousands of voltage steps in milliseconds.</p> </li> </ul>"},{"location":"examples/mzm/","title":"Mzm","text":"In\u00a0[1]: Copied! <pre>import time\n\nimport jax\nimport jax.numpy as jnp\nimport matplotlib.pyplot as plt\n\nfrom circulax.compiler import compile_netlist\nfrom circulax.solvers import analyze_circuit\nfrom circulax.utils import update_group_params\n</pre> import time  import jax import jax.numpy as jnp import matplotlib.pyplot as plt  from circulax.compiler import compile_netlist from circulax.solvers import analyze_circuit from circulax.utils import update_group_params  In\u00a0[2]: Copied! <pre>net_dict = {\n    \"instances\": {\n        \"GND\": {\"component\": \"ground\"},\n        \"Laser\": {\"component\": \"source\", \"settings\": {\"power\": 1.0, \"phase\": 0.0}},\n        # Input Coupling\n        \"GC_In\": {\n            \"component\": \"grating\",\n            \"settings\": {\"peak_loss_dB\": 1.0, \"bandwidth_1dB\": 40.0},\n        },\n        \"WG_In\": {\"component\": \"waveguide\", \"settings\": {\"length_um\": 50.0}},\n        # The Interferometer\n        \"Splitter\": {\"component\": \"splitter\", \"settings\": {\"split_ratio\": 0.5}},\n        \"WG_Long\": {\n            \"component\": \"waveguide\",\n            \"settings\": {\"length_um\": 150.0},\n        },  # Delta L = 100um\n        \"WG_Short\": {\"component\": \"waveguide\", \"settings\": {\"length_um\": 100.0}},\n        \"Combiner\": {\n            \"component\": \"splitter\",\n            \"settings\": {\"split_ratio\": 0.5},\n        },  # Reciprocal Splitter\n        # Output Coupling\n        \"WG_Out\": {\"component\": \"waveguide\", \"settings\": {\"length_um\": 50.0}},\n        \"GC_Out\": {\n            \"component\": \"grating\",\n            \"settings\": {\"peak_loss_dB\": 1.0, \"bandwidth_1dB\": 40.0},\n        },\n        \"Detector\": {\"component\": \"resistor\", \"settings\": {\"R\": 1.0}},\n    },\n    \"connections\": {\n        \"GND,p1\": (\"Laser,p2\", \"Detector,p2\"),\n        # Input: Laser -&gt; GC -&gt; WG -&gt; Splitter\n        \"Laser,p1\": \"GC_In,grating\",\n        \"GC_In,waveguide\": \"WG_In,p1\",\n        \"WG_In,p2\": \"Splitter,p1\",\n        # Arms\n        \"Splitter,p2\": \"WG_Long,p1\",\n        \"Splitter,p3\": \"WG_Short,p1\",\n        \"WG_Long,p2\": \"Combiner,p2\",\n        \"WG_Short,p2\": \"Combiner,p3\",\n        # Output: Combiner -&gt; WG -&gt; GC -&gt; Detector\n        \"Combiner,p1\": \"WG_Out,p1\",\n        \"WG_Out,p2\": \"GC_Out,waveguide\",\n        \"GC_Out,grating\": \"Detector,p1\",\n    },\n}\n</pre> net_dict = {     \"instances\": {         \"GND\": {\"component\": \"ground\"},         \"Laser\": {\"component\": \"source\", \"settings\": {\"power\": 1.0, \"phase\": 0.0}},         # Input Coupling         \"GC_In\": {             \"component\": \"grating\",             \"settings\": {\"peak_loss_dB\": 1.0, \"bandwidth_1dB\": 40.0},         },         \"WG_In\": {\"component\": \"waveguide\", \"settings\": {\"length_um\": 50.0}},         # The Interferometer         \"Splitter\": {\"component\": \"splitter\", \"settings\": {\"split_ratio\": 0.5}},         \"WG_Long\": {             \"component\": \"waveguide\",             \"settings\": {\"length_um\": 150.0},         },  # Delta L = 100um         \"WG_Short\": {\"component\": \"waveguide\", \"settings\": {\"length_um\": 100.0}},         \"Combiner\": {             \"component\": \"splitter\",             \"settings\": {\"split_ratio\": 0.5},         },  # Reciprocal Splitter         # Output Coupling         \"WG_Out\": {\"component\": \"waveguide\", \"settings\": {\"length_um\": 50.0}},         \"GC_Out\": {             \"component\": \"grating\",             \"settings\": {\"peak_loss_dB\": 1.0, \"bandwidth_1dB\": 40.0},         },         \"Detector\": {\"component\": \"resistor\", \"settings\": {\"R\": 1.0}},     },     \"connections\": {         \"GND,p1\": (\"Laser,p2\", \"Detector,p2\"),         # Input: Laser -&gt; GC -&gt; WG -&gt; Splitter         \"Laser,p1\": \"GC_In,grating\",         \"GC_In,waveguide\": \"WG_In,p1\",         \"WG_In,p2\": \"Splitter,p1\",         # Arms         \"Splitter,p2\": \"WG_Long,p1\",         \"Splitter,p3\": \"WG_Short,p1\",         \"WG_Long,p2\": \"Combiner,p2\",         \"WG_Short,p2\": \"Combiner,p3\",         # Output: Combiner -&gt; WG -&gt; GC -&gt; Detector         \"Combiner,p1\": \"WG_Out,p1\",         \"WG_Out,p2\": \"GC_Out,waveguide\",         \"GC_Out,grating\": \"Detector,p1\",     }, } In\u00a0[4]: Copied! <pre>from circulax.components.electronic import Resistor\nfrom circulax.components.photonic import (\n    Grating,\n    OpticalSource,\n    OpticalWaveguide,\n    Splitter,\n)\n\nprint(\"--- DEMO: Photonic Splitter &amp; Grating Link (Wavelength Sweep) ---\")\n\nmodels_map = {\n    \"grating\": Grating,\n    \"waveguide\": OpticalWaveguide,\n    \"splitter\": Splitter,\n    \"source\": OpticalSource,\n    \"resistor\": Resistor,\n    \"ground\": lambda: 0,\n}\n\n\ngroups, sys_size, port_map = compile_netlist(net_dict, models_map)\n\nwavelengths = jnp.linspace(1260, 1360, 2000)\n\nsolver_strat = analyze_circuit(groups, sys_size, is_complex=True)\n\nprint(\"Sweeping Wavelength...\")\n\n\n@jax.jit\ndef solve_for_loss(val):\n    g = update_group_params(groups, \"grating\", \"wavelength_nm\", val)\n    g = update_group_params(g, \"waveguide\", \"wavelength_nm\", val)\n    y_flat = solver_strat.solve_dc(g, y_guess=jnp.ones(sys_size * 2))\n    return y_flat\n\n\nstart = time.time()\nprint(\"Solving for single wavelength (and jit compiling)\")\nsolve_for_loss(1310)\ntotal = time.time() - start\nprint(f\"Compilation and single point simulation Time: {total:.3f}s\")\n\nprint(\"Sweeping DC Operating Point...\")\nstart = time.time()\nsolutions = jax.vmap(solve_for_loss)(wavelengths)\ntotal = time.time() - start\nprint(f\"Vmap simulation Time: {total:.3f}s\")\n\nv_out1 = (\n    solutions[:, port_map[\"Detector,p1\"]]\n    + 1j * solutions[:, port_map[\"Detector,p1\"] + sys_size]\n)\n# v_out2 = solutions[:, port_map[\"Load2,p1\" ]] + 1j * solutions[:, port_map[\"Load2,p1\"]+sys_size]\n\np_out1_db = 10.0 * jnp.log10(jnp.abs(v_out1) ** 2 + 1e-12)\n# p_out2_db = 10.0 * jnp.log10(jnp.abs(v_out2)**2 + 1e-12)\n\nplt.figure(figsize=(8, 4))\nplt.plot(wavelengths, p_out1_db, \"b-\", label=\"Port 1 (Split)\")\n# plt.plot(wavelengths, p_out2_db, 'r--', label='Port 2 (Split)')\n\nplt.title(\"Grating and MZM Response\")\nplt.xlabel(\"Wavelength (nm)\")\nplt.ylabel(\"Received Power (dB)\")\nplt.legend()\nplt.grid(True)\nplt.show()\n</pre> from circulax.components.electronic import Resistor from circulax.components.photonic import (     Grating,     OpticalSource,     OpticalWaveguide,     Splitter, )  print(\"--- DEMO: Photonic Splitter &amp; Grating Link (Wavelength Sweep) ---\")  models_map = {     \"grating\": Grating,     \"waveguide\": OpticalWaveguide,     \"splitter\": Splitter,     \"source\": OpticalSource,     \"resistor\": Resistor,     \"ground\": lambda: 0, }   groups, sys_size, port_map = compile_netlist(net_dict, models_map)  wavelengths = jnp.linspace(1260, 1360, 2000)  solver_strat = analyze_circuit(groups, sys_size, is_complex=True)  print(\"Sweeping Wavelength...\")   @jax.jit def solve_for_loss(val):     g = update_group_params(groups, \"grating\", \"wavelength_nm\", val)     g = update_group_params(g, \"waveguide\", \"wavelength_nm\", val)     y_flat = solver_strat.solve_dc(g, y_guess=jnp.ones(sys_size * 2))     return y_flat   start = time.time() print(\"Solving for single wavelength (and jit compiling)\") solve_for_loss(1310) total = time.time() - start print(f\"Compilation and single point simulation Time: {total:.3f}s\")  print(\"Sweeping DC Operating Point...\") start = time.time() solutions = jax.vmap(solve_for_loss)(wavelengths) total = time.time() - start print(f\"Vmap simulation Time: {total:.3f}s\")  v_out1 = (     solutions[:, port_map[\"Detector,p1\"]]     + 1j * solutions[:, port_map[\"Detector,p1\"] + sys_size] ) # v_out2 = solutions[:, port_map[\"Load2,p1\" ]] + 1j * solutions[:, port_map[\"Load2,p1\"]+sys_size]  p_out1_db = 10.0 * jnp.log10(jnp.abs(v_out1) ** 2 + 1e-12) # p_out2_db = 10.0 * jnp.log10(jnp.abs(v_out2)**2 + 1e-12)  plt.figure(figsize=(8, 4)) plt.plot(wavelengths, p_out1_db, \"b-\", label=\"Port 1 (Split)\") # plt.plot(wavelengths, p_out2_db, 'r--', label='Port 2 (Split)')  plt.title(\"Grating and MZM Response\") plt.xlabel(\"Wavelength (nm)\") plt.ylabel(\"Received Power (dB)\") plt.legend() plt.grid(True) plt.show() <pre>--- DEMO: Photonic Splitter &amp; Grating Link (Wavelength Sweep) ---\n</pre> <pre>Sweeping Wavelength...\nSolving for single wavelength (and jit compiling)\n</pre> <pre>Compilation and single point simulation Time: 1.473s\nSweeping DC Operating Point...\n</pre> <pre>Vmap simulation Time: 2.175s\n</pre>"},{"location":"examples/mzm/#mach-zehnder-inteferometer","title":"Mach-Zehnder Inteferometer\u00b6","text":""},{"location":"examples/mzm/#introduciton","title":"Introduciton\u00b6","text":"<p>In this example, the vmap capabilities of the solver will be demonstrated to perform a wavelength sweep in the optical domain of an asummetric MZM coupled by two grating couplers. This is a very common structure in photonics.</p>"},{"location":"examples/mzm/#key-modeling-concepts","title":"Key Modeling Concepts\u00b6","text":"<ul> <li><p>Waveguides as Transmission Lines: Unlike ideal electrical wires, optical waveguides have significant phase delay and propagation loss proportional to their length. Our Waveguide model captures this phase accumulation $\\phi = \\beta L$.</p> </li> <li><p>S-Parameters: The \"Splitter\" is modeled as a 3-port device (1 Input, 2 Outputs) with a specific power splitting ratio (here 50:50).</p> </li> <li><p>Grating Couplers: These components couple light from the chip surface to an optical fiber. They are highly frequency-dependent (bandpass filters).</p> </li> </ul> <p>In this netlist, they are terminated by \"Loads\" (Resistors), representing the matched impedance of a photodetector or optical power meter.</p>"},{"location":"examples/photonics_transient/","title":"Photonics transient","text":"<p>In this advanced demonstration, we simulate the non-linear transient response of a photonic circuit. We revisit the standard waveguide model but introduce Two-Photon Absorption (TPA).</p> <p>In linear optics, loss is constant ($\\alpha$). In the non-linear regime, loss becomes intensity-dependent ($\\alpha + \\beta I$). This creates an Optical Limiting effect: as the optical power increases, the material absorbs more efficiently, effectively \"clamping\" the output power. This example demonstrates two critical capabilities of the solver:</p> <p>Dynamic S-Matrices: Unlike the previous linear examples where the system matrix was constant, here the scattering parameters $S(t)$ are a function of the instantaneous state $|E(t)|^2$. The solver re-evaluates the component physics at every femtosecond time-step.</p> <p>Complex Envelopes: Optical signals oscillate at hundreds of terahertz ($193\\text{THz}$). To make simulation feasible, we simulate the complex slowly-varying envelope $A(t)$ rather than the raw field, using a Real-Imaginary Flattening strategy to map the complex state to the solver's real-valued requirements.</p> <p>What to Expect: A high-power Gaussian pulse will be launched into the waveguide. In the linear regeime, the output is just a scaled, delayed version of the input, however with tpa_coeff &gt; 0, pulse reshaping is observed. The peak of the Gaussian (high intensity) will be flattened or \"squashed\" due to the non-linear loss, while the tails (low intensity) pass through with standard linear attenuation.</p> In\u00a0[1]: Copied! <pre>import diffrax\nimport jax\nimport jax.numpy as jnp\nimport matplotlib.pyplot as plt\n\nfrom circulax.compiler import compile_netlist\nfrom circulax.components.base_component import PhysicsReturn, Signals, States, component\nfrom circulax.components.electronic import Resistor\nfrom circulax.components.photonic import OpticalSourcePulse\nfrom circulax.solvers import analyze_circuit, setup_transient\n</pre> import diffrax import jax import jax.numpy as jnp import matplotlib.pyplot as plt  from circulax.compiler import compile_netlist from circulax.components.base_component import PhysicsReturn, Signals, States, component from circulax.components.electronic import Resistor from circulax.components.photonic import OpticalSourcePulse from circulax.solvers import analyze_circuit, setup_transient  In\u00a0[3]: Copied! <pre>print(\"--- DEMO: Photonic Transient (Flat Vector Fix) ---\")\n\njax.config.update(\"jax_enable_x64\", True)\n\nmodels_map = {\n    \"waveguide\": OpticalWaveguide,\n    \"source\": OpticalSourcePulse,\n    \"resistor\": Resistor,\n    \"ground\": lambda: 0,\n}\n\nnet_dict = {\n    \"instances\": {\n        \"GND\": {\"component\": \"ground\"},\n        \"I1\": {\"component\": \"source\", \"settings\": {\"power\": 100.0, \"delay\": 0.1e-9}},\n        \"WG1\": {\n            \"component\": \"waveguide\",\n            \"settings\": {\"length_um\": 1000.0, \"loss_dB_cm\": 20.0, \"tpa_coeff\": 5e-1},\n        },\n        \"R1\": {\"component\": \"resistor\", \"settings\": {\"R\": 1.0}},\n    },\n    \"connections\": {\"GND,p1\": (\"I1,p2\", \"R1,p2\"), \"I1,p1\": \"WG1,p1\", \"WG1,p2\": \"R1,p1\"},\n}\n\nprint(\"1. Compiling...\")\ngroups, sys_size, port_map = compile_netlist(net_dict, models_map)\n\nlinear_strat = analyze_circuit(groups, sys_size, is_complex=True)\n\nprint(\"2. Solving DC Operating Point...\")\n\ny_guess_flat = jnp.zeros(sys_size * 2, dtype=jnp.float64)\ny_op_flat = linear_strat.solve_dc(groups, y_guess_flat)\n\nprint(f\"   DC Converged. Norm: {jnp.linalg.norm(y_op_flat):.2e}\")\n\ntransient_sim = setup_transient(groups=groups, linear_strategy=linear_strat)\n\nt_max = 1.0e-9\nsaveat = diffrax.SaveAt(ts=jnp.linspace(0, t_max, 500))\n\nprint(\"3. Running Transient Simulation...\")\nsol = transient_sim(\n    t0=0.0,\n    t1=t_max,\n    dt0=1e-13,\n    y0=y_op_flat,\n    args=(groups, sys_size),\n    saveat=saveat,\n    max_steps=100000,\n    throw=False,\n    stepsize_controller=diffrax.PIDController(rtol=1e-4, atol=1e-6),\n)\n\nif sol.result == diffrax.RESULTS.successful:\n    print(\"   \u2705 Simulation Successful\")\n\n    ts = sol.ts * 1e9\n\n    ys_flat = sol.ys\n    ys_complex = ys_flat[:, :sys_size] + 1j * ys_flat[:, sys_size:]\n\n    node_in_idx = port_map[\"I1,p1\"]\n    node_out_idx = port_map[\"R1,p1\"]\n\n    v_in = ys_complex[:, node_in_idx]\n    v_out = ys_complex[:, node_out_idx]\n\n    fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(10, 6))\n    axes = axes.ravel()\n\n    axes[0].plot(ts, 20 * jnp.log10(jnp.abs(v_in)), \"k--\", label=\"Input Pulse\")\n    axes[0].plot(ts, 20 * jnp.log10(jnp.abs(v_out)), \"r-\", label=\"Output (After WG)\")\n\n    axes[0].set_title(\"Photonic Transient Response\")\n    axes[0].set_xlabel(\"Time (ns)\")\n    axes[0].set_ylabel(\"Power (dBm)\")\n    axes[0].legend()\n    axes[0].grid(True, alpha=0.3)\n\n    axes[1].set_title(\"Ouput Power vs Input Power\")\n    axes[1].set_xlabel(\"Input Power (dB)\")\n    axes[1].set_ylabel(\"Ouput Power(dB)\")\n    axes[1].plot(\n        20 * jnp.log10(jnp.abs(v_in)),\n        (20 * jnp.log10(jnp.abs(v_out))),\n        \"r-\",\n        label=\"Loss\",\n    )\n    axes[1].grid(True, alpha=0.3)\nelse:\n    print(f\"\u274c Simulation Failed: {sol.result}\")\n</pre> print(\"--- DEMO: Photonic Transient (Flat Vector Fix) ---\")  jax.config.update(\"jax_enable_x64\", True)  models_map = {     \"waveguide\": OpticalWaveguide,     \"source\": OpticalSourcePulse,     \"resistor\": Resistor,     \"ground\": lambda: 0, }  net_dict = {     \"instances\": {         \"GND\": {\"component\": \"ground\"},         \"I1\": {\"component\": \"source\", \"settings\": {\"power\": 100.0, \"delay\": 0.1e-9}},         \"WG1\": {             \"component\": \"waveguide\",             \"settings\": {\"length_um\": 1000.0, \"loss_dB_cm\": 20.0, \"tpa_coeff\": 5e-1},         },         \"R1\": {\"component\": \"resistor\", \"settings\": {\"R\": 1.0}},     },     \"connections\": {\"GND,p1\": (\"I1,p2\", \"R1,p2\"), \"I1,p1\": \"WG1,p1\", \"WG1,p2\": \"R1,p1\"}, }  print(\"1. Compiling...\") groups, sys_size, port_map = compile_netlist(net_dict, models_map)  linear_strat = analyze_circuit(groups, sys_size, is_complex=True)  print(\"2. Solving DC Operating Point...\")  y_guess_flat = jnp.zeros(sys_size * 2, dtype=jnp.float64) y_op_flat = linear_strat.solve_dc(groups, y_guess_flat)  print(f\"   DC Converged. Norm: {jnp.linalg.norm(y_op_flat):.2e}\")  transient_sim = setup_transient(groups=groups, linear_strategy=linear_strat)  t_max = 1.0e-9 saveat = diffrax.SaveAt(ts=jnp.linspace(0, t_max, 500))  print(\"3. Running Transient Simulation...\") sol = transient_sim(     t0=0.0,     t1=t_max,     dt0=1e-13,     y0=y_op_flat,     args=(groups, sys_size),     saveat=saveat,     max_steps=100000,     throw=False,     stepsize_controller=diffrax.PIDController(rtol=1e-4, atol=1e-6), )  if sol.result == diffrax.RESULTS.successful:     print(\"   \u2705 Simulation Successful\")      ts = sol.ts * 1e9      ys_flat = sol.ys     ys_complex = ys_flat[:, :sys_size] + 1j * ys_flat[:, sys_size:]      node_in_idx = port_map[\"I1,p1\"]     node_out_idx = port_map[\"R1,p1\"]      v_in = ys_complex[:, node_in_idx]     v_out = ys_complex[:, node_out_idx]      fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(10, 6))     axes = axes.ravel()      axes[0].plot(ts, 20 * jnp.log10(jnp.abs(v_in)), \"k--\", label=\"Input Pulse\")     axes[0].plot(ts, 20 * jnp.log10(jnp.abs(v_out)), \"r-\", label=\"Output (After WG)\")      axes[0].set_title(\"Photonic Transient Response\")     axes[0].set_xlabel(\"Time (ns)\")     axes[0].set_ylabel(\"Power (dBm)\")     axes[0].legend()     axes[0].grid(True, alpha=0.3)      axes[1].set_title(\"Ouput Power vs Input Power\")     axes[1].set_xlabel(\"Input Power (dB)\")     axes[1].set_ylabel(\"Ouput Power(dB)\")     axes[1].plot(         20 * jnp.log10(jnp.abs(v_in)),         (20 * jnp.log10(jnp.abs(v_out))),         \"r-\",         label=\"Loss\",     )     axes[1].grid(True, alpha=0.3) else:     print(f\"\u274c Simulation Failed: {sol.result}\") <pre>--- DEMO: Photonic Transient (Flat Vector Fix) ---\n1. Compiling...\n2. Solving DC Operating Point...\n</pre> <pre>   DC Converged. Norm: 1.92e+00\n3. Running Transient Simulation...\n</pre> <pre>   \u2705 Simulation Successful\n</pre>"},{"location":"examples/photonics_transient/#photonics-transient","title":"Photonics Transient\u00b6","text":""},{"location":"examples/resistor_ladder/","title":"Resistor ladder","text":"<p>Before running complex transient analyses, it is standard practice to validate the solver against a known analytical solution. For this purpose, we use the R-2R Ladder Network.This circuit acts as a precise voltage divider. We have configured a \"1-2-1\" ladder where:</p> <p>Series Resistors ($R_S$) = $1000\\Omega$ ($R$) Shunt/Termination Resistors ($R_P$) = $2000\\Omega$ ($2R$)T</p> <p>The Analytical Benchmark: Due to the recursive nature of the equivalent resistance in an R-2R ladder, the voltage at each successive node should be exactly half of the previous node.</p> <ul> <li>Node 1: $4.0V$</li> <li>Node 2: $2.0V$</li> <li>Node 3: $1.0V$</li> </ul> In\u00a0[1]: Copied! <pre>import time\n\nimport jax\nimport jax.numpy as jnp\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom circulax.compiler import compile_netlist\nfrom circulax.components.electronic import Resistor, VoltageSource\nfrom circulax.solvers import analyze_circuit\n</pre> import time  import jax import jax.numpy as jnp import matplotlib.pyplot as plt import numpy as np  from circulax.compiler import compile_netlist from circulax.components.electronic import Resistor, VoltageSource from circulax.solvers import analyze_circuit In\u00a0[2]: Copied! <pre>net_dict = {\n    \"instances\": {\n        \"GND\": {\"component\": \"ground\"},\n        \"V_REF\": {\"component\": \"source_voltage\", \"settings\": {\"V\": 8.0}},\n        \"R_S1\": {\"component\": \"resistor\", \"settings\": {\"R\": 1000.0}},\n        \"R_P1\": {\"component\": \"resistor\", \"settings\": {\"R\": 2000.0}},\n        \"R_S2\": {\"component\": \"resistor\", \"settings\": {\"R\": 1000.0}},\n        \"R_P2\": {\"component\": \"resistor\", \"settings\": {\"R\": 2000.0}},\n        \"R_S3\": {\"component\": \"resistor\", \"settings\": {\"R\": 1000.0}},\n        \"R_P3\": {\"component\": \"resistor\", \"settings\": {\"R\": 2000.0}},\n        \"R_TERM\": {\"component\": \"resistor\", \"settings\": {\"R\": 2000.0}},\n    },\n    \"connections\": {\n        \"GND,p1\": (\"V_REF,p2\", \"R_P1,p2\", \"R_P2,p2\", \"R_P3,p2\", \"R_TERM,p2\"),\n        \"V_REF,p1\": \"R_S1,p1\",\n        \"R_S1,p2\": (\"R_P1,p1\", \"R_S2,p1\"),\n        \"R_S2,p2\": (\"R_P2,p1\", \"R_S3,p1\"),\n        \"R_S3,p2\": (\"R_P3,p1\", \"R_TERM,p1\"),\n    },\n}\n</pre> net_dict = {     \"instances\": {         \"GND\": {\"component\": \"ground\"},         \"V_REF\": {\"component\": \"source_voltage\", \"settings\": {\"V\": 8.0}},         \"R_S1\": {\"component\": \"resistor\", \"settings\": {\"R\": 1000.0}},         \"R_P1\": {\"component\": \"resistor\", \"settings\": {\"R\": 2000.0}},         \"R_S2\": {\"component\": \"resistor\", \"settings\": {\"R\": 1000.0}},         \"R_P2\": {\"component\": \"resistor\", \"settings\": {\"R\": 2000.0}},         \"R_S3\": {\"component\": \"resistor\", \"settings\": {\"R\": 1000.0}},         \"R_P3\": {\"component\": \"resistor\", \"settings\": {\"R\": 2000.0}},         \"R_TERM\": {\"component\": \"resistor\", \"settings\": {\"R\": 2000.0}},     },     \"connections\": {         \"GND,p1\": (\"V_REF,p2\", \"R_P1,p2\", \"R_P2,p2\", \"R_P3,p2\", \"R_TERM,p2\"),         \"V_REF,p1\": \"R_S1,p1\",         \"R_S1,p2\": (\"R_P1,p1\", \"R_S2,p1\"),         \"R_S2,p2\": (\"R_P2,p1\", \"R_S3,p1\"),         \"R_S3,p2\": (\"R_P3,p1\", \"R_TERM,p1\"),     }, } In\u00a0[4]: Copied! <pre>jax.config.update(\"jax_enable_x64\", True)\n\nmodels_map = {\n    \"resistor\": Resistor,\n    \"source_voltage\": VoltageSource,\n    \"ground\": lambda: 0,\n}\n\n\nprint(\"1. Compiling Circuit...\")\ngroups, num_vars, port_map = compile_netlist(net_dict, models_map)\nprint(f\"   System Size: {num_vars} variables\")\n\nlinear_strategy = analyze_circuit(groups, num_vars)\n\nprint(\"\\n2. Solving DC Operating Point...\")\n\ny_guess = jnp.zeros(num_vars)\n\nstart = time.time()\ny_dc = linear_strategy.solve_dc(component_groups=groups, y_guess=y_guess)\nprint(f\"Time take = {time.time() - start:.4f}s\")\n\nprint(\"\\n3. Verification:\")\n\n\ndef get_v(name):\n    idx = port_map[name]\n    return float(y_dc[idx])\n\n\nv_n1 = get_v(\"R_S1,p2\")\nv_n2 = get_v(\"R_S2,p2\")\nv_n3 = get_v(\"R_S3,p2\")\n\nprint(\"   V_REF:    8.0 V\")\nprint(f\"   Node 1:   {v_n1:.4f} V  (Expected: 4.0000 V)\")\nprint(f\"   Node 2:   {v_n2:.4f} V  (Expected: 2.0000 V)\")\nprint(f\"   Node 3:   {v_n3:.4f} V  (Expected: 1.0000 V)\")\n\nv_gnd = get_v(\"R_TERM,p2\")\nprint(f\"   Ground:   {v_gnd:.1e} V  (Expected: 0.0)\")\n\nnodes = [\"Node 1\", \"Node 2\", \"Node 3\"]\nvoltages = [v_n1, v_n2, v_n3]\nexpected = [4.0, 2.0, 1.0]\n\nplt.figure(figsize=(8, 4))\nx = np.arange(len(nodes))\nwidth = 0.35\n\nplt.bar(x - width / 2, expected, width, label=\"Theoretical\", color=\"gray\", alpha=0.5)\nplt.bar(\n    x + width / 2, voltages, width, label=\"Solver Output\", color=\"tab:blue\", alpha=0.8\n)\n\nplt.ylabel(\"Voltage (V)\")\nplt.title(\"DC Solver Accuracy Test (R-2R Ladder)\")\nplt.xticks(x, nodes)\nplt.legend()\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.7)\n\nmax_err = np.max(np.abs(np.array(voltages) - np.array(expected)))\nplt.text(\n    1,\n    3,\n    f\"Max Error: {max_err:.2e} V\",\n    ha=\"center\",\n    fontsize=12,\n    bbox=dict(facecolor=\"white\", alpha=0.8),\n)\n\nplt.show()\n\nif max_err &lt; 1e-6:\n    print(\"\\n\u2705 DC Solver PASSED\")\nelse:\n    print(\"\\n\u274c DC Solver FAILED\")\n</pre> jax.config.update(\"jax_enable_x64\", True)  models_map = {     \"resistor\": Resistor,     \"source_voltage\": VoltageSource,     \"ground\": lambda: 0, }   print(\"1. Compiling Circuit...\") groups, num_vars, port_map = compile_netlist(net_dict, models_map) print(f\"   System Size: {num_vars} variables\")  linear_strategy = analyze_circuit(groups, num_vars)  print(\"\\n2. Solving DC Operating Point...\")  y_guess = jnp.zeros(num_vars)  start = time.time() y_dc = linear_strategy.solve_dc(component_groups=groups, y_guess=y_guess) print(f\"Time take = {time.time() - start:.4f}s\")  print(\"\\n3. Verification:\")   def get_v(name):     idx = port_map[name]     return float(y_dc[idx])   v_n1 = get_v(\"R_S1,p2\") v_n2 = get_v(\"R_S2,p2\") v_n3 = get_v(\"R_S3,p2\")  print(\"   V_REF:    8.0 V\") print(f\"   Node 1:   {v_n1:.4f} V  (Expected: 4.0000 V)\") print(f\"   Node 2:   {v_n2:.4f} V  (Expected: 2.0000 V)\") print(f\"   Node 3:   {v_n3:.4f} V  (Expected: 1.0000 V)\")  v_gnd = get_v(\"R_TERM,p2\") print(f\"   Ground:   {v_gnd:.1e} V  (Expected: 0.0)\")  nodes = [\"Node 1\", \"Node 2\", \"Node 3\"] voltages = [v_n1, v_n2, v_n3] expected = [4.0, 2.0, 1.0]  plt.figure(figsize=(8, 4)) x = np.arange(len(nodes)) width = 0.35  plt.bar(x - width / 2, expected, width, label=\"Theoretical\", color=\"gray\", alpha=0.5) plt.bar(     x + width / 2, voltages, width, label=\"Solver Output\", color=\"tab:blue\", alpha=0.8 )  plt.ylabel(\"Voltage (V)\") plt.title(\"DC Solver Accuracy Test (R-2R Ladder)\") plt.xticks(x, nodes) plt.legend() plt.grid(axis=\"y\", linestyle=\"--\", alpha=0.7)  max_err = np.max(np.abs(np.array(voltages) - np.array(expected))) plt.text(     1,     3,     f\"Max Error: {max_err:.2e} V\",     ha=\"center\",     fontsize=12,     bbox=dict(facecolor=\"white\", alpha=0.8), )  plt.show()  if max_err &lt; 1e-6:     print(\"\\n\u2705 DC Solver PASSED\") else:     print(\"\\n\u274c DC Solver FAILED\") <pre>1. Compiling Circuit...\n   System Size: 6 variables\n</pre> <pre>\n2. Solving DC Operating Point...\n</pre> <pre>Time take = 0.3032s\n\n3. Verification:\n   V_REF:    8.0 V\n   Node 1:   4.0000 V  (Expected: 4.0000 V)\n   Node 2:   2.0000 V  (Expected: 2.0000 V)\n   Node 3:   1.0000 V  (Expected: 1.0000 V)\n   Ground:   -4.4e-25 V  (Expected: 0.0)\n</pre> <pre>\n\u2705 DC Solver PASSED\n</pre>"},{"location":"examples/resistor_ladder/#resistor-ladder","title":"Resistor Ladder\u00b6","text":""},{"location":"references/","title":"Index","text":""},{"location":"references/#circulax","title":"circulax","text":"<p>circulax: A differentiable, JAX based circuit simulator.</p> <p>Modules:</p> Name Description <code>compiler</code> <p>Compiles the group into ComponentGroups and organizes the node index.</p> <code>components</code> <code>netlist</code> <p>circulax netlists.</p> <code>s_transforms</code> <p>Utilities for converting between S-parameters.</p> <code>solvers</code> <p>Root finding and transient solvers.</p> <code>utils</code> <p>circulax utilities.</p>"},{"location":"references/_version/","title":"version","text":""},{"location":"references/_version/#circulax._version","title":"_version","text":""},{"location":"references/compiler/","title":"Compiler","text":""},{"location":"references/compiler/#circulax.compiler","title":"compiler","text":"<p>Compiles the group into ComponentGroups and organizes the node index.</p> <p>Classes:</p> Name Description <code>ComponentGroup</code> <p>Represents a BATCH of identical components (e.g., ALL Resistors).</p> <p>Functions:</p> Name Description <code>compile_netlist</code> <p>Compile a netlist into batched, vectorized component groups ready for simulation.</p> <code>ensure_time_signature</code> <p>Wraps a model function to ensure it accepts a 't' keyword argument.</p> <code>get_default_params</code> <p>Return a copy so callers can\u2019t mutate the cache.</p> <code>get_model_width</code> <p>Determines the size of the 'vars' vector expected by the model.</p> <code>merge_dicts</code> <p>Merges a list of dictionaries into a single dictionary.</p> <code>solve_connectivity</code> <p>Resolves Port-to-Port connections into a Port-to-NodeID map.</p>"},{"location":"references/compiler/#circulax.compiler.ComponentGroup","title":"ComponentGroup","text":"<p>               Bases: <code>Module</code></p> <p>Represents a BATCH of identical components (e.g., ALL Resistors). Optimized for jax.vmap in the solver.</p>"},{"location":"references/compiler/#circulax.compiler.compile_netlist","title":"compile_netlist","text":"<pre><code>compile_netlist(netlist: dict, models_map: dict) -&gt; tuple[dict, int, dict]\n</code></pre> <p>Compile a netlist into batched, vectorized component groups ready for simulation.</p> <p>This function bridges the gap between a human-readable netlist description and the internal representation required by the ODE solver. It resolves net connectivity, instantiates component objects, assigns state variable indices, and batches components of the same type into vectorized groups for efficient JAX execution.</p> <p>The compilation proceeds in three stages:</p> <ol> <li>Connectivity resolution \u2014 <code>build_net_map</code> assigns a unique integer    node index to every net, returning a flat map of <code>\"Instance,Port\"</code> keys    to node indices.</li> <li>Instance processing \u2014 each instance is instantiated as an Equinox    object using its settings, its port indices are looked up in the node map,    and it is placed into a bucket keyed by <code>(component_type, tree_structure)</code>.    The tree structure is included in the key so that instances whose static    fields differ (e.g. a callable parameter) are never incorrectly batched    together.</li> <li>Vectorization \u2014 each bucket is stacked into a single    :class:<code>ComponentGroup</code> with batched parameters and pre-computed Jacobian    sparsity index arrays, ready to be passed directly to the solver.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>netlist</code> <code>dict</code> <p>Circuit description dict. Expected to contain an <code>\"instances\"</code> key mapping instance names to dicts with at least a <code>\"component\"</code> key (model name string) and an optional <code>\"settings\"</code> key (parameter dict forwarded to the component constructor). A <code>\"GND\"</code> instance with <code>component=\"ground\"</code> is recognised and skipped.</p> required <code>models_map</code> <code>dict</code> <p>Mapping from model name strings to :class:<code>~circulax.components.base_component.CircuitComponent</code> subclasses, e.g. <code>{\"Resistor\": Resistor, \"Capacitor\": Capacitor}</code>.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A three-tuple <code>(compiled_groups, sys_size, port_to_node_map)</code> where:</p> <code>int</code> <ul> <li>compiled_groups (<code>dict[str, ComponentGroup]</code>) \u2014 maps group name to a fully vectorized :class:<code>ComponentGroup</code>. If all instances of a type share the same tree structure there is one group per type, named after the type (e.g. <code>\"Resistor\"</code>). When a type is split across multiple structures the groups are numbered (<code>\"Resistor_0\"</code>, <code>\"Resistor_1\"</code>, \u2026).</li> </ul> <code>dict</code> <ul> <li>sys_size (<code>int</code>) \u2014 total number of scalar unknowns in the system vector <code>y</code>, equal to the number of nets plus the total number of state variables across all instances. This is the length of the array passed to the solver.</li> </ul> <code>tuple[dict, int, dict]</code> <ul> <li>port_to_node_map (<code>dict[str, int]</code>) \u2014 the raw <code>\"Instance,Port\"</code> \u2192 node index map produced by <code>build_net_map</code>, returned for use by callers that need to extract specific node voltages from the solution vector.</li> </ul> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a component type listed in the netlist is not present in <code>models_map</code>, or if a port declared on a component class has no corresponding entry in the netlist connections.</p> <code>TypeError</code> <p>If the settings dict for an instance does not match the constructor signature of its component class.</p> Source code in <code>circulax/compiler.py</code> <pre><code>def compile_netlist(netlist: dict, models_map: dict) -&gt; tuple[dict, int, dict]:  # noqa: C901, PLR0912, PLR0915\n    \"\"\"Compile a netlist into batched, vectorized component groups ready for simulation.\n\n    This function bridges the gap between a human-readable netlist description and\n    the internal representation required by the ODE solver. It resolves net\n    connectivity, instantiates component objects, assigns state variable indices,\n    and batches components of the same type into vectorized groups for efficient\n    JAX execution.\n\n    The compilation proceeds in three stages:\n\n    1. **Connectivity resolution** \u2014 ``build_net_map`` assigns a unique integer\n       node index to every net, returning a flat map of ``\"Instance,Port\"`` keys\n       to node indices.\n    2. **Instance processing** \u2014 each instance is instantiated as an Equinox\n       object using its settings, its port indices are looked up in the node map,\n       and it is placed into a bucket keyed by ``(component_type, tree_structure)``.\n       The tree structure is included in the key so that instances whose static\n       fields differ (e.g. a callable parameter) are never incorrectly batched\n       together.\n    3. **Vectorization** \u2014 each bucket is stacked into a single\n       :class:`ComponentGroup` with batched parameters and pre-computed Jacobian\n       sparsity index arrays, ready to be passed directly to the solver.\n\n    Args:\n        netlist: Circuit description dict. Expected to contain an\n            ``\"instances\"`` key mapping instance names to dicts with at least\n            a ``\"component\"`` key (model name string) and an optional\n            ``\"settings\"`` key (parameter dict forwarded to the component\n            constructor). A ``\"GND\"`` instance with ``component=\"ground\"`` is\n            recognised and skipped.\n        models_map: Mapping from model name strings to\n            :class:`~circulax.components.base_component.CircuitComponent`\n            subclasses, e.g. ``{\"Resistor\": Resistor, \"Capacitor\": Capacitor}``.\n\n    Returns:\n        A three-tuple ``(compiled_groups, sys_size, port_to_node_map)`` where:\n\n        - **compiled_groups** (``dict[str, ComponentGroup]``) \u2014 maps group name\n            to a fully vectorized :class:`ComponentGroup`. If all instances of a\n            type share the same tree structure there is one group per type, named\n            after the type (e.g. ``\"Resistor\"``). When a type is split across\n            multiple structures the groups are numbered (``\"Resistor_0\"``,\n            ``\"Resistor_1\"``, \u2026).\n        - **sys_size** (``int``) \u2014 total number of scalar unknowns in the system\n            vector ``y``, equal to the number of nets plus the total number of\n            state variables across all instances. This is the length of the array\n            passed to the solver.\n        - **port_to_node_map** (``dict[str, int]``) \u2014 the raw ``\"Instance,Port\"``\n            \u2192 node index map produced by ``build_net_map``, returned for use by\n            callers that need to extract specific node voltages from the solution\n            vector.\n\n    Raises:\n        ValueError: If a component type listed in the netlist is not present in\n            ``models_map``, or if a port declared on a component class has no\n            corresponding entry in the netlist connections.\n        TypeError: If the settings dict for an instance does not match the\n            constructor signature of its component class.\n\n    \"\"\"\n    port_to_node_map, num_nodes = build_net_map(netlist)\n\n    # Buckets: Key = (comp_type_name, tree_structure), Value = list of instances\n    buckets = defaultdict(list)\n    sys_size = num_nodes\n\n    # --- 2. Process Instances ---\n    instances = netlist.get(\"instances\", {})\n\n    for name, data in instances.items():\n        comp_type = data[\"component\"]\n\n        # Skip ground (it's just a marker, already handled in build_net_map)\n        if comp_type == \"ground\" or name == \"GND\":\n            continue\n\n        if comp_type not in models_map:\n            msg = f\"Model '{comp_type}' not found for '{name}'\"\n            raise ValueError(msg)\n\n        comp_cls = models_map[comp_type]\n        settings = data.get(\"settings\", {})\n\n        # A. Create Equinox Object\n        try:\n            comp_obj = comp_cls(**settings)\n        except TypeError as e:\n            msg = f\"Settings error for {name}: {e}\"\n            raise TypeError(msg)  # noqa: B904\n\n        # B. Get Port Indices\n        port_indices = []\n        for port in comp_cls.ports:\n            key = f\"{name},{port}\"\n\n            if key in port_to_node_map:\n                port_indices.append(port_to_node_map[key])\n            else:\n                msg = f\"Port '{port}' on '{name}' is unconnected.\\nYour netlist connections must include '{key}'\"\n                raise ValueError(msg)\n\n        # Group by Type AND Structure (to handle static field differences)\n        structure = jax.tree.structure(comp_obj)\n        buckets[(comp_type, structure)].append(\n            {\n                \"obj\": comp_obj,\n                \"ports\": port_indices,\n                \"num_states\": len(comp_cls.states),\n                \"name\": name,\n            }\n        )\n\n    compiled_groups = {}\n\n    # Helper to generate unique names for split groups\n    type_counts = defaultdict(int)\n    for ctype, _ in buckets:\n        type_counts[ctype] += 1\n    type_counters = defaultdict(int)\n\n    for (comp_type, _), items in buckets.items():\n        comp_cls = models_map[comp_type]\n\n        # Generate Group Name\n        if type_counts[comp_type] &gt; 1:\n            idx = type_counters[comp_type]\n            group_name = f\"{comp_type}_{idx}\"\n            type_counters[comp_type] += 1\n        else:\n            group_name = comp_type\n\n        # A. Assign Internal States\n        all_var_indices = []\n        for item in items:\n            state_indices = []\n            for _ in range(item[\"num_states\"]):\n                state_indices.append(sys_size)\n                sys_size += 1\n            all_var_indices.append(item[\"ports\"] + state_indices)\n\n        # B. Batch Params\n        instance_objects = [item[\"obj\"] for item in items]\n        batched_params = jax.tree.map(lambda *args: jnp.stack(args), *instance_objects)\n\n        # C. Matrices\n        var_indices_arr = jnp.array(all_var_indices, dtype=jnp.int32)\n        width = var_indices_arr.shape[1]\n        count = len(items)\n\n        jac_rows = jnp.broadcast_to(var_indices_arr[:, :, None], (count, width, width))\n        jac_cols = jnp.broadcast_to(var_indices_arr[:, None, :], (count, width, width))\n\n        # Create Index Map for parameter updates\n        index_map = {item[\"name\"]: i for i, item in enumerate(items)}\n\n        compiled_groups[group_name] = ComponentGroup(\n            name=group_name,\n            var_indices=var_indices_arr,\n            eq_indices=var_indices_arr,\n            params=batched_params,\n            physics_func=comp_cls.solver_call,\n            jac_rows=jac_rows,\n            jac_cols=jac_cols,\n            index_map=index_map,\n        )\n\n    return compiled_groups, sys_size, port_to_node_map\n</code></pre>"},{"location":"references/compiler/#circulax.compiler.ensure_time_signature","title":"ensure_time_signature","text":"<pre><code>ensure_time_signature(model_func: callable) -&gt; callable\n</code></pre> <p>Wraps a model function to ensure it accepts a 't' keyword argument.</p> <p>If the original model doesn't take 't', the wrapper swallows it.</p> Source code in <code>circulax/compiler.py</code> <pre><code>def ensure_time_signature(model_func: callable) -&gt; callable:\n    \"\"\"Wraps a model function to ensure it accepts a 't' keyword argument.\n\n    If the original model doesn't take 't', the wrapper swallows it.\n    \"\"\"\n    sig = inspect.signature(model_func)\n\n    if \"t\" in sig.parameters or \"**kwargs\" in str(sig):\n        return model_func\n\n    # Wrapper for static models\n    @wraps(model_func)\n    def time_aware_wrapper(signal_states: Signals, params: dict, t: float | None = None) -&gt; PhysicsReturn:  # noqa: ARG001\n        return model_func(signal_states, params)\n\n    return time_aware_wrapper\n</code></pre>"},{"location":"references/compiler/#circulax.compiler.get_default_params","title":"get_default_params","text":"<pre><code>get_default_params(func: callable) -&gt; dict[str, Any]\n</code></pre> <p>Return a copy so callers can\u2019t mutate the cache.</p> Source code in <code>circulax/compiler.py</code> <pre><code>def get_default_params(func: callable) -&gt; dict[str, Any]:\n    \"\"\"Return a copy so callers can\u2019t mutate the cache.\"\"\"\n    return dict(_get_default_params_cached(func))\n</code></pre>"},{"location":"references/compiler/#circulax.compiler.get_model_width","title":"get_model_width","text":"<pre><code>get_model_width(func: callable) -&gt; int\n</code></pre> <p>Determines the size of the 'vars' vector expected by the model.</p> Source code in <code>circulax/compiler.py</code> <pre><code>def get_model_width(func: callable) -&gt; int:\n    \"\"\"Determines the size of the 'vars' vector expected by the model.\"\"\"\n    sig = inspect.signature(func)\n    if \"vars\" not in sig.parameters:\n        msg = f\"{func.__name__} missing 'vars' argument\"\n        raise ValueError(msg)\n    default_val = sig.parameters[\"vars\"].default\n    if default_val is inspect.Parameter.empty:\n        msg = f\"{func.__name__} 'vars' must have a default (e.g. jnp.zeros(3))\"\n        raise ValueError(msg)\n    return len(default_val)\n</code></pre>"},{"location":"references/compiler/#circulax.compiler.merge_dicts","title":"merge_dicts","text":"<pre><code>merge_dicts(dict_list: list[dict[str, Any]]) -&gt; dict[str, Any]\n</code></pre> <p>Merges a list of dictionaries into a single dictionary.</p> Source code in <code>circulax/compiler.py</code> <pre><code>def merge_dicts(dict_list: list[dict[str, Any]]) -&gt; dict[str, Any]:\n    \"\"\"Merges a list of dictionaries into a single dictionary.\"\"\"\n    merged = {}\n    for d in dict_list:\n        merged.update(d)\n    return merged\n</code></pre>"},{"location":"references/compiler/#circulax.compiler.solve_connectivity","title":"solve_connectivity","text":"<pre><code>solve_connectivity(connections: dict) -&gt; dict\n</code></pre> <p>Resolves Port-to-Port connections into a Port-to-NodeID map.</p> <p>Example: {\"R1,p1\": \"V1,p1\"} -&gt; {\"R1,p1\": 1, \"V1,p1\": 1}</p> Source code in <code>circulax/compiler.py</code> <pre><code>def solve_connectivity(connections: dict) -&gt; dict:  # noqa: C901\n    \"\"\"Resolves Port-to-Port connections into a Port-to-NodeID map.\n\n    Example: {\"R1,p1\": \"V1,p1\"} -&gt; {\"R1,p1\": 1, \"V1,p1\": 1}\n    \"\"\"\n    parent = {}\n\n    def find(i: int):  # noqa: ANN202\n        if i not in parent:\n            parent[i] = i\n        if parent[i] != i:\n            parent[i] = find(parent[i])\n        return parent[i]\n\n    def union(i: int, j: int) -&gt; None:\n        root_i = find(i)\n        root_j = find(j)\n        if root_i != root_j:\n            parent[root_i] = root_j\n\n    # 1. Process all connections\n    for src, targets in connections.items():\n        # Ensure 'targets' is a list\n        if not isinstance(targets, (list, tuple)):\n            targets = [targets]\n\n        # Link Source to all Targets\n        for tgt in targets:\n            union(src, tgt)\n\n    # 2. Assign Node IDs\n    # We reserve ID 0 for Ground (any group containing \"GND\")\n    groups = {}\n    node_map = {}\n\n    # Identify the root for \"GND\" if it exists\n    gnd_roots = {find(k) for k in parent if \"GND\" in k}\n\n    node_counter = 1\n\n    for port in parent:\n        root = find(port)\n\n        if root in gnd_roots:\n            node_id = 0\n        else:\n            if root not in groups:\n                groups[root] = node_counter\n                node_counter += 1\n            node_id = groups[root]\n\n        node_map[port] = node_id\n\n    return node_map, node_counter\n</code></pre>"},{"location":"references/netlist/","title":"Netlist","text":""},{"location":"references/netlist/#circulax.netlist","title":"netlist","text":"<p>circulax netlists.</p> <p>SAX netlists will be used as much as possible in circulax; however, connections for node based simulators need to be handled slightly differently.</p> <p>Functions:</p> Name Description <code>build_net_map</code> <p>Maps every port (e.g. 'R1,p1') to a generic Node Index (integer).</p> <code>draw_circuit_graph</code> <p>Visualize a circuit netlist as a connectivity graph.</p> <p>Attributes:</p> Name Type Description <code>circulaxNetlist</code> <p>A complete netlist definition for an optical circuit.</p>"},{"location":"references/netlist/#circulax.netlist.circulaxNetlist","title":"circulaxNetlist  <code>module-attribute</code>","text":"<pre><code>circulaxNetlist = Annotated[\n    TypedDict(\n        \"Netlist\",\n        {\n            \"instances\": Instances,\n            \"connections\": NotRequired[Connections],\n            \"ports\": Ports,\n            \"placements\": NotRequired[Placements],\n            \"settings\": NotRequired[Settings],\n        },\n    ),\n    bval(val_netlist),\n]\n</code></pre> <p>A complete netlist definition for an optical circuit.</p> <p>Contains all information needed to define a circuit: instances, connections, external ports, and optional placement/settings.</p> <p>Attributes:</p> Name Type Description <code>instances</code> <p>The component instances in the circuit.</p> <code>connections</code> <p>Point-to-point connections between instances.</p> <code>ports</code> <p>Mapping of external ports to internal instance ports.</p> <code>placements</code> <p>Physical placement information for instances.</p> <code>settings</code> <p>Global circuit settings.</p>"},{"location":"references/netlist/#circulax.netlist.build_net_map","title":"build_net_map","text":"<pre><code>build_net_map(netlist: dict) -&gt; tuple[dict[str, int], int]\n</code></pre> <p>Maps every port (e.g. 'R1,p1') to a generic Node Index (integer).</p> <p>Returns:</p> Name Type Description <code>port_to_idx</code> <code>dict[str, int]</code> <p>dict mapping 'Instance,Pin' -&gt; int index</p> <code>num_nets</code> <code>int</code> <p>Total number of unique electrical nodes (excluding Ground).</p> Source code in <code>circulax/netlist.py</code> <pre><code>def build_net_map(netlist: dict) -&gt; tuple[dict[str, int], int]:\n    \"\"\"Maps every port (e.g. 'R1,p1') to a generic Node Index (integer).\n\n    Returns:\n        port_to_idx: dict mapping 'Instance,Pin' -&gt; int index\n        num_nets: Total number of unique electrical nodes (excluding Ground).\n\n    \"\"\"\n    g = nx.Graph()\n\n    # Add connections\n    for src, targets in netlist.get(\"connections\", {}).items():\n        if isinstance(targets, str):\n            targets = [targets]\n        for tgt in targets:\n            g.add_edge(src, tgt)\n\n    # Find connected components (nets)\n    components = list(nx.connected_components(g))\n    components.sort(key=lambda x: natsorted(list(x))[0])  # Deterministic sort\n\n    port_to_idx = {}\n    current_idx = 1  # Start at 1, 0 is reserved for Ground\n\n    for comp in components:\n        is_ground = any(\"GND\" in node for node in comp)\n        net_id = 0 if is_ground else current_idx\n\n        for node in comp:\n            port_to_idx[node] = net_id\n\n        if not is_ground:\n            current_idx += 1\n\n    return port_to_idx, current_idx\n</code></pre>"},{"location":"references/netlist/#circulax.netlist.draw_circuit_graph","title":"draw_circuit_graph","text":"<pre><code>draw_circuit_graph(\n    netlist: dict[str, dict], layout_attempts: int = 10, *, show: bool = True\n) -&gt; Figure\n</code></pre> <p>Visualize a circuit netlist as a connectivity graph.</p> Nodes are split into two categories <ul> <li>Instance nodes: large circles (red for components, black for GND)   representing circuit components.</li> <li>Port nodes: small skyblue circles representing the pins on each   component. Each port is drawn close to its parent instance.</li> </ul> Edges are split into two categories <ul> <li>Internal edges: solid lines connecting each port to its parent instance.</li> <li>External edges (wires): dashed gray lines connecting ports that share   the same net, labelled with the net index.</li> </ul> <p>The layout is computed by running <code>networkx.spring_layout</code> up to <code>layout_attempts</code> times with different seeds. Each candidate layout is scored by counting proper edge-segment crossings, and the layout with the fewest crossings is used. Port nodes are warm-started near their parent instance to encourage tight visual clustering regardless of which seed wins.</p> <p>Parameters:</p> Name Type Description Default <code>netlist</code> <code>dict[str, dict]</code> <p>Circuit description dict. Must contain an <code>\"instances\"</code> key mapping component names to their data. Connectivity is derived via <code>build_net_map</code>, which returns a port map of the form <code>\"InstanceName,PinName\" -&gt; net_index</code>.</p> required <code>show</code> <code>bool</code> <p>If <code>True</code>, call <code>plt.show()</code> before returning. Set to <code>False</code> when embedding the figure in a larger application or when running in a non-interactive environment.</p> <code>True</code> <code>layout_attempts</code> <code>int</code> <p>Number of spring-layout seeds to try. The candidate with the fewest edge crossings is kept. Higher values improve crossing minimisation at the cost of extra compute time. Defaults to <code>10</code>; values between <code>20</code> and <code>30</code> are reasonable for larger netlists.</p> <code>10</code> <p>Returns:</p> Name Type Description <code>The</code> <code>Figure</code> <p>class:<code>matplotlib.figure.Figure</code> containing the rendered graph.</p> Source code in <code>circulax/netlist.py</code> <pre><code>def draw_circuit_graph(  # noqa: C901, PLR0912, PLR0915\n    netlist: dict[str, dict],\n    layout_attempts: int = 10,\n    *,\n    show: bool = True,\n) -&gt; mpl.figure.Figure:\n    \"\"\"Visualize a circuit netlist as a connectivity graph.\n\n    Nodes are split into two categories:\n      - Instance nodes: large circles (red for components, black for GND)\n        representing circuit components.\n      - Port nodes: small skyblue circles representing the pins on each\n        component. Each port is drawn close to its parent instance.\n\n    Edges are split into two categories:\n      - Internal edges: solid lines connecting each port to its parent instance.\n      - External edges (wires): dashed gray lines connecting ports that share\n        the same net, labelled with the net index.\n\n    The layout is computed by running ``networkx.spring_layout`` up to\n    ``layout_attempts`` times with different seeds. Each candidate layout is\n    scored by counting proper edge-segment crossings, and the layout with the\n    fewest crossings is used. Port nodes are warm-started near their parent\n    instance to encourage tight visual clustering regardless of which seed wins.\n\n    Args:\n        netlist: Circuit description dict. Must contain an ``\"instances\"`` key\n            mapping component names to their data. Connectivity is derived via\n            ``build_net_map``, which returns a port map of the form\n            ``\"InstanceName,PinName\" -&gt; net_index``.\n        show: If ``True``, call ``plt.show()`` before returning. Set to\n            ``False`` when embedding the figure in a larger application or\n            when running in a non-interactive environment.\n        layout_attempts: Number of spring-layout seeds to try. The candidate\n            with the fewest edge crossings is kept. Higher values improve\n            crossing minimisation at the cost of extra compute time.\n            Defaults to ``10``; values between ``20`` and ``30`` are\n            reasonable for larger netlists.\n\n    Returns:\n        The :class:`matplotlib.figure.Figure` containing the rendered graph.\n\n    \"\"\"\n    port_map, _= build_net_map(netlist)\n\n    G = nx.Graph()\n\n    instances = netlist.get(\"instances\", {})\n    for name in instances:\n        if name == \"GND\":\n            G.add_node(name, color=\"black\", size=1500, label=name)\n        else:\n            G.add_node(name, color=\"red\", size=2000, label=name)\n\n\n    net_groups = {}\n\n    for port_str, net_idx in port_map.items():\n        if \",\" not in port_str:\n            continue\n\n        inst_name, pin_name = port_str.split(\",\", 1)\n\n        G.add_node(\n            port_str, color=\"skyblue\", size=300, label=pin_name, parent=inst_name\n        )\n\n        if inst_name in G.nodes:\n            G.add_edge(inst_name, port_str, weight=10, type=\"internal\")\n\n        if net_idx not in net_groups:\n            net_groups[net_idx] = []\n        net_groups[net_idx].append(port_str)\n\n    edge_labels = {}\n\n    for net_idx, ports in net_groups.items():\n        if len(ports) &gt; 1:\n            for i in range(len(ports) - 1):\n                u, v = ports[i], ports[i + 1]\n                G.add_edge(u, v, weight=1, type=\"external\")\n                edge_labels[(u, v)] = str(net_idx)\n\n    def make_initial_pos(seed: int) -&gt; dict:\n        rng = np.random.default_rng(seed)\n        pos = {}\n        instance_nodes = [\n            n for n, d in G.nodes(data=True) if d.get(\"color\") in [\"red\", \"black\"]\n        ]\n\n        # Place instances on a rough grid / random spread\n        for name in instance_nodes:\n            pos[name] = rng.uniform(-1, 1, size=2)\n\n        # Place each port with a small random offset from its parent\n        for n, d in G.nodes(data=True):\n            if d.get(\"color\") == \"skyblue\":\n                parent = d.get(\"parent\")\n                if parent and parent in pos:\n                    pos[n] = pos[parent] + rng.uniform(-0.1, 0.1, size=2)\n                else:\n                    pos[n] = rng.uniform(-1, 1, size=2)\n        return pos\n\n    def count_crossings(pos: dict[str, np.ndarray]) -&gt; int:\n\n        def segments_intersect(\n            p1: np.ndarray, p2: np.ndarray, p3: np.ndarray, p4: np.ndarray\n        ) -&gt; bool:\n\n            def cross(o: np.ndarray, a: np.ndarray, b: np.ndarray) -&gt; float:\n                return float((a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]))\n\n            d1 = cross(p3, p4, p1)\n            d2 = cross(p3, p4, p2)\n            d3 = cross(p1, p2, p3)\n            d4 = cross(p1, p2, p4)\n\n            return bool(((d1 &gt; 0 and d2 &lt; 0) or (d1 &lt; 0 and d2 &gt; 0))\n                        and ((d3 &gt; 0 and d4 &lt; 0) or (d3 &lt; 0 and d4 &gt; 0)))\n\n        edges = list(G.edges())\n        crossings = 0\n        for i in range(len(edges)):\n            for j in range(i + 1, len(edges)):\n                u1, v1 = edges[i]\n                u2, v2 = edges[j]\n                # Skip pairs that share a node (adjacent edges always \"meet\", not cross)\n                if u1 in (u2, v2) or v1 in (u2, v2):\n                    continue\n                p1, p2 = pos[u1], pos[v1]\n                p3, p4 = pos[u2], pos[v2]\n                if segments_intersect(p1, p2, p3, p4):\n                    crossings += 1\n        return crossings\n\n    best_pos = None\n    best_crossings = float(\"inf\")\n\n    for attempt in range(layout_attempts):\n        seed = attempt  # deterministic across runs with same layout_attempts\n        init_pos = make_initial_pos(seed)\n        candidate_pos = nx.spring_layout(\n            G,\n            pos=init_pos,  # warm start near the desired structure\n            fixed=None,  # let everything move, but start well\n            k=0.5,\n            iterations=80,  # more iterations since we have a good warm start\n            weight=\"weight\",\n            seed=seed,\n        )\n        crossings = count_crossings(candidate_pos)\n        if crossings &lt; best_crossings:\n            best_crossings = crossings\n            best_pos = candidate_pos\n\n    pos = best_pos\n\n    fig = plt.figure(figsize=(10, 8))\n\n    instance_nodes = [\n        n for n, d in G.nodes(data=True) if d.get(\"color\") in [\"red\", \"black\"]\n    ]\n    port_nodes = [n for n, d in G.nodes(data=True) if d.get(\"color\") == \"skyblue\"]\n\n    nx.draw_networkx_nodes(\n        G,\n        pos,\n        nodelist=instance_nodes,\n        node_color=[G.nodes[n][\"color\"] for n in instance_nodes],\n        node_size=[G.nodes[n][\"size\"] for n in instance_nodes],\n    )\n\n    nx.draw_networkx_labels(\n        G,\n        pos,\n        labels={n: n for n in instance_nodes},\n        font_color=\"white\",\n        font_weight=\"bold\",\n    )\n\n    nx.draw_networkx_nodes(\n        G, pos, nodelist=port_nodes, node_color=\"skyblue\", node_size=300\n    )\n\n    port_labels = {n: G.nodes[n][\"label\"] for n in port_nodes}\n    nx.draw_networkx_labels(G, pos, labels=port_labels, font_size=8, font_color=\"black\")\n\n    internal_edges = [\n        (u, v) for u, v, d in G.edges(data=True) if d.get(\"type\") == \"internal\"\n    ]\n    nx.draw_networkx_edges(G, pos, edgelist=internal_edges, width=2.0, alpha=0.5)\n\n    external_edges = [\n        (u, v) for u, v, d in G.edges(data=True) if d.get(\"type\") == \"external\"\n    ]\n    nx.draw_networkx_edges(\n        G, pos, edgelist=external_edges, width=1.5, style=\"dashed\", edge_color=\"gray\"\n    )\n\n    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color=\"blue\")\n\n    ax = plt.gca()\n    ax.set_title(\"Circuit Connectivity Graph\")\n    ax.axis(\"off\")\n    fig.tight_layout()\n\n    if show:\n        plt.show()\n\n    return fig\n</code></pre>"},{"location":"references/s_transforms/","title":"S transforms","text":""},{"location":"references/s_transforms/#circulax.s_transforms","title":"s_transforms","text":"<p>Utilities for converting between S-parameters.</p> <p>Utilities for converting between S-parameter and admittance representations, and for wrapping SAX model functions as circulax components.</p> <p>Functions:</p> Name Description <code>s_to_y</code> <p>Convert an S-parameter matrix to an admittance (Y) matrix.</p> <code>sax_component</code> <p>Decorator to convert a SAX model function into a circulax component.</p>"},{"location":"references/s_transforms/#circulax.s_transforms.s_to_y","title":"s_to_y","text":"<pre><code>s_to_y(S: Array, z0: float = 1.0) -&gt; Array\n</code></pre> <p>Convert an S-parameter matrix to an admittance (Y) matrix.</p> <p>Uses the formula <code>Y = (1/z0) * (I - S) * (I + S)^-1</code>. Requires dense matrix inversion; if a component can be defined directly in terms of a Y-matrix it should be, to avoid the overhead of this conversion.</p> <p>Parameters:</p> Name Type Description Default <code>S</code> <code>Array</code> <p>S-parameter matrix of shape <code>(..., n, n)</code>.</p> required <code>z0</code> <code>float</code> <p>Reference impedance in ohms. Defaults to <code>1.0</code>.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>Array</code> <p>Y-matrix of the same shape and dtype as <code>S</code>.</p> Source code in <code>circulax/s_transforms.py</code> <pre><code>@jax.jit\ndef s_to_y(S: jax.Array, z0: float = 1.0) -&gt; jax.Array:\n    \"\"\"Convert an S-parameter matrix to an admittance (Y) matrix.\n\n    Uses the formula ``Y = (1/z0) * (I - S) * (I + S)^-1``. Requires dense\n    matrix inversion; if a component can be defined directly in terms of a\n    Y-matrix it should be, to avoid the overhead of this conversion.\n\n    Args:\n        S: S-parameter matrix of shape ``(..., n, n)``.\n        z0: Reference impedance in ohms. Defaults to ``1.0``.\n\n    Returns:\n        Y-matrix of the same shape and dtype as ``S``.\n\n    \"\"\"\n    n = S.shape[-1]\n    eye = jnp.eye(n, dtype=S.dtype)\n    return (1.0 / z0) * (eye - S) @ jnp.linalg.inv(eye + S)\n</code></pre>"},{"location":"references/s_transforms/#circulax.s_transforms.sax_component","title":"sax_component","text":"<pre><code>sax_component(fn: callable) -&gt; callable\n</code></pre> <p>Decorator to convert a SAX model function into a circulax component.</p> <p>Inspects <code>fn</code> at decoration time to discover its port interface via a dry run, then wraps its S-matrix output in an admittance-based physics function compatible with the circulax nodal solver.</p> <p>The conversion proceeds in three stages:</p> <ol> <li>Discovery \u2014 <code>fn</code> is called once with its default (or dummy)    parameter values and :func:<code>sax.get_ports</code> extracts the sorted port    names from the resulting S-parameter dict.</li> <li>Physics wrapper \u2014 a closure is built that calls <code>fn</code> at runtime,    converts the S-dict to a dense matrix via :func:<code>sax.sdense</code>, converts    it to an admittance matrix via :func:<code>s_to_y</code>, and returns    <code>I = Y @ V</code> as a port current dict.</li> <li>Component registration \u2014 the wrapper is passed to    :func:<code>~circulax.components.base_component.component</code> with the    discovered ports, producing a :class:<code>~circulax.components.base_component.CircuitComponent</code>    subclass.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>callable</code> <p>A SAX model function whose keyword arguments are scalar parameters and whose return value is a SAX S-parameter dict. All parameters must have defaults, or will be substituted with <code>1.0</code> during the dry run.</p> required <p>Returns:</p> Name Type Description <code>A</code> <code>callable</code> <p>class:<code>~circulax.components.base_component.CircuitComponent</code></p> <code>callable</code> <p>subclass named after <code>fn</code>.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the dry run fails for any reason.</p> Source code in <code>circulax/s_transforms.py</code> <pre><code>def sax_component(fn: callable) -&gt; callable:\n    \"\"\"Decorator to convert a SAX model function into a circulax component.\n\n    Inspects ``fn`` at decoration time to discover its port interface via a\n    dry run, then wraps its S-matrix output in an admittance-based physics\n    function compatible with the circulax nodal solver.\n\n    The conversion proceeds in three stages:\n\n    1. **Discovery** \u2014 ``fn`` is called once with its default (or dummy)\n       parameter values and :func:`sax.get_ports` extracts the sorted port\n       names from the resulting S-parameter dict.\n    2. **Physics wrapper** \u2014 a closure is built that calls ``fn`` at runtime,\n       converts the S-dict to a dense matrix via :func:`sax.sdense`, converts\n       it to an admittance matrix via :func:`s_to_y`, and returns\n       ``I = Y @ V`` as a port current dict.\n    3. **Component registration** \u2014 the wrapper is passed to\n       :func:`~circulax.components.base_component.component` with the\n       discovered ports, producing a :class:`~circulax.components.base_component.CircuitComponent`\n       subclass.\n\n    Args:\n        fn: A SAX model function whose keyword arguments are scalar\n            parameters and whose return value is a SAX S-parameter dict.\n            All parameters must have defaults, or will be substituted with\n            ``1.0`` during the dry run.\n\n    Returns:\n        A :class:`~circulax.components.base_component.CircuitComponent`\n        subclass named after ``fn``.\n\n    Raises:\n        RuntimeError: If the dry run fails for any reason.\n\n    \"\"\"\n    sig = inspect.signature(fn)\n    defaults = {\n        param.name: param.default if param.default is not inspect.Parameter.empty else 1.0\n        for param in sig.parameters.values()\n    }\n\n    try:\n        dummy_s_dict = fn(**defaults)\n        detected_ports = get_ports(dummy_s_dict)\n    except Exception as exc:\n        msg = f\"Failed to dry-run SAX component '{fn.__name__}': {exc}\"\n        raise RuntimeError(msg) from exc\n\n    def physics_wrapper(signals: Signals, s: States, **kwargs) -&gt; tuple[dict, dict]:  # noqa: ANN003\n        s_dict = fn(**kwargs)\n        s_matrix, _ = sdense(s_dict)\n        y_matrix = s_to_y(s_matrix)\n        v_vec = jnp.array(\n            [getattr(signals, p) for p in detected_ports], dtype=jnp.complex128\n        )\n        i_vec = y_matrix @ v_vec\n        return {p: i_vec[i] for i, p in enumerate(detected_ports)}, {}\n\n    physics_wrapper.__name__ = fn.__name__\n    physics_wrapper.__doc__ = fn.__doc__\n    physics_wrapper.__signature__ = sig\n\n    return component(ports=detected_ports)(physics_wrapper)\n</code></pre>"},{"location":"references/utils/","title":"Utils","text":""},{"location":"references/utils/#circulax.utils","title":"utils","text":"<p>circulax utilities.</p> <p>Functions:</p> Name Description <code>update_group_params</code> <p>Updates a parameter for ALL instances in a component group.</p> <code>update_params_dict</code> <p>Updates a parameter for a specific instance within a component group.</p>"},{"location":"references/utils/#circulax.utils.update_group_params","title":"update_group_params","text":"<pre><code>update_group_params(\n    groups_dict: dict, group_name: str, param_key: str, new_value: float\n) -&gt; dict[str, ComponentGroup]\n</code></pre> <p>Updates a parameter for ALL instances in a component group.</p> Source code in <code>circulax/utils.py</code> <pre><code>def update_group_params(\n    groups_dict: dict, group_name: str, param_key: str, new_value: float\n) -&gt; dict[str, \"ComponentGroup\"]:\n    \"\"\"Updates a parameter for ALL instances in a component group.\"\"\"\n    g = groups_dict[group_name]\n\n    # Handle Equinox Component (Batched)\n    batched_comp = g.params\n    current_val = getattr(batched_comp, param_key)\n\n    new_vals = jnp.full_like(current_val, new_value)\n\n    new_batched_comp = eqx.tree_at(\n        lambda c: getattr(c, param_key), batched_comp, new_vals\n    )\n    new_g = eqx.tree_at(lambda g: g.params, g, new_batched_comp)\n\n    return {**groups_dict, group_name: new_g}\n</code></pre>"},{"location":"references/utils/#circulax.utils.update_params_dict","title":"update_params_dict","text":"<pre><code>update_params_dict(\n    groups_dict: dict,\n    group_name: str,\n    instance_name: str,\n    param_key: str,\n    new_value: float,\n) -&gt; dict[str, ComponentGroup]\n</code></pre> <p>Updates a parameter for a specific instance within a component group.</p> Source code in <code>circulax/utils.py</code> <pre><code>def update_params_dict(\n    groups_dict: dict,\n    group_name: str,\n    instance_name: str,\n    param_key: str,\n    new_value: float,\n) -&gt; dict[str, \"ComponentGroup\"]:\n    \"\"\"Updates a parameter for a specific instance within a component group.\"\"\"\n    g = groups_dict[group_name]\n\n    instance_idx = g.index_map[instance_name]\n\n    # Handle Equinox Component (Batched)\n    batched_comp = g.params\n    current_val = getattr(batched_comp, param_key)\n    new_vals = current_val.at[instance_idx].set(new_value)\n\n    new_batched_comp = eqx.tree_at(\n        lambda c: getattr(c, param_key), batched_comp, new_vals\n    )\n    new_g = eqx.tree_at(lambda g: g.params, g, new_batched_comp)\n\n    # Return new dict (JAX helper to copy-and-modify dicts)\n    return {**groups_dict, group_name: new_g}\n</code></pre>"},{"location":"references/components/","title":"Index","text":""},{"location":"references/components/#circulax.components","title":"components","text":"<p>Modules:</p> Name Description <code>base_component</code> <p>Base class and decorators for defining JAX-compatible circuit components.</p> <code>electronic</code> <p>Electronic components.</p> <code>photonic</code> <p>Photonic components for optical circuit simulation.</p>"},{"location":"references/components/base_component/","title":"Base component","text":""},{"location":"references/components/base_component/#circulax.components.base_component","title":"base_component","text":"<p>Base class and decorators for defining JAX-compatible circuit components.</p> <p>Circuit components are defined as plain Python functions decorated with :func:<code>component</code> or :func:<code>source</code>, which compile them into :class:<code>CircuitComponent</code> subclasses \u2014 Equinox modules whose parameters are JAX-traceable leaves. The resulting classes expose two entry points:</p> <ul> <li><code>__call__</code> \u2014 a debug-friendly instance method that accepts port voltages   and state values as keyword arguments and returns the physics dicts directly.</li> <li><code>solver_call</code> \u2014 a class method used by the transient solver that operates   on flat JAX arrays and a parameter container, and is compatible with   <code>jax.vmap</code> and <code>jax.jacfwd</code>.</li> </ul> <p>Example::</p> <pre><code>@component(ports=(\"p1\", \"p2\"))\ndef Resistor(signals: Signals, s: States, R: float = 1.0):\n    i = (signals.p1 - signals.p2) / R\n    return {\"p1\": i, \"p2\": -i}, {}\n\nr = Resistor(R=100.0)\nf, q = r(p1=1.0, p2=0.0)\n</code></pre> <p>Classes:</p> Name Description <code>CircuitComponent</code> <p>Base class for all JAX-compatible circuit components.</p> <code>Signals</code> <p>Protocol representing the port voltage signals passed to a component's physics function.</p> <code>States</code> <p>Protocol representing the internal state variables passed to a component's physics function.</p> <p>Functions:</p> Name Description <code>component</code> <p>Decorator for defining a time-independent circuit component.</p> <code>source</code> <p>Decorator for defining a time-dependent circuit component.</p>"},{"location":"references/components/base_component/#circulax.components.base_component.CircuitComponent","title":"CircuitComponent","text":"<p>               Bases: <code>Module</code></p> <p>Base class for all JAX-compatible circuit components.</p> <p>Subclasses are not written by hand \u2014 they are generated at import time by the :func:<code>component</code> and :func:<code>source</code> decorators, which inspect the decorated function's signature to populate the class variables and wire up the two physics entry points.</p> Class Variables <p>ports: Ordered tuple of port names, e.g. <code>(\"p1\", \"p2\")</code>. states: Ordered tuple of internal state variable names,     e.g. <code>(\"i_L\",)</code>. Empty for purely algebraic components. _uses_time: <code>True</code> for components decorated with :func:<code>source</code>     whose physics function accepts a <code>t</code> argument. _VarsType_P: Namedtuple type for unpacking port voltages from a     flat array. <code>None</code> if the component has no ports. _VarsType_S: Namedtuple type for unpacking state variables from a     flat array. <code>None</code> if the component has no states. _n_ports: Number of ports, cached to avoid repeated <code>len</code> calls     in the hot path. _fast_physics: Static closure over the user-defined physics function,     compatible with <code>jax.vmap</code> and <code>jax.jacfwd</code>. Signature is     <code>(vars_vec, params, t) -&gt; (f_vec, q_vec)</code>.</p> <p>Methods:</p> Name Description <code>physics</code> <p>Raw physics dispatch; overridden by the decorator-generated subclass.</p> <code>solver_call</code> <p>Evaluate the component physics (solver entry point).</p>"},{"location":"references/components/base_component/#circulax.components.base_component.CircuitComponent.physics","title":"physics","text":"<pre><code>physics(*args: Any, **kwargs: Any) -&gt; tuple[dict, dict]\n</code></pre> <p>Raw physics dispatch; overridden by the decorator-generated subclass.</p> Source code in <code>circulax/components/base_component.py</code> <pre><code>def physics(self, *args: Any, **kwargs: Any) -&gt; tuple[dict, dict]:\n    \"\"\"Raw physics dispatch; overridden by the decorator-generated subclass.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"references/components/base_component/#circulax.components.base_component.CircuitComponent.solver_call","title":"solver_call  <code>classmethod</code>","text":"<pre><code>solver_call(t: float, y: Array, args: Any) -&gt; tuple[Array, Array]\n</code></pre> <p>Evaluate the component physics (solver entry point).</p> <p>Thin wrapper around the static <code>_fast_physics</code> closure. Called by the transient solver inside <code>jax.vmap</code> across all instances in a component group, and differentiated via <code>jax.jacfwd</code> to assemble the system Jacobian.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Current simulation time.</p> required <code>y</code> <code>Array</code> <p>Flat state vector of shape <code>(n_ports + n_states,)</code> containing port voltages followed by state variable values.</p> required <code>args</code> <code>Any</code> <p>Parameter container for this instance. May be a dict <code>{\"R\": 100.0}</code> or an object (e.g. the component instance itself) whose attributes match the parameter names. Must not be a raw scalar.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>A two-tuple <code>(f_vec, q_vec)</code> of JAX arrays, each of shape</p> <code>Array</code> <p><code>(n_ports + n_states,)</code>, containing the resistive and reactive</p> <code>tuple[Array, Array]</code> <p>contributions for every port and state variable.</p> Source code in <code>circulax/components/base_component.py</code> <pre><code>@classmethod\ndef solver_call(\n    cls,\n    t: float,\n    y: jax.Array,\n    args: Any,\n) -&gt; tuple[jax.Array, jax.Array]:\n    \"\"\"Evaluate the component physics (solver entry point).\n\n    Thin wrapper around the static ``_fast_physics`` closure. Called by\n    the transient solver inside ``jax.vmap`` across all instances in a\n    component group, and differentiated via ``jax.jacfwd`` to assemble\n    the system Jacobian.\n\n    Args:\n        t: Current simulation time.\n        y: Flat state vector of shape ``(n_ports + n_states,)`` containing\n            port voltages followed by state variable values.\n        args: Parameter container for this instance. May be a dict\n            ``{\"R\": 100.0}`` or an object (e.g. the component instance\n            itself) whose attributes match the parameter names. Must not\n            be a raw scalar.\n\n    Returns:\n        A two-tuple ``(f_vec, q_vec)`` of JAX arrays, each of shape\n        ``(n_ports + n_states,)``, containing the resistive and reactive\n        contributions for every port and state variable.\n\n    \"\"\"\n    return cls._fast_physics(y, args, t)\n</code></pre>"},{"location":"references/components/base_component/#circulax.components.base_component.Signals","title":"Signals","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol representing the port voltage signals passed to a component's physics function.</p> <p>Attributes are accessed by port name (e.g. <code>signals.p1</code>), backed by a namedtuple constructed from the component's <code>ports</code> declaration.</p>"},{"location":"references/components/base_component/#circulax.components.base_component.States","title":"States","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol representing the internal state variables passed to a component's physics function.</p> <p>Attributes are accessed by state name (e.g. <code>s.i_L</code>), backed by a namedtuple constructed from the component's <code>states</code> declaration.</p>"},{"location":"references/components/base_component/#circulax.components.base_component.component","title":"component","text":"<pre><code>component(ports: tuple[str, ...] = (), states: tuple[str, ...] = ()) -&gt; Any\n</code></pre> <p>Decorator for defining a time-independent circuit component.</p> <p>Compiles the decorated physics function into a :class:<code>CircuitComponent</code> subclass. The function must begin with <code>(signals, s)</code> followed by any number of parameters with defaults, which become JAX-traceable Equinox fields on the resulting class.</p> <p>Parameters:</p> Name Type Description Default <code>ports</code> <code>tuple[str, ...]</code> <p>Ordered tuple of port names. Must match the connection keys used in the netlist.</p> <code>()</code> <code>states</code> <code>tuple[str, ...]</code> <p>Ordered tuple of internal state variable names. State variables are appended to the solver's state vector after the node voltages.</p> <code>()</code> <p>Returns:</p> Type Description <code>Any</code> <p>A decorator that accepts a physics function and returns a</p> <code>Any</code> <p>class:<code>CircuitComponent</code> subclass.</p> <p>Example::</p> <pre><code>@component(ports=(\"p1\", \"p2\"))\ndef Resistor(signals: Signals, s: States, R: float = 1.0):\n    i = (signals.p1 - signals.p2) / R\n    return {\"p1\": i, \"p2\": -i}, {}\n</code></pre> Source code in <code>circulax/components/base_component.py</code> <pre><code>def component(\n    ports: tuple[str, ...] = (),\n    states: tuple[str, ...] = (),\n) -&gt; Any:\n    \"\"\"Decorator for defining a time-independent circuit component.\n\n    Compiles the decorated physics function into a :class:`CircuitComponent`\n    subclass. The function must begin with ``(signals, s)`` followed by any\n    number of parameters with defaults, which become JAX-traceable Equinox\n    fields on the resulting class.\n\n    Args:\n        ports: Ordered tuple of port names. Must match the connection keys\n            used in the netlist.\n        states: Ordered tuple of internal state variable names. State\n            variables are appended to the solver's state vector after the\n            node voltages.\n\n    Returns:\n        A decorator that accepts a physics function and returns a\n        :class:`CircuitComponent` subclass.\n\n    Example::\n\n        @component(ports=(\"p1\", \"p2\"))\n        def Resistor(signals: Signals, s: States, R: float = 1.0):\n            i = (signals.p1 - signals.p2) / R\n            return {\"p1\": i, \"p2\": -i}, {}\n\n    \"\"\"\n    return lambda fn: _build_component(fn, ports, states, uses_time=False)\n</code></pre>"},{"location":"references/components/base_component/#circulax.components.base_component.source","title":"source","text":"<pre><code>source(ports: tuple[str, ...] = (), states: tuple[str, ...] = ()) -&gt; Any\n</code></pre> <p>Decorator for defining a time-dependent circuit component.</p> <p>Identical to :func:<code>component</code> except the decorated physics function must accept <code>t</code> as its third argument (after <code>signals</code> and <code>s</code>), and may use it to implement time-varying behaviour such as sinusoidal sources or delayed step functions.</p> <p>Parameters:</p> Name Type Description Default <code>ports</code> <code>tuple[str, ...]</code> <p>Ordered tuple of port names.</p> <code>()</code> <code>states</code> <code>tuple[str, ...]</code> <p>Ordered tuple of internal state variable names.</p> <code>()</code> <p>Returns:</p> Type Description <code>Any</code> <p>A decorator that accepts a physics function and returns a</p> <code>Any</code> <p>class:<code>CircuitComponent</code> subclass.</p> <p>Example::</p> <pre><code>@source(ports=(\"p1\", \"p2\"), states=(\"i_src\",))\ndef VoltageSource(signals: Signals, s: States, t: float, V: float = 1.0):\n    constraint = (signals.p1 - signals.p2) - V\n    return {\"p1\": s.i_src, \"p2\": -s.i_src, \"i_src\": constraint}, {}\n</code></pre> Source code in <code>circulax/components/base_component.py</code> <pre><code>def source(\n    ports: tuple[str, ...] = (),\n    states: tuple[str, ...] = (),\n) -&gt; Any:\n    \"\"\"Decorator for defining a time-dependent circuit component.\n\n    Identical to :func:`component` except the decorated physics function\n    must accept ``t`` as its third argument (after ``signals`` and ``s``),\n    and may use it to implement time-varying behaviour such as sinusoidal\n    sources or delayed step functions.\n\n    Args:\n        ports: Ordered tuple of port names.\n        states: Ordered tuple of internal state variable names.\n\n    Returns:\n        A decorator that accepts a physics function and returns a\n        :class:`CircuitComponent` subclass.\n\n    Example::\n\n        @source(ports=(\"p1\", \"p2\"), states=(\"i_src\",))\n        def VoltageSource(signals: Signals, s: States, t: float, V: float = 1.0):\n            constraint = (signals.p1 - signals.p2) - V\n            return {\"p1\": s.i_src, \"p2\": -s.i_src, \"i_src\": constraint}, {}\n\n    \"\"\"\n    return lambda fn: _build_component(fn, ports, states, uses_time=True)\n</code></pre>"},{"location":"references/components/electronic/","title":"Electronic","text":""},{"location":"references/components/electronic/#circulax.components.electronic","title":"electronic","text":"<p>Electronic components.</p> <p>Functions:</p> Name Description <code>BJT_NPN</code> <p>NPN BJT using the transport form of the Ebers-Moll DC model.</p> <code>BJT_NPN_Dynamic</code> <p>NPN BJT with the Ebers-Moll DC model and first-order junction charge dynamics.</p> <code>CCCS</code> <p>Current Controlled Current Source (Current Gain).</p> <code>CCVS</code> <p>Current Controlled Voltage Source (Transresistance).</p> <code>Capacitor</code> <p>Q = C * V.</p> <code>CurrentSource</code> <p>Constant current source.</p> <code>Diode</code> <p>Ideal diode using the Shockley equation <code>I = Is * (exp(Vd / n*Vt) - 1)</code>.</p> <code>IdealOpAmp</code> <p>Ideal Op Amp.</p> <code>Inductor</code> <p>V = L * di/dt  -&gt;  di_L/dt = V / L.</p> <code>NMOS</code> <p>N-channel MOSFET with square-law DC model and channel-length modulation.</p> <code>NMOSDynamic</code> <p>NMOS with square-law DC model and Meyer gate capacitance model.</p> <code>PMOS</code> <p>P-channel MOSFET with square-law DC model, formulated in terms of <code>Vsg</code> and <code>Vsd</code>.</p> <code>Resistor</code> <p>Ohm's Law: I = V/R.</p> <code>SmoothPulse</code> <p>Sigmoid-smoothed pulse.</p> <code>VCCS</code> <p>Voltage Controlled Current Source.</p> <code>VCVS</code> <p>Voltage Controlled Voltage Source.</p> <code>VoltageControlledSwitch</code> <p>Voltage Controlled Switch.</p> <code>VoltageSource</code> <p>Step voltage source.</p> <code>VoltageSourceAC</code> <p>Sinusoidal voltage source.</p> <code>ZenerDiode</code> <p>Zener diode with forward Shockley conduction and reverse breakdown.</p>"},{"location":"references/components/electronic/#circulax.components.electronic.BJT_NPN","title":"BJT_NPN","text":"<pre><code>BJT_NPN(\n    signals: Signals,\n    s: States,\n    Is: float = 1e-12,\n    BetaF: float = 100.0,\n    BetaR: float = 1.0,\n    Vt: float = 0.02585,\n) -&gt; PhysicsReturn\n</code></pre> <p>NPN BJT using the transport form of the Ebers-Moll DC model.</p> <p>Junction voltages are clipped to <code>[-5, 2]</code> V before exponentiation. For transient simulations with junction charge dynamics use :func:<code>BJT_NPN_Dynamic</code> instead.</p> <p>Parameters:</p> Name Type Description Default <code>signals</code> <code>Signals</code> <p>Port voltages at collector (<code>c</code>), base (<code>b</code>), and emitter (<code>e</code>).</p> required <code>s</code> <code>States</code> <p>Unused.</p> required <code>Is</code> <code>float</code> <p>Saturation current in amperes. Defaults to <code>1e-12</code>.</p> <code>1e-12</code> <code>BetaF</code> <code>float</code> <p>Forward common-emitter current gain. Defaults to <code>100</code>.</p> <code>100.0</code> <code>BetaR</code> <code>float</code> <p>Reverse common-emitter current gain. Defaults to <code>1</code>.</p> <code>1.0</code> <code>Vt</code> <code>float</code> <p>Thermal voltage in volts. Defaults to <code>25.85e-3</code>.</p> <code>0.02585</code> Source code in <code>circulax/components/electronic.py</code> <pre><code>@component(ports=(\"c\", \"b\", \"e\"))\ndef BJT_NPN(\n    signals: Signals,\n    s: States,\n    Is: float = 1e-12,\n    BetaF: float = 100.0,\n    BetaR: float = 1.0,\n    Vt: float = 25.85e-3,\n) -&gt; PhysicsReturn:\n    \"\"\"NPN BJT using the transport form of the Ebers-Moll DC model.\n\n    Junction voltages are clipped to ``[-5, 2]`` V before exponentiation.\n    For transient simulations with junction charge dynamics use\n    :func:`BJT_NPN_Dynamic` instead.\n\n    Args:\n        signals: Port voltages at collector (``c``), base (``b``), and emitter (``e``).\n        s: Unused.\n        Is: Saturation current in amperes. Defaults to ``1e-12``.\n        BetaF: Forward common-emitter current gain. Defaults to ``100``.\n        BetaR: Reverse common-emitter current gain. Defaults to ``1``.\n        Vt: Thermal voltage in volts. Defaults to ``25.85e-3``.\n\n    \"\"\"\n    vbe = signals.b - signals.e\n    vbc = signals.b - signals.c\n\n    alpha_f = BetaF / (1.0 + BetaF)\n    alpha_r = BetaR / (1.0 + BetaR)\n\n    vbe_safe = jnp.clip(vbe, -5.0, 2.0)\n    vbc_safe = jnp.clip(vbc, -5.0, 2.0)\n\n    i_f = Is * (jnp.exp(vbe_safe / Vt) - 1.0)\n    i_r = Is * (jnp.exp(vbc_safe / Vt) - 1.0)\n\n    i_c = alpha_f * i_f - i_r\n    i_e = -i_f + alpha_r * i_r\n    i_b = -(i_c + i_e)\n\n    return {\"c\": i_c, \"b\": i_b, \"e\": i_e}, {}\n</code></pre>"},{"location":"references/components/electronic/#circulax.components.electronic.BJT_NPN_Dynamic","title":"BJT_NPN_Dynamic","text":"<pre><code>BJT_NPN_Dynamic(\n    signals: Signals,\n    s: States,\n    Is: float = 1e-12,\n    BetaF: float = 100.0,\n    BetaR: float = 1.0,\n    Vt: float = 0.02585,\n    Cje: float = 1e-12,\n    Cjc: float = 1e-12,\n    Vje: float = 0.75,\n    Vjc: float = 0.75,\n    Mje: float = 0.33,\n    Mjc: float = 0.33,\n    Tf: float = 0.0,\n    Tr: float = 0.0,\n) -&gt; PhysicsReturn\n</code></pre> <p>NPN BJT with the Ebers-Moll DC model and first-order junction charge dynamics.</p> <p>DC currents follow the transport form of the Ebers-Moll equations. Junction voltages are clipped to <code>[-5, 2]</code> V before exponentiation to prevent overflow during transient solver iterations.</p> <p>Charge dynamics combine two contributions at each junction:</p> <ul> <li>Depletion charge \u2014 modelled as a nonlinear junction capacitance via   :func:<code>_junction_charge</code>, using the standard abrupt/graded junction   formula with ideality parameters <code>Vj</code> and <code>Mj</code>.</li> <li>Diffusion charge \u2014 proportional to the junction current scaled by the   transit time (<code>Tf</code> for BE, <code>Tr</code> for BC``), representing minority   carrier storage in the base.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>signals</code> <code>Signals</code> <p>Port voltages at collector (<code>c</code>), base (<code>b</code>), and emitter (<code>e</code>).</p> required <code>s</code> <code>States</code> <p>Unused; present to satisfy the component protocol.</p> required <code>Is</code> <code>float</code> <p>Saturation current in amperes. Defaults to <code>1e-12</code>.</p> <code>1e-12</code> <code>BetaF</code> <code>float</code> <p>Forward common-emitter current gain. Defaults to <code>100</code>.</p> <code>100.0</code> <code>BetaR</code> <code>float</code> <p>Reverse common-emitter current gain. Defaults to <code>1</code>.</p> <code>1.0</code> <code>Vt</code> <code>float</code> <p>Thermal voltage in volts. Defaults to <code>25.85e-3</code> (room temperature).</p> <code>0.02585</code> <code>Cje</code> <code>float</code> <p>Zero-bias BE junction capacitance in farads. Defaults to <code>1e-12</code>.</p> <code>1e-12</code> <code>Cjc</code> <code>float</code> <p>Zero-bias BC junction capacitance in farads. Defaults to <code>1e-12</code>.</p> <code>1e-12</code> <code>Vje</code> <code>float</code> <p>BE built-in junction potential in volts. Defaults to <code>0.75</code>.</p> <code>0.75</code> <code>Vjc</code> <code>float</code> <p>BC built-in junction potential in volts. Defaults to <code>0.75</code>.</p> <code>0.75</code> <code>Mje</code> <code>float</code> <p>BE junction grading coefficient. Defaults to <code>0.33</code>.</p> <code>0.33</code> <code>Mjc</code> <code>float</code> <p>BC junction grading coefficient. Defaults to <code>0.33</code>.</p> <code>0.33</code> <code>Tf</code> <code>float</code> <p>Forward transit time in seconds. Defaults to <code>0</code> (no BE diffusion charge).</p> <code>0.0</code> <code>Tr</code> <code>float</code> <p>Reverse transit time in seconds. Defaults to <code>0</code> (no BC diffusion charge).</p> <code>0.0</code> <p>Returns:</p> Type Description <code>PhysicsReturn</code> <p>A two-tuple <code>(f, q)</code> where:</p> <code>PhysicsReturn</code> <ul> <li>f \u2014 DC current dict <code>{\"c\": i_c, \"b\": i_b, \"e\": i_e}</code>.</li> </ul> <code>PhysicsReturn</code> <ul> <li>q \u2014 Junction charge dict <code>{\"c\": Q_collector, \"b\": Q_base, \"e\": Q_emitter}</code>, where <code>Q_base = Q_be_total + Q_bc_total</code>, <code>Q_collector = -Q_bc_total</code>, and <code>Q_emitter = -Q_be_total</code>.</li> </ul> Source code in <code>circulax/components/electronic.py</code> <pre><code>@component(ports=(\"c\", \"b\", \"e\"))\ndef BJT_NPN_Dynamic(\n    signals: Signals,\n    s: States,\n    Is: float = 1e-12,\n    BetaF: float = 100.0,\n    BetaR: float = 1.0,\n    Vt: float = 25.85e-3,\n    Cje: float = 1e-12,\n    Cjc: float = 1e-12,\n    Vje: float = 0.75,\n    Vjc: float = 0.75,\n    Mje: float = 0.33,\n    Mjc: float = 0.33,\n    Tf: float = 0.0,\n    Tr: float = 0.0,\n) -&gt; PhysicsReturn:\n    \"\"\"NPN BJT with the Ebers-Moll DC model and first-order junction charge dynamics.\n\n    DC currents follow the transport form of the Ebers-Moll equations. Junction\n    voltages are clipped to ``[-5, 2]`` V before exponentiation to prevent\n    overflow during transient solver iterations.\n\n    Charge dynamics combine two contributions at each junction:\n\n    - **Depletion charge** \u2014 modelled as a nonlinear junction capacitance via\n      :func:`_junction_charge`, using the standard abrupt/graded junction\n      formula with ideality parameters ``Vj`` and ``Mj``.\n    - **Diffusion charge** \u2014 proportional to the junction current scaled by the\n      transit time (``Tf`` for BE, ``Tr`` for BC``), representing minority\n      carrier storage in the base.\n\n    Args:\n        signals: Port voltages at collector (``c``), base (``b``), and\n            emitter (``e``).\n        s: Unused; present to satisfy the component protocol.\n        Is: Saturation current in amperes. Defaults to ``1e-12``.\n        BetaF: Forward common-emitter current gain. Defaults to ``100``.\n        BetaR: Reverse common-emitter current gain. Defaults to ``1``.\n        Vt: Thermal voltage in volts. Defaults to ``25.85e-3`` (room temperature).\n        Cje: Zero-bias BE junction capacitance in farads. Defaults to ``1e-12``.\n        Cjc: Zero-bias BC junction capacitance in farads. Defaults to ``1e-12``.\n        Vje: BE built-in junction potential in volts. Defaults to ``0.75``.\n        Vjc: BC built-in junction potential in volts. Defaults to ``0.75``.\n        Mje: BE junction grading coefficient. Defaults to ``0.33``.\n        Mjc: BC junction grading coefficient. Defaults to ``0.33``.\n        Tf: Forward transit time in seconds. Defaults to ``0`` (no BE diffusion charge).\n        Tr: Reverse transit time in seconds. Defaults to ``0`` (no BC diffusion charge).\n\n    Returns:\n        A two-tuple ``(f, q)`` where:\n\n        - **f** \u2014 DC current dict ``{\"c\": i_c, \"b\": i_b, \"e\": i_e}``.\n        - **q** \u2014 Junction charge dict ``{\"c\": Q_collector, \"b\": Q_base, \"e\": Q_emitter}``,\n            where ``Q_base = Q_be_total + Q_bc_total``, ``Q_collector = -Q_bc_total``,\n            and ``Q_emitter = -Q_be_total``.\n\n    \"\"\"\n    vbe = signals.b - signals.e\n    vbc = signals.b - signals.c\n\n    vbe_safe = jnp.clip(vbe, -5.0, 2.0)\n    vbc_safe = jnp.clip(vbc, -5.0, 2.0)\n\n    alpha_f = BetaF / (1.0 + BetaF)\n    alpha_r = BetaR / (1.0 + BetaR)\n\n    i_f = Is * (jnp.exp(vbe_safe / Vt) - 1.0)\n    i_r = Is * (jnp.exp(vbc_safe / Vt) - 1.0)\n\n    i_c = alpha_f * i_f - i_r\n    i_e = -i_f + alpha_r * i_r\n    i_b = -(i_c + i_e)\n\n    f_dict = {\"c\": i_c, \"b\": i_b, \"e\": i_e}\n\n    # 2. Dynamic Charges (Diffusion + Depletion)\n    Qje_depl = _junction_charge(vbe, Cje, Vje, Mje)\n    Qjc_depl = _junction_charge(vbc, Cjc, Vjc, Mjc)\n\n    Qbe_diff = Tf * i_f\n    Qbc_diff = Tr * i_r\n\n    Q_be_total = Qje_depl + Qbe_diff\n    Q_bc_total = Qjc_depl + Qbc_diff\n\n    Q_base = Q_be_total + Q_bc_total\n    Q_collector = -Q_bc_total\n    Q_emitter = -Q_be_total\n\n    return f_dict, {\"c\": Q_collector, \"b\": Q_base, \"e\": Q_emitter}\n</code></pre>"},{"location":"references/components/electronic/#circulax.components.electronic.CCCS","title":"CCCS","text":"<pre><code>CCCS(signals: Signals, s: States, alpha: float = 1.0) -&gt; PhysicsReturn\n</code></pre> <p>Current Controlled Current Source (Current Gain).</p> <p>Physics: 1. Input side (in_p, in_m) acts as a short circuit to measure 'i_ctrl'. 2. Output side pushes current I_out = alpha * i_ctrl.</p> Source code in <code>circulax/components/electronic.py</code> <pre><code>@component(ports=(\"out_p\", \"out_m\", \"in_p\", \"in_m\"), states=(\"i_ctrl\",))\ndef CCCS(signals: Signals, s: States, alpha: float = 1.0) -&gt; PhysicsReturn:\n    \"\"\"Current Controlled Current Source (Current Gain).\n\n    Physics:\n    1. Input side (in_p, in_m) acts as a short circuit to measure 'i_ctrl'.\n    2. Output side pushes current I_out = alpha * i_ctrl.\n    \"\"\"\n    # 1. Input Constraint: Short Circuit\n    eq_in = signals.in_p - signals.in_m\n\n    # 2. Output Current Calculation\n    i_out = alpha * s.i_ctrl\n\n    return {\n        # Output side flow (Direct current injection)\n        \"out_p\": i_out,\n        \"out_m\": -i_out,\n        # Input side flow (Short circuit current path)\n        \"in_p\": s.i_ctrl,\n        \"in_m\": -s.i_ctrl,\n        # Equation for the state variable\n        \"i_ctrl\": eq_in,  # Enforce V_in = 0\n    }, {}\n</code></pre>"},{"location":"references/components/electronic/#circulax.components.electronic.CCVS","title":"CCVS","text":"<pre><code>CCVS(signals: Signals, s: States, R: float = 1.0) -&gt; PhysicsReturn\n</code></pre> <p>Current Controlled Voltage Source (Transresistance).</p> <p>Physics: 1. Input side (in_p, in_m) acts as a short circuit (0V drop) to measure current 'i_ctrl'. 2. Output side (out_p, out_m) acts as a voltage source V = R * i_ctrl.</p> Source code in <code>circulax/components/electronic.py</code> <pre><code>@component(ports=(\"out_p\", \"out_m\", \"in_p\", \"in_m\"), states=(\"i_src\", \"i_ctrl\"))\ndef CCVS(signals: Signals, s: States, R: float = 1.0) -&gt; PhysicsReturn:\n    \"\"\"Current Controlled Voltage Source (Transresistance).\n\n    Physics:\n    1. Input side (in_p, in_m) acts as a short circuit (0V drop) to measure current 'i_ctrl'.\n    2. Output side (out_p, out_m) acts as a voltage source V = R * i_ctrl.\n    \"\"\"\n    # 1. Input Constraint: Short Circuit (v_in = 0)\n    #    The variable 'i_ctrl' is the current flowing through this short.\n    eq_in = signals.in_p - signals.in_m\n\n    # 2. Output Constraint: Voltage Source (v_out - R*i_in = 0)\n    #    The variable 'i_src' is the current delivered by this source.\n    eq_out = (signals.out_p - signals.out_m) - (R * s.i_ctrl)\n\n    return {\n        # Output side flow (standard voltage source behavior)\n        \"out_p\": s.i_src,\n        \"out_m\": -s.i_src,\n        # Input side flow (current 'i_ctrl' enters in_p, leaves in_m)\n        \"in_p\": s.i_ctrl,\n        \"in_m\": -s.i_ctrl,\n        # Equations for the state variables\n        \"i_src\": eq_out,  # Enforce V_out = R * I_in\n        \"i_ctrl\": eq_in,  # Enforce V_in = 0\n    }, {}\n</code></pre>"},{"location":"references/components/electronic/#circulax.components.electronic.Capacitor","title":"Capacitor","text":"<pre><code>Capacitor(signals: Signals, s: States, C: float = 1e-12) -&gt; PhysicsReturn\n</code></pre> <p>Q = C * V. Returns Charge (q) so the solver computes I = dq/dt.</p> Source code in <code>circulax/components/electronic.py</code> <pre><code>@component(ports=(\"p1\", \"p2\"))\ndef Capacitor(signals: Signals, s: States, C: float = 1e-12) -&gt; PhysicsReturn:\n    \"\"\"Q = C * V.\n    Returns Charge (q) so the solver computes I = dq/dt.\n    \"\"\"  # noqa: D205\n    v_drop = signals.p1 - signals.p2\n    q_val = C * v_drop\n    return {}, {\"p1\": q_val, \"p2\": -q_val}\n</code></pre>"},{"location":"references/components/electronic/#circulax.components.electronic.CurrentSource","title":"CurrentSource","text":"<pre><code>CurrentSource(signals: Signals, s: States, I: float = 0.0) -&gt; PhysicsReturn\n</code></pre> <p>Constant current source.</p> Source code in <code>circulax/components/electronic.py</code> <pre><code>@component(ports=(\"p1\", \"p2\"))\ndef CurrentSource(signals: Signals, s: States, I: float = 0.0) -&gt; PhysicsReturn:\n    \"\"\"Constant current source.\"\"\"\n    return {\"p1\": I, \"p2\": -I}, {}\n</code></pre>"},{"location":"references/components/electronic/#circulax.components.electronic.Diode","title":"Diode","text":"<pre><code>Diode(\n    signals: Signals, s: States, Is: float = 1e-12, n: float = 1.0, Vt: float = 0.02585\n) -&gt; PhysicsReturn\n</code></pre> <p>Ideal diode using the Shockley equation <code>I = Is * (exp(Vd / n*Vt) - 1)</code>.</p> <p>Junction voltage is clipped to <code>[-5, 5]</code> V for numerical stability.</p> <p>Parameters:</p> Name Type Description Default <code>signals</code> <code>Signals</code> <p>Port voltages at anode (<code>p1</code>) and cathode (<code>p2</code>).</p> required <code>s</code> <code>States</code> <p>Unused.</p> required <code>Is</code> <code>float</code> <p>Saturation current in amperes. Defaults to <code>1e-12</code>.</p> <code>1e-12</code> <code>n</code> <code>float</code> <p>Ideality factor. Defaults to <code>1.0</code>.</p> <code>1.0</code> <code>Vt</code> <code>float</code> <p>Thermal voltage in volts. Defaults to <code>25.85e-3</code>.</p> <code>0.02585</code> Source code in <code>circulax/components/electronic.py</code> <pre><code>@component(ports=(\"p1\", \"p2\"))\ndef Diode(\n    signals: Signals, s: States, Is: float = 1e-12, n: float = 1.0, Vt: float = 25.85e-3\n) -&gt; PhysicsReturn:\n    \"\"\"Ideal diode using the Shockley equation ``I = Is * (exp(Vd / n*Vt) - 1)``.\n\n    Junction voltage is clipped to ``[-5, 5]`` V for numerical stability.\n\n    Args:\n        signals: Port voltages at anode (``p1``) and cathode (``p2``).\n        s: Unused.\n        Is: Saturation current in amperes. Defaults to ``1e-12``.\n        n: Ideality factor. Defaults to ``1.0``.\n        Vt: Thermal voltage in volts. Defaults to ``25.85e-3``.\n\n    \"\"\"\n    vd = signals.p1 - signals.p2\n    # Clip for numerical stability\n    vd_safe = jnp.clip(vd, -5.0, 5.0)\n    i = Is * (jnp.exp(vd_safe / (n * Vt)) - 1.0)\n    return {\"p1\": i, \"p2\": -i}, {}\n</code></pre>"},{"location":"references/components/electronic/#circulax.components.electronic.IdealOpAmp","title":"IdealOpAmp","text":"<pre><code>IdealOpAmp(signals: Signals, s: States, A: float = 1000000.0) -&gt; PhysicsReturn\n</code></pre> <p>Ideal Op Amp.</p> Source code in <code>circulax/components/electronic.py</code> <pre><code>@component(ports=(\"out_p\", \"out_m\", \"in_p\", \"in_m\"), states=(\"i_src\",))\ndef IdealOpAmp(signals: Signals, s: States, A: float = 1e6) -&gt; PhysicsReturn:\n    \"\"\"Ideal Op Amp.\"\"\"\n    constraint = (signals.out_p - signals.out_m) - A * (signals.in_p - signals.in_m)\n    return {\n        \"out_p\": s.i_src,\n        \"out_m\": -s.i_src,\n        \"in_p\": 0.0,\n        \"in_m\": 0.0,\n        \"i_src\": constraint,\n    }, {}\n</code></pre>"},{"location":"references/components/electronic/#circulax.components.electronic.Inductor","title":"Inductor","text":"<pre><code>Inductor(signals: Signals, s: States, L: float = 1e-09) -&gt; PhysicsReturn\n</code></pre> <p>V = L * di/dt  -&gt;  di_L/dt = V / L.</p> <p>We treat Flux (phi) = L * i_L.</p> Source code in <code>circulax/components/electronic.py</code> <pre><code>@component(ports=(\"p1\", \"p2\"), states=(\"i_L\",))\ndef Inductor(signals: Signals, s: States, L: float = 1e-9) -&gt; PhysicsReturn:\n    \"\"\"V = L * di/dt  -&gt;  di_L/dt = V / L.\n\n    We treat Flux (phi) = L * i_L.\n    \"\"\"\n    v_drop = signals.p1 - signals.p2\n    # Flow: Current i_L flows p1 -&gt; p2.\n    # State Eq: i_L is the variable. We constrain its derivative via flux.\n    # However, standard modified nodal analysis often writes:\n    #   p1: i_L\n    #   p2: -i_L\n    #   branch: v1 - v2 - L*di/dt = 0\n    #\n    # In this (f, q) formulation:\n    # f['i_L'] = v1 - v2 (Force / Potential)\n    # q['i_L'] = -L * i_L (Momentum / Flux)\n    # Result: (v1-v2) - d/dt(L*i_L) = 0  =&gt; v = L di/dt\n    return ({\"p1\": s.i_L, \"p2\": -s.i_L, \"i_L\": v_drop}, {\"i_L\": -L * s.i_L})\n</code></pre>"},{"location":"references/components/electronic/#circulax.components.electronic.NMOS","title":"NMOS","text":"<pre><code>NMOS(\n    signals: Signals,\n    s: States,\n    Kp: float = 2e-05,\n    W: float = 1e-05,\n    L: float = 1e-06,\n    Vth: float = 1.0,\n    lam: float = 0.0,\n) -&gt; PhysicsReturn\n</code></pre> <p>N-channel MOSFET with square-law DC model and channel-length modulation.</p> <p>Gate current is zero (infinite input impedance).</p> <p>Parameters:</p> Name Type Description Default <code>signals</code> <code>Signals</code> <p>Port voltages at drain (<code>d</code>), gate (<code>g</code>), and source (<code>s</code>).</p> required <code>s</code> <code>States</code> <p>Unused.</p> required <code>Kp</code> <code>float</code> <p>Process transconductance parameter in A/V\u00b2. Defaults to <code>2e-5</code>.</p> <code>2e-05</code> <code>W</code> <code>float</code> <p>Gate width in metres. Defaults to <code>10e-6</code>.</p> <code>1e-05</code> <code>L</code> <code>float</code> <p>Gate length in metres. Defaults to <code>1e-6</code>.</p> <code>1e-06</code> <code>Vth</code> <code>float</code> <p>Threshold voltage in volts. Defaults to <code>1.0</code>.</p> <code>1.0</code> <code>lam</code> <code>float</code> <p>Channel-length modulation coefficient in V\u207b\u00b9. Defaults to <code>0</code>.</p> <code>0.0</code> Source code in <code>circulax/components/electronic.py</code> <pre><code>@component(ports=(\"d\", \"g\", \"s\"))\ndef NMOS(\n    signals: Signals,\n    s: States,\n    Kp: float = 2e-5,\n    W: float = 10e-6,\n    L: float = 1e-6,\n    Vth: float = 1.0,\n    lam: float = 0.0,\n) -&gt; PhysicsReturn:\n    \"\"\"N-channel MOSFET with square-law DC model and channel-length modulation.\n\n    Gate current is zero (infinite input impedance).\n\n    Args:\n        signals: Port voltages at drain (``d``), gate (``g``), and source (``s``).\n        s: Unused.\n        Kp: Process transconductance parameter in A/V\u00b2. Defaults to ``2e-5``.\n        W: Gate width in metres. Defaults to ``10e-6``.\n        L: Gate length in metres. Defaults to ``1e-6``.\n        Vth: Threshold voltage in volts. Defaults to ``1.0``.\n        lam: Channel-length modulation coefficient in V\u207b\u00b9. Defaults to ``0``.\n\n    \"\"\"\n    i_ds = _nmos_current(signals.d, signals.g, signals.s, Kp, W, L, Vth, lam)\n    return {\"d\": i_ds, \"g\": 0.0, \"s\": -i_ds}, {}\n</code></pre>"},{"location":"references/components/electronic/#circulax.components.electronic.NMOSDynamic","title":"NMOSDynamic","text":"<pre><code>NMOSDynamic(\n    signals: Signals,\n    s: States,\n    Kp: float = 2e-05,\n    W: float = 1e-05,\n    L: float = 1e-06,\n    Vth: float = 1.0,\n    lam: float = 0.0,\n    Cox: float = 0.001,\n    Cgd_ov: float = 1e-15,\n    Cgs_ov: float = 1e-15,\n) -&gt; PhysicsReturn\n</code></pre> <p>NMOS with square-law DC model and Meyer gate capacitance model.</p> <p>Gate charge is split into bias-dependent intrinsic charge (Meyer) and linear overlap contributions at the drain and source.</p> <p>Parameters:</p> Name Type Description Default <code>signals</code> <code>Signals</code> <p>Port voltages at drain (<code>d</code>), gate (<code>g</code>), and source (<code>s</code>).</p> required <code>s</code> <code>States</code> <p>Unused.</p> required <code>Kp</code> <code>float</code> <p>Process transconductance parameter in A/V\u00b2. Defaults to <code>2e-5</code>.</p> <code>2e-05</code> <code>W</code> <code>float</code> <p>Gate width in metres. Defaults to <code>10e-6</code>.</p> <code>1e-05</code> <code>L</code> <code>float</code> <p>Gate length in metres. Defaults to <code>1e-6</code>.</p> <code>1e-06</code> <code>Vth</code> <code>float</code> <p>Threshold voltage in volts. Defaults to <code>1.0</code>.</p> <code>1.0</code> <code>lam</code> <code>float</code> <p>Channel-length modulation coefficient in V\u207b\u00b9. Defaults to <code>0</code>.</p> <code>0.0</code> <code>Cox</code> <code>float</code> <p>Gate oxide capacitance per unit area in F/m\u00b2. Defaults to <code>1e-3</code>.</p> <code>0.001</code> <code>Cgd_ov</code> <code>float</code> <p>Gate-drain overlap capacitance in farads. Defaults to <code>1e-15</code>.</p> <code>1e-15</code> <code>Cgs_ov</code> <code>float</code> <p>Gate-source overlap capacitance in farads. Defaults to <code>1e-15</code>.</p> <code>1e-15</code> Source code in <code>circulax/components/electronic.py</code> <pre><code>@component(ports=(\"d\", \"g\", \"s\"))\ndef NMOSDynamic(\n    signals: Signals,\n    s: States,\n    Kp: float = 2e-5,\n    W: float = 10e-6,\n    L: float = 1e-6,\n    Vth: float = 1.0,\n    lam: float = 0.0,\n    Cox: float = 1e-3,\n    Cgd_ov: float = 1e-15,\n    Cgs_ov: float = 1e-15,\n) -&gt; PhysicsReturn:\n    \"\"\"NMOS with square-law DC model and Meyer gate capacitance model.\n\n    Gate charge is split into bias-dependent intrinsic charge (Meyer) and\n    linear overlap contributions at the drain and source.\n\n    Args:\n        signals: Port voltages at drain (``d``), gate (``g``), and source (``s``).\n        s: Unused.\n        Kp: Process transconductance parameter in A/V\u00b2. Defaults to ``2e-5``.\n        W: Gate width in metres. Defaults to ``10e-6``.\n        L: Gate length in metres. Defaults to ``1e-6``.\n        Vth: Threshold voltage in volts. Defaults to ``1.0``.\n        lam: Channel-length modulation coefficient in V\u207b\u00b9. Defaults to ``0``.\n        Cox: Gate oxide capacitance per unit area in F/m\u00b2. Defaults to ``1e-3``.\n        Cgd_ov: Gate-drain overlap capacitance in farads. Defaults to ``1e-15``.\n        Cgs_ov: Gate-source overlap capacitance in farads. Defaults to ``1e-15``.\n\n    \"\"\"\n    # 1. DC Current\n    i_ds = _nmos_current(signals.d, signals.g, signals.s, Kp, W, L, Vth, lam)\n    f_dict = {\"d\": i_ds, \"g\": 0.0, \"s\": -i_ds}\n\n    # 2. Charges\n    vgs = signals.g - signals.s\n    vds = signals.d - signals.s\n    vgd = signals.g - signals.d\n\n    WL = W * L\n    Cox_total = Cox * WL\n    v_over = vgs - Vth\n\n    cutoff = vgs &lt;= Vth\n    saturation = vds &gt;= v_over\n\n    # Meyer Capacitance Logic\n    Qg_cut = 0.0\n    Qg_sat = (2.0 / 3.0) * Cox_total * v_over\n    Qg_lin = 0.5 * Cox_total * v_over\n\n    Qg = jnp.where(cutoff, Qg_cut, jnp.where(saturation, Qg_sat, Qg_lin))\n    Qd = jnp.where(cutoff, 0.0, jnp.where(saturation, 0.0, -0.5 * Qg))\n    Qs = -Qg - Qd\n\n    Q_gate = Qg + Cgd_ov * vgd + Cgs_ov * vgs\n    Q_drain = Qd - Cgd_ov * vgd\n    Q_source = Qs - Cgs_ov * vgs\n\n    return f_dict, {\"d\": Q_drain, \"g\": Q_gate, \"s\": Q_source}\n</code></pre>"},{"location":"references/components/electronic/#circulax.components.electronic.PMOS","title":"PMOS","text":"<pre><code>PMOS(\n    signals: Signals,\n    s: States,\n    Kp: float = 1e-05,\n    W: float = 2e-05,\n    L: float = 1e-06,\n    Vth: float = -1.0,\n    lam: float = 0.0,\n) -&gt; PhysicsReturn\n</code></pre> <p>P-channel MOSFET with square-law DC model, formulated in terms of <code>Vsg</code> and <code>Vsd</code>.</p> <p>Gate current is zero (infinite input impedance).</p> <p>Parameters:</p> Name Type Description Default <code>signals</code> <code>Signals</code> <p>Port voltages at drain (<code>d</code>), gate (<code>g</code>), and source (<code>s</code>).</p> required <code>s</code> <code>States</code> <p>Unused.</p> required <code>Kp</code> <code>float</code> <p>Process transconductance parameter in A/V\u00b2. Defaults to <code>1e-5</code>.</p> <code>1e-05</code> <code>W</code> <code>float</code> <p>Gate width in metres. Defaults to <code>20e-6</code>.</p> <code>2e-05</code> <code>L</code> <code>float</code> <p>Gate length in metres. Defaults to <code>1e-6</code>.</p> <code>1e-06</code> <code>Vth</code> <code>float</code> <p>Threshold voltage in volts (negative for PMOS). Defaults to <code>-1.0</code>.</p> <code>-1.0</code> <code>lam</code> <code>float</code> <p>Channel-length modulation coefficient in V\u207b\u00b9. Defaults to <code>0</code>.</p> <code>0.0</code> Source code in <code>circulax/components/electronic.py</code> <pre><code>@component(ports=(\"d\", \"g\", \"s\"))\ndef PMOS(\n    signals: Signals,\n    s: States,\n    Kp: float = 1e-5,\n    W: float = 20e-6,\n    L: float = 1e-6,\n    Vth: float = -1.0,\n    lam: float = 0.0,\n) -&gt; PhysicsReturn:\n    \"\"\"P-channel MOSFET with square-law DC model, formulated in terms of ``Vsg`` and ``Vsd``.\n\n    Gate current is zero (infinite input impedance).\n\n    Args:\n        signals: Port voltages at drain (``d``), gate (``g``), and source (``s``).\n        s: Unused.\n        Kp: Process transconductance parameter in A/V\u00b2. Defaults to ``1e-5``.\n        W: Gate width in metres. Defaults to ``20e-6``.\n        L: Gate length in metres. Defaults to ``1e-6``.\n        Vth: Threshold voltage in volts (negative for PMOS). Defaults to ``-1.0``.\n        lam: Channel-length modulation coefficient in V\u207b\u00b9. Defaults to ``0``.\n\n    \"\"\"\n    vsg = signals.s - signals.g\n    vsd = signals.s - signals.d\n\n    beta = Kp * (W / L)\n    vth_abs = jnp.abs(Vth)\n    v_over = vsg - vth_abs\n\n    linear_current = beta * (v_over * vsd - 0.5 * vsd**2) * (1 + lam * vsd)\n    sat_current = (beta / 2.0) * (v_over**2) * (1 + lam * vsd)\n\n    i_sd = jnp.where(\n        vsg &lt;= vth_abs, 0.0, jnp.where(vsd &lt; v_over, linear_current, sat_current)\n    )\n\n    return {\"d\": -i_sd, \"g\": 0.0, \"s\": i_sd}, {}\n</code></pre>"},{"location":"references/components/electronic/#circulax.components.electronic.Resistor","title":"Resistor","text":"<pre><code>Resistor(signals: Signals, s: States, R: float = 1000.0) -&gt; PhysicsReturn\n</code></pre> <p>Ohm's Law: I = V/R.</p> Source code in <code>circulax/components/electronic.py</code> <pre><code>@component(ports=(\"p1\", \"p2\"))\ndef Resistor(signals: Signals, s: States, R: float = 1e3) -&gt; PhysicsReturn:\n    \"\"\"Ohm's Law: I = V/R.\"\"\"\n    i = (signals.p1 - signals.p2) / (R + 1e-12)\n    return {\"p1\": i, \"p2\": -i}, {}\n</code></pre>"},{"location":"references/components/electronic/#circulax.components.electronic.SmoothPulse","title":"SmoothPulse","text":"<pre><code>SmoothPulse(\n    signals: Signals,\n    s: States,\n    t: float,\n    V: float = 1.0,\n    delay: float = 1e-09,\n    tr: float = 1e-10,\n) -&gt; PhysicsReturn\n</code></pre> <p>Sigmoid-smoothed pulse.</p> Source code in <code>circulax/components/electronic.py</code> <pre><code>@source(ports=(\"p1\", \"p2\"), states=(\"i_src\",))\ndef SmoothPulse(\n    signals: Signals,\n    s: States,\n    t: float,\n    V: float = 1.0,\n    delay: float = 1e-9,\n    tr: float = 1e-10,\n) -&gt; PhysicsReturn:\n    \"\"\"Sigmoid-smoothed pulse.\"\"\"\n    k = 10.0 / tr\n    v_val = V * jnn.sigmoid(k * (t - delay))\n    constraint = (signals.p1 - signals.p2) - v_val\n    return {\"p1\": s.i_src, \"p2\": -s.i_src, \"i_src\": constraint}, {}\n</code></pre>"},{"location":"references/components/electronic/#circulax.components.electronic.VCCS","title":"VCCS","text":"<pre><code>VCCS(signals: Signals, s: States, G: float = 0.0) -&gt; PhysicsReturn\n</code></pre> <p>Voltage Controlled Current Source.</p> Source code in <code>circulax/components/electronic.py</code> <pre><code>@component(ports=(\"out_p\", \"out_m\", \"ctrl_p\", \"ctrl_m\"))\ndef VCCS(signals: Signals, s: States, G: float = 0.0) -&gt; PhysicsReturn:\n    \"\"\"Voltage Controlled Current Source.\"\"\"\n    i = G * (signals.ctrl_p - signals.ctrl_m)\n    return {\"out_p\": i, \"out_m\": -i, \"ctrl_p\": 0.0, \"ctrl_m\": 0.0}, {}\n</code></pre>"},{"location":"references/components/electronic/#circulax.components.electronic.VCVS","title":"VCVS","text":"<pre><code>VCVS(signals: Signals, s: States, A: float = 1.0) -&gt; PhysicsReturn\n</code></pre> <p>Voltage Controlled Voltage Source.</p> Source code in <code>circulax/components/electronic.py</code> <pre><code>@component(ports=(\"out_p\", \"out_m\", \"ctrl_p\", \"ctrl_m\"), states=(\"i_src\",))\ndef VCVS(signals: Signals, s: States, A: float = 1.0) -&gt; PhysicsReturn:\n    \"\"\"Voltage Controlled Voltage Source.\"\"\"\n    constraint = (signals.out_p - signals.out_m) - A * (signals.ctrl_p - signals.ctrl_m)\n    return {\n        \"out_p\": s.i_src,\n        \"out_m\": -s.i_src,\n        \"ctrl_p\": 0.0,\n        \"ctrl_m\": 0.0,\n        \"i_src\": constraint,\n    }, {}\n</code></pre>"},{"location":"references/components/electronic/#circulax.components.electronic.VoltageControlledSwitch","title":"VoltageControlledSwitch","text":"<pre><code>VoltageControlledSwitch(\n    signals: Signals,\n    s: States,\n    Ron: float = 1.0,\n    Roff: float = 1000000.0,\n    Vt: float = 0.0,\n) -&gt; PhysicsReturn\n</code></pre> <p>Voltage Controlled Switch.</p> Source code in <code>circulax/components/electronic.py</code> <pre><code>@component(ports=(\"p1\", \"p2\", \"cp\", \"cm\"))\ndef VoltageControlledSwitch(\n    signals: Signals, s: States, Ron: float = 1.0, Roff: float = 1e6, Vt: float = 0.0\n) -&gt; PhysicsReturn:\n    \"\"\"Voltage Controlled Switch.\"\"\"\n    v_ctrl = signals.cp - signals.cm\n    k = 10.0\n    sig = jnn.sigmoid(k * (v_ctrl - Vt))\n\n    g_on = 1.0 / Ron\n    g_off = 1.0 / Roff\n    g_eff = g_off + (g_on - g_off) * sig\n\n    i = (signals.p1 - signals.p2) * g_eff\n    return {\"p1\": i, \"p2\": -i, \"cp\": 0.0, \"cm\": 0.0}, {}\n</code></pre>"},{"location":"references/components/electronic/#circulax.components.electronic.VoltageSource","title":"VoltageSource","text":"<pre><code>VoltageSource(\n    signals: Signals, s: States, t: float, V: float = 0.0, delay: float = 0.0\n) -&gt; PhysicsReturn\n</code></pre> <p>Step voltage source.</p> Source code in <code>circulax/components/electronic.py</code> <pre><code>@source(ports=(\"p1\", \"p2\"), states=(\"i_src\",))\ndef VoltageSource(\n    signals: Signals, s: States, t: float, V: float = 0.0, delay: float = 0.0\n) -&gt; PhysicsReturn:\n    \"\"\"Step voltage source.\"\"\"\n    v_val = jnp.where(t &gt;= delay, V, 0.0)\n    constraint = (signals.p1 - signals.p2) - v_val\n    return {\"p1\": s.i_src, \"p2\": -s.i_src, \"i_src\": constraint}, {}\n</code></pre>"},{"location":"references/components/electronic/#circulax.components.electronic.VoltageSourceAC","title":"VoltageSourceAC","text":"<pre><code>VoltageSourceAC(\n    signals: Signals,\n    s: States,\n    t: float,\n    V: float = 0.0,\n    freq: float = 1000000.0,\n    phase: float = 0.0,\n    delay: float = 0.0,\n) -&gt; PhysicsReturn\n</code></pre> <p>Sinusoidal voltage source.</p> Source code in <code>circulax/components/electronic.py</code> <pre><code>@source(ports=(\"p1\", \"p2\"), states=(\"i_src\",))\ndef VoltageSourceAC(\n    signals: Signals,\n    s: States,\n    t: float,\n    V: float = 0.0,\n    freq: float = 1e6,\n    phase: float = 0.0,\n    delay: float = 0.0,\n) -&gt; PhysicsReturn:\n    \"\"\"Sinusoidal voltage source.\"\"\"\n    omega = 2.0 * jnp.pi * freq\n    v_ac = V * jnp.sin(omega * t + phase)\n    v_val = jnp.where(t &gt;= delay, v_ac, 0.0)\n    constraint = (signals.p1 - signals.p2) - v_val\n    return {\"p1\": s.i_src, \"p2\": -s.i_src, \"i_src\": constraint}, {}\n</code></pre>"},{"location":"references/components/electronic/#circulax.components.electronic.ZenerDiode","title":"ZenerDiode","text":"<pre><code>ZenerDiode(\n    signals: Signals,\n    s: States,\n    Vz: float = 5.0,\n    Is: float = 1e-12,\n    n: float = 1.0,\n    Vt: float = 0.02585,\n) -&gt; PhysicsReturn\n</code></pre> <p>Zener diode with forward Shockley conduction and reverse breakdown.</p> <p>Breakdown is modelled as a reverse exponential that activates when <code>Vd &lt; -Vz</code>.</p> <p>Parameters:</p> Name Type Description Default <code>signals</code> <code>Signals</code> <p>Port voltages at anode (<code>p1</code>) and cathode (<code>p2</code>).</p> required <code>s</code> <code>States</code> <p>Unused.</p> required <code>Vz</code> <code>float</code> <p>Zener breakdown voltage in volts. Defaults to <code>5.0</code>.</p> <code>5.0</code> <code>Is</code> <code>float</code> <p>Saturation current in amperes. Defaults to <code>1e-12</code>.</p> <code>1e-12</code> <code>n</code> <code>float</code> <p>Ideality factor. Defaults to <code>1.0</code>.</p> <code>1.0</code> <code>Vt</code> <code>float</code> <p>Thermal voltage in volts. Defaults to <code>25.85e-3</code>.</p> <code>0.02585</code> Source code in <code>circulax/components/electronic.py</code> <pre><code>@component(ports=(\"p1\", \"p2\"))\ndef ZenerDiode(\n    signals: Signals,\n    s: States,\n    Vz: float = 5.0,\n    Is: float = 1e-12,\n    n: float = 1.0,\n    Vt: float = 25.85e-3,\n) -&gt; PhysicsReturn:\n    \"\"\"Zener diode with forward Shockley conduction and reverse breakdown.\n\n    Breakdown is modelled as a reverse exponential that activates when\n    ``Vd &lt; -Vz``.\n\n    Args:\n        signals: Port voltages at anode (``p1``) and cathode (``p2``).\n        s: Unused.\n        Vz: Zener breakdown voltage in volts. Defaults to ``5.0``.\n        Is: Saturation current in amperes. Defaults to ``1e-12``.\n        n: Ideality factor. Defaults to ``1.0``.\n        Vt: Thermal voltage in volts. Defaults to ``25.85e-3``.\n\n    \"\"\"\n    vd = signals.p1 - signals.p2\n    i_fwd = Is * (jnp.exp(vd / (n * Vt)) - 1.0)\n    # Zener breakdown modeled as reverse exponential\n    i_rev = -Is * (jnp.exp(-(vd + Vz) / (n * Vt)) - 1.0)\n    i_total = i_fwd + jnp.where(vd &lt; -Vz, i_rev, 0.0)\n    return {\"p1\": i_total, \"p2\": -i_total}, {}\n</code></pre>"},{"location":"references/components/photonic/","title":"Photonic","text":""},{"location":"references/components/photonic/#circulax.components.photonic","title":"photonic","text":"<p>Photonic components for optical circuit simulation.</p> <p>All wavelength parameters are in nanometres and power in watts.</p> <p>Functions:</p> Name Description <code>Grating</code> <p>Grating coupler with Gaussian wavelength-dependent insertion loss.</p> <code>OpticalSource</code> <p>Ideal CW optical source for DC and small-signal AC analysis.</p> <code>OpticalSourcePulse</code> <p>Time-dependent optical source with a sigmoid turn-on profile.</p> <code>OpticalWaveguide</code> <p>Single-mode waveguide with first-order dispersion and propagation loss.</p> <code>Splitter</code> <p>Lossless asymmetric optical splitter (Y-junction) with a configurable power split ratio.</p>"},{"location":"references/components/photonic/#circulax.components.photonic.Grating","title":"Grating","text":"<pre><code>Grating(\n    signals: Signals,\n    s: States,\n    center_wavelength_nm: float = 1310.0,\n    peak_loss_dB: float = 0.0,\n    bandwidth_1dB: float = 20.0,\n    wavelength_nm: float = 1310.0,\n) -&gt; PhysicsReturn\n</code></pre> <p>Grating coupler with Gaussian wavelength-dependent insertion loss.</p> <p>Loss increases quadratically with detuning from <code>center_wavelength_nm</code>, approximating the Gaussian spectral response of a typical grating coupler. Transmission is clipped to <code>0.9999</code> to keep the Y-matrix well-conditioned.</p> <p>Parameters:</p> Name Type Description Default <code>signals</code> <code>Signals</code> <p>Field amplitudes at the grating (<code>grating</code>) and waveguide (<code>waveguide</code>) ports.</p> required <code>s</code> <code>States</code> <p>Unused.</p> required <code>center_wavelength_nm</code> <code>float</code> <p>Peak transmission wavelength in nm. Defaults to <code>1310.0</code>.</p> <code>1310.0</code> <code>peak_loss_dB</code> <code>float</code> <p>Insertion loss at peak wavelength in dB. Defaults to <code>0.0</code>.</p> <code>0.0</code> <code>bandwidth_1dB</code> <code>float</code> <p>Full 1 dB bandwidth in nm. Defaults to <code>20.0</code>.</p> <code>20.0</code> <code>wavelength_nm</code> <code>float</code> <p>Operating wavelength in nm. Defaults to <code>1310.0</code>.</p> <code>1310.0</code> Source code in <code>circulax/components/photonic.py</code> <pre><code>@component(ports=(\"grating\", \"waveguide\"))\ndef Grating(\n    signals: Signals,\n    s: States,\n    center_wavelength_nm: float = 1310.0,\n    peak_loss_dB: float = 0.0,\n    bandwidth_1dB: float = 20.0,\n    wavelength_nm: float = 1310.0,\n)-&gt; PhysicsReturn:\n    \"\"\"Grating coupler with Gaussian wavelength-dependent insertion loss.\n\n    Loss increases quadratically with detuning from ``center_wavelength_nm``,\n    approximating the Gaussian spectral response of a typical grating coupler.\n    Transmission is clipped to ``0.9999`` to keep the Y-matrix well-conditioned.\n\n    Args:\n        signals: Field amplitudes at the grating (``grating``) and waveguide (``waveguide``) ports.\n        s: Unused.\n        center_wavelength_nm: Peak transmission wavelength in nm. Defaults to ``1310.0``.\n        peak_loss_dB: Insertion loss at peak wavelength in dB. Defaults to ``0.0``.\n        bandwidth_1dB: Full 1 dB bandwidth in nm. Defaults to ``20.0``.\n        wavelength_nm: Operating wavelength in nm. Defaults to ``1310.0``.\n\n    \"\"\"\n    delta = wavelength_nm - center_wavelength_nm\n    excess_loss = (delta / (0.5 * bandwidth_1dB)) ** 2\n    loss_dB = peak_loss_dB + excess_loss\n\n    T = 10.0 ** (-loss_dB / 20.0)\n    # Numerical stability clip\n    T = jnp.minimum(T, 0.9999)\n\n    S = jnp.array([[0.0, T], [T, 0.0]], dtype=jnp.complex128)\n    Y = s_to_y(S)\n\n    v_vec = jnp.array([signals.grating, signals.waveguide], dtype=jnp.complex128)\n    i_vec = Y @ v_vec\n\n    return {\"grating\": i_vec[0], \"waveguide\": i_vec[1]}, {}\n</code></pre>"},{"location":"references/components/photonic/#circulax.components.photonic.OpticalSource","title":"OpticalSource","text":"<pre><code>OpticalSource(\n    signals: Signals, s: States, power: float = 1.0, phase: float = 0.0\n) -&gt; PhysicsReturn\n</code></pre> <p>Ideal CW optical source for DC and small-signal AC analysis.</p> <p>Enforces a fixed complex field amplitude <code>sqrt(power) * exp(j * phase)</code> across its ports, analogous to an ideal voltage source in electrical circuits.</p> <p>Parameters:</p> Name Type Description Default <code>signals</code> <code>Signals</code> <p>Field amplitudes at the positive (<code>p1</code>) and negative (<code>p2</code>) ports.</p> required <code>s</code> <code>States</code> <p>Source current state variable <code>i_src</code>.</p> required <code>power</code> <code>float</code> <p>Output optical power in watts. Defaults to <code>1.0</code>.</p> <code>1.0</code> <code>phase</code> <code>float</code> <p>Output field phase in radians. Defaults to <code>0.0</code>.</p> <code>0.0</code> Source code in <code>circulax/components/photonic.py</code> <pre><code>@component(ports=(\"p1\", \"p2\"), states=(\"i_src\",))\ndef OpticalSource(signals: Signals, s: States, power: float = 1.0, phase: float = 0.0)-&gt; PhysicsReturn:\n    \"\"\"Ideal CW optical source for DC and small-signal AC analysis.\n\n    Enforces a fixed complex field amplitude ``sqrt(power) * exp(j * phase)``\n    across its ports, analogous to an ideal voltage source in electrical circuits.\n\n    Args:\n        signals: Field amplitudes at the positive (``p1``) and negative (``p2``) ports.\n        s: Source current state variable ``i_src``.\n        power: Output optical power in watts. Defaults to ``1.0``.\n        phase: Output field phase in radians. Defaults to ``0.0``.\n\n    \"\"\"\n    v_val = jnp.sqrt(power) * jnp.exp(1j * phase)\n    constraint = (signals.p1 - signals.p2) - v_val\n\n    return {\"p1\": s.i_src, \"p2\": -s.i_src, \"i_src\": constraint}, {}\n</code></pre>"},{"location":"references/components/photonic/#circulax.components.photonic.OpticalSourcePulse","title":"OpticalSourcePulse","text":"<pre><code>OpticalSourcePulse(\n    signals: Signals,\n    s: States,\n    t: float,\n    power: float = 1.0,\n    phase: float = 0.0,\n    delay: float = 2e-10,\n    rise: float = 5e-11,\n) -&gt; PhysicsReturn\n</code></pre> <p>Time-dependent optical source with a sigmoid turn-on profile.</p> <p>Field amplitude ramps smoothly from zero to <code>sqrt(power)</code> around <code>delay</code>, with the steepness of the transition controlled by <code>rise</code>. Suitable for transient simulations of optical pulse propagation.</p> <p>Parameters:</p> Name Type Description Default <code>signals</code> <code>Signals</code> <p>Field amplitudes at the positive (<code>p1</code>) and negative (<code>p2</code>) ports.</p> required <code>s</code> <code>States</code> <p>Source current state variable <code>i_src</code>.</p> required <code>t</code> <code>float</code> <p>Current simulation time in seconds.</p> required <code>power</code> <code>float</code> <p>Peak output optical power in watts. Defaults to <code>1.0</code>.</p> <code>1.0</code> <code>phase</code> <code>float</code> <p>Output field phase in radians. Defaults to <code>0.0</code>.</p> <code>0.0</code> <code>delay</code> <code>float</code> <p>Turn-on delay in seconds. Defaults to <code>0.2e-9</code>.</p> <code>2e-10</code> <code>rise</code> <code>float</code> <p>Sigmoid rise time constant in seconds. Defaults to <code>0.05e-9</code>.</p> <code>5e-11</code> Source code in <code>circulax/components/photonic.py</code> <pre><code>@source(ports=(\"p1\", \"p2\"), states=(\"i_src\",))\ndef OpticalSourcePulse(\n    signals: Signals,\n    s: States,\n    t: float,\n    power: float = 1.0,\n    phase: float = 0.0,\n    delay: float = 0.2e-9,\n    rise: float = 0.05e-9,\n)-&gt; PhysicsReturn:\n    \"\"\"Time-dependent optical source with a sigmoid turn-on profile.\n\n    Field amplitude ramps smoothly from zero to ``sqrt(power)`` around\n    ``delay``, with the steepness of the transition controlled by ``rise``.\n    Suitable for transient simulations of optical pulse propagation.\n\n    Args:\n        signals: Field amplitudes at the positive (``p1``) and negative (``p2``) ports.\n        s: Source current state variable ``i_src``.\n        t: Current simulation time in seconds.\n        power: Peak output optical power in watts. Defaults to ``1.0``.\n        phase: Output field phase in radians. Defaults to ``0.0``.\n        delay: Turn-on delay in seconds. Defaults to ``0.2e-9``.\n        rise: Sigmoid rise time constant in seconds. Defaults to ``0.05e-9``.\n\n    \"\"\"\n    val = jnp.sqrt(power) * jnn.sigmoid((t - delay) / rise)\n    v_val = val * jnp.exp(1j * phase)\n\n    constraint = (signals.p1 - signals.p2) - v_val\n\n    return {\"p1\": s.i_src, \"p2\": -s.i_src, \"i_src\": constraint}, {}\n</code></pre>"},{"location":"references/components/photonic/#circulax.components.photonic.OpticalWaveguide","title":"OpticalWaveguide","text":"<pre><code>OpticalWaveguide(\n    signals: Signals,\n    s: States,\n    length_um: float = 100.0,\n    loss_dB_cm: float = 1.0,\n    neff: float = 2.4,\n    n_group: float = 4.0,\n    center_wavelength_nm: float = 1310.0,\n    wavelength_nm: float = 1310.0,\n) -&gt; PhysicsReturn\n</code></pre> <p>Single-mode waveguide with first-order dispersion and propagation loss.</p> <p>The effective index is linearised around <code>center_wavelength_nm</code> using the group index to approximate dispersion. Phase and loss are combined into a complex transmission coefficient <code>T</code>, from which the 2\u00d72 S-matrix and corresponding Y-matrix are derived.</p> <p>Parameters:</p> Name Type Description Default <code>signals</code> <code>Signals</code> <p>Field amplitudes at input (<code>p1</code>) and output (<code>p2</code>).</p> required <code>s</code> <code>States</code> <p>Unused.</p> required <code>length_um</code> <code>float</code> <p>Waveguide length in micrometres. Defaults to <code>100.0</code>.</p> <code>100.0</code> <code>loss_dB_cm</code> <code>float</code> <p>Propagation loss in dB/cm. Defaults to <code>1.0</code>.</p> <code>1.0</code> <code>neff</code> <code>float</code> <p>Effective refractive index at <code>center_wavelength_nm</code>. Defaults to <code>2.4</code>.</p> <code>2.4</code> <code>n_group</code> <code>float</code> <p>Group refractive index, used to compute the dispersion slope. Defaults to <code>4.0</code>.</p> <code>4.0</code> <code>center_wavelength_nm</code> <code>float</code> <p>Reference wavelength for dispersion expansion in nm. Defaults to <code>1310.0</code>.</p> <code>1310.0</code> <code>wavelength_nm</code> <code>float</code> <p>Operating wavelength in nm. Defaults to <code>1310.0</code>.</p> <code>1310.0</code> Source code in <code>circulax/components/photonic.py</code> <pre><code>@component(ports=(\"p1\", \"p2\"))\ndef OpticalWaveguide(\n    signals: Signals,\n    s: States,\n    length_um: float = 100.0,\n    loss_dB_cm: float = 1.0,\n    neff: float = 2.4,\n    n_group: float = 4.0,\n    center_wavelength_nm: float = 1310.0,\n    wavelength_nm: float = 1310.0,\n) -&gt; PhysicsReturn:\n    \"\"\"Single-mode waveguide with first-order dispersion and propagation loss.\n\n    The effective index is linearised around ``center_wavelength_nm`` using the\n    group index to approximate dispersion. Phase and loss are combined into a\n    complex transmission coefficient ``T``, from which the 2\u00d72 S-matrix and\n    corresponding Y-matrix are derived.\n\n    Args:\n        signals: Field amplitudes at input (``p1``) and output (``p2``).\n        s: Unused.\n        length_um: Waveguide length in micrometres. Defaults to ``100.0``.\n        loss_dB_cm: Propagation loss in dB/cm. Defaults to ``1.0``.\n        neff: Effective refractive index at ``center_wavelength_nm``. Defaults to ``2.4``.\n        n_group: Group refractive index, used to compute the dispersion slope. Defaults to ``4.0``.\n        center_wavelength_nm: Reference wavelength for dispersion expansion in nm. Defaults to ``1310.0``.\n        wavelength_nm: Operating wavelength in nm. Defaults to ``1310.0``.\n\n    \"\"\"\n    d_lam = wavelength_nm - center_wavelength_nm\n    slope = (neff - n_group) / center_wavelength_nm\n    n_eff_disp = neff + slope * d_lam\n\n    # Phase calculation\n    phi = 2.0 * jnp.pi * n_eff_disp * (length_um / wavelength_nm) * 1000.0\n\n    # Loss calculation\n    loss_val = loss_dB_cm * (length_um / 10000.0)\n    T_mag = 10.0 ** (-loss_val / 20.0)\n\n    # S-Matrix construction\n    T = T_mag * jnp.exp(-1j * phi)\n    S = jnp.array([[0.0, T], [T, 0.0]], dtype=jnp.complex128)\n\n    # Convert to Admittance (Y)\n    Y = s_to_y(S)\n\n    # Calculate Currents (I = Y * V)\n    # Note: Explicit complex cast ensures JAX treats the interaction as complex\n    v_vec = jnp.array([signals.p1, signals.p2], dtype=jnp.complex128)\n    i_vec = Y @ v_vec\n\n    return {\"p1\": i_vec[0], \"p2\": i_vec[1]}, {}\n</code></pre>"},{"location":"references/components/photonic/#circulax.components.photonic.Splitter","title":"Splitter","text":"<pre><code>Splitter(signals: Signals, s: States, split_ratio: float = 0.5) -&gt; PhysicsReturn\n</code></pre> <p>Lossless asymmetric optical splitter (Y-junction) with a configurable power split ratio.</p> <p>The S-matrix is constructed to be unitary, with the cross-port coupling carrying a <code>j</code> phase shift to satisfy energy conservation.</p> <p>Parameters:</p> Name Type Description Default <code>signals</code> <code>Signals</code> <p>Field amplitudes at the input (<code>p1</code>) and two output ports (<code>p2</code>, <code>p3</code>).</p> required <code>s</code> <code>States</code> <p>Unused.</p> required <code>split_ratio</code> <code>float</code> <p>Fraction of input power routed to <code>p2</code>. The remaining <code>1 - split_ratio</code> is routed to <code>p3</code>. Defaults to <code>0.5</code> (50/50 splitter).</p> <code>0.5</code> Source code in <code>circulax/components/photonic.py</code> <pre><code>@component(ports=(\"p1\", \"p2\", \"p3\"))\ndef Splitter(signals: Signals, s: States, split_ratio: float = 0.5)-&gt; PhysicsReturn:\n    \"\"\"Lossless asymmetric optical splitter (Y-junction) with a configurable power split ratio.\n\n    The S-matrix is constructed to be unitary, with the cross-port coupling\n    carrying a ``j`` phase shift to satisfy energy conservation.\n\n    Args:\n        signals: Field amplitudes at the input (``p1``) and two output ports\n            (``p2``, ``p3``).\n        s: Unused.\n        split_ratio: Fraction of input power routed to ``p2``. The remaining\n            ``1 - split_ratio`` is routed to ``p3``. Defaults to ``0.5``\n            (50/50 splitter).\n\n    \"\"\"\n    r = jnp.sqrt(split_ratio)\n    tc = jnp.sqrt(1.0 - split_ratio)\n\n    S = jnp.array(\n        [[0.0, r, 1j * tc], [r, 0.0, 0.0], [1j * tc, 0.0, 0.0]], dtype=jnp.complex128\n    )\n\n    Y = s_to_y(S)\n\n    v_vec = jnp.array([signals.p1, signals.p2, signals.p3], dtype=jnp.complex128)\n    i_vec = Y @ v_vec\n\n    return {\"p1\": i_vec[0], \"p2\": i_vec[1], \"p3\": i_vec[2]}, {}\n</code></pre>"},{"location":"references/solvers/","title":"Index","text":""},{"location":"references/solvers/#circulax.solvers","title":"solvers","text":"<p>Root finding and transient solvers.</p> <p>Modules:</p> Name Description <code>assembly</code> <p>Assembly functions for the transient circuit solver.</p> <code>linear</code> <p>Circuit Linear Solvers Strategy Pattern.</p> <code>transient</code> <p>Transient solvers to be used with Diffrax.</p> <p>Classes:</p> Name Description <code>CircuitLinearSolver</code> <p>Abstract Base Class for all circuit linear solvers.</p> <code>DenseSolver</code> <p>Solves the system using dense matrix factorization (LU).</p> <code>KLUSolver</code> <p>Solves the system using the KLU sparse solver (via <code>klujax</code>).</p> <code>SparseSolver</code> <p>Solves the system using JAX's Iterative BiCGStab solver.</p> <code>VectorizedTransientSolver</code> <p>Transient solver that works strictly on FLAT (Real) vectors.</p> <p>Functions:</p> Name Description <code>analyze_circuit</code> <p>Initializes a linear solver strategy for circuit analysis.</p> <code>assemble_system_complex</code> <p>Assemble the residual vectors and effective Jacobian values for an unrolled complex system.</p> <code>assemble_system_real</code> <p>Assemble the residual vectors and effective Jacobian values for a real system.</p> <code>setup_transient</code> <p>Configures and returns a function for executing transient analysis.</p>"},{"location":"references/solvers/#circulax.solvers.CircuitLinearSolver","title":"CircuitLinearSolver","text":"<p>               Bases: <code>AbstractLinearSolver</code></p> <p>Abstract Base Class for all circuit linear solvers.</p> <p>This class provides the unified interface for: 1.  Storing static matrix structure (indices, rows, cols). 2.  Handling Real vs. Complex-Unrolled system configurations. 3.  Providing a robust Newton-Raphson DC Operating Point solver.</p> <p>Attributes:</p> Name Type Description <code>ground_indices</code> <code>Array</code> <p>Indices of nodes connected to ground (forced to 0V).</p> <code>is_complex</code> <code>bool</code> <p>Static flag. If True, the system is 2N x 2N (Real/Imag unrolled).                If False, the system is N x N (Real).</p> <p>Methods:</p> Name Description <code>assume_full_rank</code> <p>Indicate if the solver assumes the operator is full rank.</p> <code>compute</code> <p>Performs the computation of the component for each step.</p> <code>init</code> <p>Initialize the solver state (No-op for stateless solvers).</p> <code>solve_dc</code> <p>Performs a robust DC Operating Point analysis (Newton-Raphson).</p>"},{"location":"references/solvers/#circulax.solvers.CircuitLinearSolver.assume_full_rank","title":"assume_full_rank","text":"<pre><code>assume_full_rank() -&gt; bool\n</code></pre> <p>Indicate if the solver assumes the operator is full rank.</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def assume_full_rank(self) -&gt; bool:\n    \"\"\"Indicate if the solver assumes the operator is full rank.\"\"\"\n    return False\n</code></pre>"},{"location":"references/solvers/#circulax.solvers.CircuitLinearSolver.compute","title":"compute","text":"<pre><code>compute(state: Any, vector: Array, options: Any) -&gt; Solution\n</code></pre> <p>Performs the computation of the component for each step.</p> <p>In our case, we usually call <code>_solve_impl</code> directly to avoid overhead, but this satisfies the API.</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def compute(self, state: Any, vector: jax.Array, options: Any) -&gt; lx.Solution:\n    \"\"\"Performs the computation of the component for each step.\n\n    In our case, we usually call `_solve_impl` directly to avoid overhead,\n    but this satisfies the API.\n\n    \"\"\"\n    msg = \"Directly call _solve_impl for internal use.\"\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"references/solvers/#circulax.solvers.CircuitLinearSolver.init","title":"init","text":"<pre><code>init(operator: Any, options: Any) -&gt; Any\n</code></pre> <p>Initialize the solver state (No-op for stateless solvers).</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def init(self, operator: Any, options: Any) -&gt; Any:  # noqa: ARG002\n    \"\"\"Initialize the solver state (No-op for stateless solvers).\"\"\"\n    return None\n</code></pre>"},{"location":"references/solvers/#circulax.solvers.CircuitLinearSolver.solve_dc","title":"solve_dc","text":"<pre><code>solve_dc(component_groups: dict[str, Any], y_guess: Array) -&gt; Array\n</code></pre> <p>Performs a robust DC Operating Point analysis (Newton-Raphson).</p> <p>This method: 1.  Detects if the system is Real or Complex based on <code>self.is_complex</code>. 2.  Assembles the system with dt=infinity (to open capacitors). 3.  Applies ground constraints (setting specific rows/cols to identity). 4.  Solves the linear system J * delta = -Residual. 5.  Applies voltage damping to prevent exponential overshoot.</p> <p>Parameters:</p> Name Type Description Default <code>component_groups</code> <code>dict</code> <p>The circuit components and their parameters.</p> required <code>y_guess</code> <code>Array</code> <p>Initial guess vector (Shape: [N] or [2N]).</p> required <p>Returns:</p> Type Description <code>Array</code> <p>jax.Array: The converged solution vector (Flat).</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def solve_dc(\n    self, component_groups: dict[str, Any], y_guess: jax.Array\n) -&gt; jax.Array:\n    \"\"\"Performs a robust DC Operating Point analysis (Newton-Raphson).\n\n    This method:\n    1.  Detects if the system is Real or Complex based on `self.is_complex`.\n    2.  Assembles the system with dt=infinity (to open capacitors).\n    3.  Applies ground constraints (setting specific rows/cols to identity).\n    4.  Solves the linear system J * delta = -Residual.\n    5.  Applies voltage damping to prevent exponential overshoot.\n\n    Args:\n        component_groups (dict): The circuit components and their parameters.\n        y_guess (jax.Array): Initial guess vector (Shape: [N] or [2N]).\n\n    Returns:\n        jax.Array: The converged solution vector (Flat).\n\n    \"\"\"\n\n    def dc_step(y: jax.Array, _: Any) -&gt; jax.Array:\n        # 1. Assemble System (dt=1e18 effectively removes time-dependent terms like C*dv/dt)\n        if self.is_complex:\n            total_f, _, all_vals = assemble_system_complex(\n                y, component_groups, t1=0.0, dt=1e18\n            )\n        else:\n            total_f, _, all_vals = assemble_system_real(\n                y, component_groups, t1=0.0, dt=1e18\n            )\n\n        # 2. Apply Ground Constraints to Residual\n        #    We add a massive penalty (1e9 * V) to the residual at ground nodes.\n        #    This forces the solver to drive V -&gt; 0.\n        total_f_grounded = total_f\n        for idx in self.ground_indices:\n            total_f_grounded = total_f_grounded.at[idx].add(1e9 * y[idx])\n\n        # 3. Solve Linear System (J * delta = -R)\n        sol = self._solve_impl(all_vals, -total_f_grounded)\n        delta = sol.value\n\n        # 4. Apply Voltage Limiting (Damping)\n        #    Prevents the solver from taking huge steps that crash exponentials (diodes/transistors).\n        max_change = jnp.max(jnp.abs(delta))\n        damping = jnp.minimum(1.0, 0.5 / (max_change + 1e-9))\n\n        return y + delta * damping\n\n    # 5. Run Newton Loop (Optimistix)\n    solver = optx.FixedPointIteration(rtol=1e-6, atol=1e-6)\n    sol = optx.fixed_point(dc_step, solver, y_guess, max_steps=100, throw=False)\n    return sol.value\n</code></pre>"},{"location":"references/solvers/#circulax.solvers.DenseSolver","title":"DenseSolver","text":"<p>               Bases: <code>CircuitLinearSolver</code></p> <p>Solves the system using dense matrix factorization (LU).</p> Best For <ul> <li>Small to Medium circuits (N &lt; 2000).</li> <li>Wavelength sweeps (AC Analysis) on GPU.</li> <li>Systems where VMAP parallelism is critical.</li> </ul> <p>Attributes:</p> Name Type Description <code>static_rows</code> <code>Array</code> <p>Row indices for placing values into dense matrix.</p> <code>static_cols</code> <code>Array</code> <p>Column indices.</p> <code>g_leak</code> <code>float</code> <p>Leakage conductance added to diagonal to prevent singularity.</p> <p>Methods:</p> Name Description <code>assume_full_rank</code> <p>Indicate if the solver assumes the operator is full rank.</p> <code>compute</code> <p>Performs the computation of the component for each step.</p> <code>from_circuit</code> <p>Factory method to pre-calculate indices for the dense matrix.</p> <code>init</code> <p>Initialize the solver state (No-op for stateless solvers).</p> <code>solve_dc</code> <p>Performs a robust DC Operating Point analysis (Newton-Raphson).</p>"},{"location":"references/solvers/#circulax.solvers.DenseSolver.assume_full_rank","title":"assume_full_rank","text":"<pre><code>assume_full_rank() -&gt; bool\n</code></pre> <p>Indicate if the solver assumes the operator is full rank.</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def assume_full_rank(self) -&gt; bool:\n    \"\"\"Indicate if the solver assumes the operator is full rank.\"\"\"\n    return False\n</code></pre>"},{"location":"references/solvers/#circulax.solvers.DenseSolver.compute","title":"compute","text":"<pre><code>compute(state: Any, vector: Array, options: Any) -&gt; Solution\n</code></pre> <p>Performs the computation of the component for each step.</p> <p>In our case, we usually call <code>_solve_impl</code> directly to avoid overhead, but this satisfies the API.</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def compute(self, state: Any, vector: jax.Array, options: Any) -&gt; lx.Solution:\n    \"\"\"Performs the computation of the component for each step.\n\n    In our case, we usually call `_solve_impl` directly to avoid overhead,\n    but this satisfies the API.\n\n    \"\"\"\n    msg = \"Directly call _solve_impl for internal use.\"\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"references/solvers/#circulax.solvers.DenseSolver.from_circuit","title":"from_circuit  <code>classmethod</code>","text":"<pre><code>from_circuit(\n    component_groups: dict[str, Any], num_vars: int, *, is_complex: bool = False\n) -&gt; DenseSolver\n</code></pre> <p>Factory method to pre-calculate indices for the dense matrix.</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>@classmethod\ndef from_circuit(\n    cls, component_groups: dict[str, Any], num_vars: int, *, is_complex: bool = False\n) -&gt; \"DenseSolver\":\n    \"\"\"Factory method to pre-calculate indices for the dense matrix.\"\"\"\n    all_rows, all_cols = [], []\n    for k in sorted(component_groups.keys()):\n        g = component_groups[k]\n        all_rows.append(np.array(g.jac_rows).reshape(-1))\n        all_cols.append(np.array(g.jac_cols).reshape(-1))\n\n    static_rows = np.concatenate(all_rows)\n    static_cols = np.concatenate(all_cols)\n\n    sys_size = num_vars\n    ground_idxs = np.array([0], dtype=np.int32)\n\n    if is_complex:\n        # Expand to 2N x 2N Block Structure:\n        # [ RR  RI ]\n        # [ IR  II ]\n        sys_size = num_vars * 2\n        r, c = static_rows, static_cols\n        N = num_vars\n\n        static_rows = np.concatenate([r, r, r + N, r + N])\n        static_cols = np.concatenate([c, c + N, c, c + N])\n        ground_idxs = np.array([0, num_vars], dtype=np.int32)\n\n    return cls(\n        static_rows=jnp.array(static_rows),\n        static_cols=jnp.array(static_cols),\n        sys_size=sys_size,\n        ground_indices=jnp.array(ground_idxs),\n        is_complex=is_complex,\n    )\n</code></pre>"},{"location":"references/solvers/#circulax.solvers.DenseSolver.init","title":"init","text":"<pre><code>init(operator: Any, options: Any) -&gt; Any\n</code></pre> <p>Initialize the solver state (No-op for stateless solvers).</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def init(self, operator: Any, options: Any) -&gt; Any:  # noqa: ARG002\n    \"\"\"Initialize the solver state (No-op for stateless solvers).\"\"\"\n    return None\n</code></pre>"},{"location":"references/solvers/#circulax.solvers.DenseSolver.solve_dc","title":"solve_dc","text":"<pre><code>solve_dc(component_groups: dict[str, Any], y_guess: Array) -&gt; Array\n</code></pre> <p>Performs a robust DC Operating Point analysis (Newton-Raphson).</p> <p>This method: 1.  Detects if the system is Real or Complex based on <code>self.is_complex</code>. 2.  Assembles the system with dt=infinity (to open capacitors). 3.  Applies ground constraints (setting specific rows/cols to identity). 4.  Solves the linear system J * delta = -Residual. 5.  Applies voltage damping to prevent exponential overshoot.</p> <p>Parameters:</p> Name Type Description Default <code>component_groups</code> <code>dict</code> <p>The circuit components and their parameters.</p> required <code>y_guess</code> <code>Array</code> <p>Initial guess vector (Shape: [N] or [2N]).</p> required <p>Returns:</p> Type Description <code>Array</code> <p>jax.Array: The converged solution vector (Flat).</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def solve_dc(\n    self, component_groups: dict[str, Any], y_guess: jax.Array\n) -&gt; jax.Array:\n    \"\"\"Performs a robust DC Operating Point analysis (Newton-Raphson).\n\n    This method:\n    1.  Detects if the system is Real or Complex based on `self.is_complex`.\n    2.  Assembles the system with dt=infinity (to open capacitors).\n    3.  Applies ground constraints (setting specific rows/cols to identity).\n    4.  Solves the linear system J * delta = -Residual.\n    5.  Applies voltage damping to prevent exponential overshoot.\n\n    Args:\n        component_groups (dict): The circuit components and their parameters.\n        y_guess (jax.Array): Initial guess vector (Shape: [N] or [2N]).\n\n    Returns:\n        jax.Array: The converged solution vector (Flat).\n\n    \"\"\"\n\n    def dc_step(y: jax.Array, _: Any) -&gt; jax.Array:\n        # 1. Assemble System (dt=1e18 effectively removes time-dependent terms like C*dv/dt)\n        if self.is_complex:\n            total_f, _, all_vals = assemble_system_complex(\n                y, component_groups, t1=0.0, dt=1e18\n            )\n        else:\n            total_f, _, all_vals = assemble_system_real(\n                y, component_groups, t1=0.0, dt=1e18\n            )\n\n        # 2. Apply Ground Constraints to Residual\n        #    We add a massive penalty (1e9 * V) to the residual at ground nodes.\n        #    This forces the solver to drive V -&gt; 0.\n        total_f_grounded = total_f\n        for idx in self.ground_indices:\n            total_f_grounded = total_f_grounded.at[idx].add(1e9 * y[idx])\n\n        # 3. Solve Linear System (J * delta = -R)\n        sol = self._solve_impl(all_vals, -total_f_grounded)\n        delta = sol.value\n\n        # 4. Apply Voltage Limiting (Damping)\n        #    Prevents the solver from taking huge steps that crash exponentials (diodes/transistors).\n        max_change = jnp.max(jnp.abs(delta))\n        damping = jnp.minimum(1.0, 0.5 / (max_change + 1e-9))\n\n        return y + delta * damping\n\n    # 5. Run Newton Loop (Optimistix)\n    solver = optx.FixedPointIteration(rtol=1e-6, atol=1e-6)\n    sol = optx.fixed_point(dc_step, solver, y_guess, max_steps=100, throw=False)\n    return sol.value\n</code></pre>"},{"location":"references/solvers/#circulax.solvers.KLUSolver","title":"KLUSolver","text":"<p>               Bases: <code>CircuitLinearSolver</code></p> <p>Solves the system using the KLU sparse solver (via <code>klujax</code>).</p> Best For <ul> <li>Large circuits (N &gt; 5000) running on CPU.</li> <li>DC Operating Points of massive meshes.</li> <li>Cases where DenseSolver runs out of memory (OOM).</li> </ul> Note <p>Does NOT support <code>vmap</code> (batching) automatically.</p> <p>Methods:</p> Name Description <code>assume_full_rank</code> <p>Indicate if the solver assumes the operator is full rank.</p> <code>compute</code> <p>Performs the computation of the component for each step.</p> <code>from_circuit</code> <p>Factory method to pre-hash indices for sparse coalescence.</p> <code>init</code> <p>Initialize the solver state (No-op for stateless solvers).</p> <code>solve_dc</code> <p>Performs a robust DC Operating Point analysis (Newton-Raphson).</p>"},{"location":"references/solvers/#circulax.solvers.KLUSolver.assume_full_rank","title":"assume_full_rank","text":"<pre><code>assume_full_rank() -&gt; bool\n</code></pre> <p>Indicate if the solver assumes the operator is full rank.</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def assume_full_rank(self) -&gt; bool:\n    \"\"\"Indicate if the solver assumes the operator is full rank.\"\"\"\n    return False\n</code></pre>"},{"location":"references/solvers/#circulax.solvers.KLUSolver.compute","title":"compute","text":"<pre><code>compute(state: Any, vector: Array, options: Any) -&gt; Solution\n</code></pre> <p>Performs the computation of the component for each step.</p> <p>In our case, we usually call <code>_solve_impl</code> directly to avoid overhead, but this satisfies the API.</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def compute(self, state: Any, vector: jax.Array, options: Any) -&gt; lx.Solution:\n    \"\"\"Performs the computation of the component for each step.\n\n    In our case, we usually call `_solve_impl` directly to avoid overhead,\n    but this satisfies the API.\n\n    \"\"\"\n    msg = \"Directly call _solve_impl for internal use.\"\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"references/solvers/#circulax.solvers.KLUSolver.from_circuit","title":"from_circuit  <code>classmethod</code>","text":"<pre><code>from_circuit(\n    component_groups: dict[str, Any], num_vars: int, *, is_complex: bool = False\n) -&gt; KLUSolver\n</code></pre> <p>Factory method to pre-hash indices for sparse coalescence.</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>@classmethod\ndef from_circuit(\n    cls, component_groups: dict[str, Any], num_vars: int, *, is_complex: bool = False\n) -&gt; \"KLUSolver\":\n    \"\"\"Factory method to pre-hash indices for sparse coalescence.\"\"\"\n    all_rows, all_cols = [], []\n    for k in sorted(component_groups.keys()):\n        g = component_groups[k]\n        all_rows.append(np.array(g.jac_rows).reshape(-1))\n        all_cols.append(np.array(g.jac_cols).reshape(-1))\n\n    static_rows = np.concatenate(all_rows)\n    static_cols = np.concatenate(all_cols)\n\n    sys_size = num_vars\n    ground_idxs = np.array([0], dtype=np.int32)\n\n    if is_complex:\n        sys_size = num_vars * 2\n        r, c = static_rows, static_cols\n        N = num_vars\n        static_rows = np.concatenate([r, r, r + N, r + N])\n        static_cols = np.concatenate([c, c + N, c, c + N])\n        ground_idxs = np.array([0, num_vars], dtype=np.int32)\n\n    # We must include indices for the full leakage diagonal\n    leak_rows = np.arange(sys_size, dtype=np.int32)\n    leak_cols = np.arange(sys_size, dtype=np.int32)\n\n    # Combine Circuit + Ground + Leakage indices\n    full_rows = np.concatenate([static_rows, ground_idxs, leak_rows])\n    full_cols = np.concatenate([static_cols, ground_idxs, leak_cols])\n\n    # Hashing to find unique entries for coalescence\n    rc_hashes = full_rows.astype(np.int64) * sys_size + full_cols.astype(np.int64)\n    unique_hashes, map_indices = np.unique(rc_hashes, return_inverse=True)\n\n    u_rows = (unique_hashes // sys_size).astype(np.int32)\n    u_cols = (unique_hashes % sys_size).astype(np.int32)\n    n_unique = len(unique_hashes)\n\n    return cls(\n        u_rows=jnp.array(u_rows),\n        u_cols=jnp.array(u_cols),\n        map_idx=jnp.array(map_indices),\n        n_unique=n_unique,\n        ground_indices=jnp.array(ground_idxs),\n        sys_size=sys_size,\n        is_complex=is_complex,\n    )\n</code></pre>"},{"location":"references/solvers/#circulax.solvers.KLUSolver.init","title":"init","text":"<pre><code>init(operator: Any, options: Any) -&gt; Any\n</code></pre> <p>Initialize the solver state (No-op for stateless solvers).</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def init(self, operator: Any, options: Any) -&gt; Any:  # noqa: ARG002\n    \"\"\"Initialize the solver state (No-op for stateless solvers).\"\"\"\n    return None\n</code></pre>"},{"location":"references/solvers/#circulax.solvers.KLUSolver.solve_dc","title":"solve_dc","text":"<pre><code>solve_dc(component_groups: dict[str, Any], y_guess: Array) -&gt; Array\n</code></pre> <p>Performs a robust DC Operating Point analysis (Newton-Raphson).</p> <p>This method: 1.  Detects if the system is Real or Complex based on <code>self.is_complex</code>. 2.  Assembles the system with dt=infinity (to open capacitors). 3.  Applies ground constraints (setting specific rows/cols to identity). 4.  Solves the linear system J * delta = -Residual. 5.  Applies voltage damping to prevent exponential overshoot.</p> <p>Parameters:</p> Name Type Description Default <code>component_groups</code> <code>dict</code> <p>The circuit components and their parameters.</p> required <code>y_guess</code> <code>Array</code> <p>Initial guess vector (Shape: [N] or [2N]).</p> required <p>Returns:</p> Type Description <code>Array</code> <p>jax.Array: The converged solution vector (Flat).</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def solve_dc(\n    self, component_groups: dict[str, Any], y_guess: jax.Array\n) -&gt; jax.Array:\n    \"\"\"Performs a robust DC Operating Point analysis (Newton-Raphson).\n\n    This method:\n    1.  Detects if the system is Real or Complex based on `self.is_complex`.\n    2.  Assembles the system with dt=infinity (to open capacitors).\n    3.  Applies ground constraints (setting specific rows/cols to identity).\n    4.  Solves the linear system J * delta = -Residual.\n    5.  Applies voltage damping to prevent exponential overshoot.\n\n    Args:\n        component_groups (dict): The circuit components and their parameters.\n        y_guess (jax.Array): Initial guess vector (Shape: [N] or [2N]).\n\n    Returns:\n        jax.Array: The converged solution vector (Flat).\n\n    \"\"\"\n\n    def dc_step(y: jax.Array, _: Any) -&gt; jax.Array:\n        # 1. Assemble System (dt=1e18 effectively removes time-dependent terms like C*dv/dt)\n        if self.is_complex:\n            total_f, _, all_vals = assemble_system_complex(\n                y, component_groups, t1=0.0, dt=1e18\n            )\n        else:\n            total_f, _, all_vals = assemble_system_real(\n                y, component_groups, t1=0.0, dt=1e18\n            )\n\n        # 2. Apply Ground Constraints to Residual\n        #    We add a massive penalty (1e9 * V) to the residual at ground nodes.\n        #    This forces the solver to drive V -&gt; 0.\n        total_f_grounded = total_f\n        for idx in self.ground_indices:\n            total_f_grounded = total_f_grounded.at[idx].add(1e9 * y[idx])\n\n        # 3. Solve Linear System (J * delta = -R)\n        sol = self._solve_impl(all_vals, -total_f_grounded)\n        delta = sol.value\n\n        # 4. Apply Voltage Limiting (Damping)\n        #    Prevents the solver from taking huge steps that crash exponentials (diodes/transistors).\n        max_change = jnp.max(jnp.abs(delta))\n        damping = jnp.minimum(1.0, 0.5 / (max_change + 1e-9))\n\n        return y + delta * damping\n\n    # 5. Run Newton Loop (Optimistix)\n    solver = optx.FixedPointIteration(rtol=1e-6, atol=1e-6)\n    sol = optx.fixed_point(dc_step, solver, y_guess, max_steps=100, throw=False)\n    return sol.value\n</code></pre>"},{"location":"references/solvers/#circulax.solvers.SparseSolver","title":"SparseSolver","text":"<p>               Bases: <code>CircuitLinearSolver</code></p> <p>Solves the system using JAX's Iterative BiCGStab solver.</p> Best For <ul> <li>Large Transient Simulations on GPU (uses previous step as warm start).</li> <li>Systems where N is too large for Dense, but we need VMAP support.</li> </ul> <p>Attributes:</p> Name Type Description <code>diag_mask</code> <code>Array</code> <p>Mask to extract diagonal elements for preconditioning.</p> <p>Methods:</p> Name Description <code>assume_full_rank</code> <p>Indicate if the solver assumes the operator is full rank.</p> <code>compute</code> <p>Performs the computation of the component for each step.</p> <code>from_circuit</code> <p>Factory method to prepare indices and diagonal mask.</p> <code>init</code> <p>Initialize the solver state (No-op for stateless solvers).</p> <code>solve_dc</code> <p>Performs a robust DC Operating Point analysis (Newton-Raphson).</p>"},{"location":"references/solvers/#circulax.solvers.SparseSolver.assume_full_rank","title":"assume_full_rank","text":"<pre><code>assume_full_rank() -&gt; bool\n</code></pre> <p>Indicate if the solver assumes the operator is full rank.</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def assume_full_rank(self) -&gt; bool:\n    \"\"\"Indicate if the solver assumes the operator is full rank.\"\"\"\n    return False\n</code></pre>"},{"location":"references/solvers/#circulax.solvers.SparseSolver.compute","title":"compute","text":"<pre><code>compute(state: Any, vector: Array, options: Any) -&gt; Solution\n</code></pre> <p>Performs the computation of the component for each step.</p> <p>In our case, we usually call <code>_solve_impl</code> directly to avoid overhead, but this satisfies the API.</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def compute(self, state: Any, vector: jax.Array, options: Any) -&gt; lx.Solution:\n    \"\"\"Performs the computation of the component for each step.\n\n    In our case, we usually call `_solve_impl` directly to avoid overhead,\n    but this satisfies the API.\n\n    \"\"\"\n    msg = \"Directly call _solve_impl for internal use.\"\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"references/solvers/#circulax.solvers.SparseSolver.from_circuit","title":"from_circuit  <code>classmethod</code>","text":"<pre><code>from_circuit(\n    component_groups: dict[str, Any], num_vars: int, *, is_complex: bool = False\n) -&gt; SparseSolver\n</code></pre> <p>Factory method to prepare indices and diagonal mask.</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>@classmethod\ndef from_circuit(\n    cls, component_groups: dict[str, Any], num_vars: int, *, is_complex: bool = False\n) -&gt; \"SparseSolver\":\n    \"\"\"Factory method to prepare indices and diagonal mask.\"\"\"\n    all_rows, all_cols = [], []\n    for k in sorted(component_groups.keys()):\n        g = component_groups[k]\n        all_rows.append(np.array(g.jac_rows).reshape(-1))\n        all_cols.append(np.array(g.jac_cols).reshape(-1))\n\n    static_rows = np.concatenate(all_rows)\n    static_cols = np.concatenate(all_cols)\n\n    sys_size = num_vars\n    ground_idxs = np.array([0], dtype=np.int32)\n\n    if is_complex:\n        sys_size = num_vars * 2\n        r, c = static_rows, static_cols\n        N = num_vars\n        static_rows = np.concatenate([r, r, r + N, r + N])\n        static_cols = np.concatenate([c, c + N, c, c + N])\n        ground_idxs = np.array([0, num_vars], dtype=np.int32)\n\n    # Create mask to identify diagonal elements (row == col) efficiently\n    diag_mask = static_rows == static_cols\n\n    return cls(\n        static_rows=jnp.array(static_rows),\n        static_cols=jnp.array(static_cols),\n        diag_mask=jnp.array(diag_mask),\n        sys_size=sys_size,\n        ground_indices=jnp.array(ground_idxs),\n        is_complex=is_complex,\n    )\n</code></pre>"},{"location":"references/solvers/#circulax.solvers.SparseSolver.init","title":"init","text":"<pre><code>init(operator: Any, options: Any) -&gt; Any\n</code></pre> <p>Initialize the solver state (No-op for stateless solvers).</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def init(self, operator: Any, options: Any) -&gt; Any:  # noqa: ARG002\n    \"\"\"Initialize the solver state (No-op for stateless solvers).\"\"\"\n    return None\n</code></pre>"},{"location":"references/solvers/#circulax.solvers.SparseSolver.solve_dc","title":"solve_dc","text":"<pre><code>solve_dc(component_groups: dict[str, Any], y_guess: Array) -&gt; Array\n</code></pre> <p>Performs a robust DC Operating Point analysis (Newton-Raphson).</p> <p>This method: 1.  Detects if the system is Real or Complex based on <code>self.is_complex</code>. 2.  Assembles the system with dt=infinity (to open capacitors). 3.  Applies ground constraints (setting specific rows/cols to identity). 4.  Solves the linear system J * delta = -Residual. 5.  Applies voltage damping to prevent exponential overshoot.</p> <p>Parameters:</p> Name Type Description Default <code>component_groups</code> <code>dict</code> <p>The circuit components and their parameters.</p> required <code>y_guess</code> <code>Array</code> <p>Initial guess vector (Shape: [N] or [2N]).</p> required <p>Returns:</p> Type Description <code>Array</code> <p>jax.Array: The converged solution vector (Flat).</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def solve_dc(\n    self, component_groups: dict[str, Any], y_guess: jax.Array\n) -&gt; jax.Array:\n    \"\"\"Performs a robust DC Operating Point analysis (Newton-Raphson).\n\n    This method:\n    1.  Detects if the system is Real or Complex based on `self.is_complex`.\n    2.  Assembles the system with dt=infinity (to open capacitors).\n    3.  Applies ground constraints (setting specific rows/cols to identity).\n    4.  Solves the linear system J * delta = -Residual.\n    5.  Applies voltage damping to prevent exponential overshoot.\n\n    Args:\n        component_groups (dict): The circuit components and their parameters.\n        y_guess (jax.Array): Initial guess vector (Shape: [N] or [2N]).\n\n    Returns:\n        jax.Array: The converged solution vector (Flat).\n\n    \"\"\"\n\n    def dc_step(y: jax.Array, _: Any) -&gt; jax.Array:\n        # 1. Assemble System (dt=1e18 effectively removes time-dependent terms like C*dv/dt)\n        if self.is_complex:\n            total_f, _, all_vals = assemble_system_complex(\n                y, component_groups, t1=0.0, dt=1e18\n            )\n        else:\n            total_f, _, all_vals = assemble_system_real(\n                y, component_groups, t1=0.0, dt=1e18\n            )\n\n        # 2. Apply Ground Constraints to Residual\n        #    We add a massive penalty (1e9 * V) to the residual at ground nodes.\n        #    This forces the solver to drive V -&gt; 0.\n        total_f_grounded = total_f\n        for idx in self.ground_indices:\n            total_f_grounded = total_f_grounded.at[idx].add(1e9 * y[idx])\n\n        # 3. Solve Linear System (J * delta = -R)\n        sol = self._solve_impl(all_vals, -total_f_grounded)\n        delta = sol.value\n\n        # 4. Apply Voltage Limiting (Damping)\n        #    Prevents the solver from taking huge steps that crash exponentials (diodes/transistors).\n        max_change = jnp.max(jnp.abs(delta))\n        damping = jnp.minimum(1.0, 0.5 / (max_change + 1e-9))\n\n        return y + delta * damping\n\n    # 5. Run Newton Loop (Optimistix)\n    solver = optx.FixedPointIteration(rtol=1e-6, atol=1e-6)\n    sol = optx.fixed_point(dc_step, solver, y_guess, max_steps=100, throw=False)\n    return sol.value\n</code></pre>"},{"location":"references/solvers/#circulax.solvers.VectorizedTransientSolver","title":"VectorizedTransientSolver","text":"<p>               Bases: <code>AbstractSolver</code></p> <p>Transient solver that works strictly on FLAT (Real) vectors.</p> <p>Delegates complexity handling to the 'linear_solver' strategy.</p>"},{"location":"references/solvers/#circulax.solvers.analyze_circuit","title":"analyze_circuit","text":"<pre><code>analyze_circuit(\n    groups: list, num_vars: int, backend: str = \"default\", *, is_complex: bool = False\n) -&gt; CircuitLinearSolver\n</code></pre> <p>Initializes a linear solver strategy for circuit analysis.</p> <p>This function serves as a factory and wrapper to select and configure the appropriate numerical backend for solving the linear system of equations derived from a circuit's topology.</p> <p>Parameters:</p> Name Type Description Default <code>groups</code> <code>list</code> <p>A list of component groups that define the circuit's structure and properties.</p> required <code>num_vars</code> <code>int</code> <p>The total number of variables in the linear system.</p> required <code>backend</code> <code>str</code> <p>The name of the solver backend to use. Supported backends are 'klu', 'klu_split', 'dense', and 'sparse'. Defaults to 'default', which uses the 'klu' solver.</p> <code>'default'</code> <code>is_complex</code> <code>bool</code> <p>A flag indicating whether the circuit analysis involves complex numbers. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>CircuitLinearSolver</code> <code>CircuitLinearSolver</code> <p>An instance of a circuit linear solver strategy</p> <code>CircuitLinearSolver</code> <p>configured for the specified backend and circuit parameters.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the specified backend is not supported.</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def analyze_circuit(\n    groups: list, num_vars: int, backend: str = \"default\", *, is_complex: bool = False\n) -&gt; CircuitLinearSolver:\n    \"\"\"Initializes a linear solver strategy for circuit analysis.\n\n    This function serves as a factory and wrapper to select and configure the\n    appropriate numerical backend for solving the linear system of equations\n    derived from a circuit's topology.\n\n    Args:\n        groups (list): A list of component groups that define the circuit's\n            structure and properties.\n        num_vars (int): The total number of variables in the linear system.\n        backend (str, optional): The name of the solver backend to use.\n            Supported backends are 'klu', 'klu_split', 'dense', and 'sparse'.\n            Defaults to 'default', which uses the 'klu' solver.\n        is_complex (bool, optional): A flag indicating whether the circuit\n            analysis involves complex numbers. Defaults to False.\n\n    Returns:\n        CircuitLinearSolver: An instance of a circuit linear solver strategy\n        configured for the specified backend and circuit parameters.\n\n    Raises:\n        ValueError: If the specified backend is not supported.\n\n    \"\"\"\n    solver_class = backends.get(backend)\n    if solver_class is None:\n        msg = (\n            f\"Unknown backend: '{backend}'. \"\n            f\"Available backends are {list(backends.keys())}\"\n        )\n        raise ValueError(\n            msg\n        )\n\n    linear_strategy = solver_class.from_circuit(groups, num_vars, is_complex=is_complex)\n\n    return linear_strategy\n</code></pre>"},{"location":"references/solvers/#circulax.solvers.assemble_system_complex","title":"assemble_system_complex","text":"<pre><code>assemble_system_complex(\n    y_guess: Array, component_groups: dict, t1: float, dt: float\n) -&gt; tuple[Array, Array, Array]\n</code></pre> <p>Assemble the residual vectors and effective Jacobian values for an unrolled complex system.</p> <p>The complex state vector is stored in unrolled (block) format: the first half of <code>y_guess</code> holds the real parts of all node voltages/states, the second half holds the imaginary parts. This avoids JAX's limited support for complex-valued sparse linear solvers by keeping all arithmetic real.</p> <p>The Jacobian is split into four real blocks \u2014 RR, RI, IR, II \u2014 representing the partial derivatives of the real and imaginary residual components with respect to the real and imaginary state components respectively. The blocks are concatenated in RR\u2192RI\u2192IR\u2192II order to match the sparsity index layout produced during compilation.</p> <p>Parameters:</p> Name Type Description Default <code>y_guess</code> <code>Array</code> <p>Unrolled state vector of shape <code>(2 * num_vars,)</code>, where <code>y_guess[:num_vars]</code> are real parts and <code>y_guess[num_vars:]</code> are imaginary parts.</p> required <code>component_groups</code> <code>dict</code> <p>Compiled component groups returned by :func:<code>compile_netlist</code>, keyed by group name.</p> required <code>t1</code> <code>float</code> <p>Time at which the system is being evaluated.</p> required <code>dt</code> <code>float</code> <p>Timestep duration, used to scale the reactive Jacobian blocks.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>A three-tuple <code>(total_f, total_q, jac_vals)</code> where:</p> <code>Array</code> <ul> <li>total_f \u2014 assembled resistive residual in unrolled format, shape <code>(2 * num_vars,)</code>.</li> </ul> <code>Array</code> <ul> <li>total_q \u2014 assembled reactive residual in unrolled format, shape <code>(2 * num_vars,)</code>.</li> </ul> <code>tuple[Array, Array, Array]</code> <ul> <li>jac_vals \u2014 concatenated non-zero values of the four effective Jacobian blocks (RR, RI, IR, II) in group-sorted order.</li> </ul> Source code in <code>circulax/solvers/assembly.py</code> <pre><code>def assemble_system_complex(\n    y_guess: Array,\n    component_groups: dict,\n    t1: float,\n    dt: float,\n) -&gt; tuple[Array, Array, Array]:\n    \"\"\"Assemble the residual vectors and effective Jacobian values for an unrolled complex system.\n\n    The complex state vector is stored in unrolled (block) format: the first\n    half of ``y_guess`` holds the real parts of all node voltages/states, the\n    second half holds the imaginary parts. This avoids JAX's limited support\n    for complex-valued sparse linear solvers by keeping all arithmetic real.\n\n    The Jacobian is split into four real blocks \u2014 RR, RI, IR, II \u2014 representing\n    the partial derivatives of the real and imaginary residual components with\n    respect to the real and imaginary state components respectively. The blocks\n    are concatenated in RR\u2192RI\u2192IR\u2192II order to match the sparsity index layout\n    produced during compilation.\n\n    Args:\n        y_guess: Unrolled state vector of shape ``(2 * num_vars,)``, where\n            ``y_guess[:num_vars]`` are real parts and ``y_guess[num_vars:]``\n            are imaginary parts.\n        component_groups: Compiled component groups returned by\n            :func:`compile_netlist`, keyed by group name.\n        t1: Time at which the system is being evaluated.\n        dt: Timestep duration, used to scale the reactive Jacobian blocks.\n\n    Returns:\n        A three-tuple ``(total_f, total_q, jac_vals)`` where:\n\n        - **total_f** \u2014 assembled resistive residual in unrolled format,\n            shape ``(2 * num_vars,)``.\n        - **total_q** \u2014 assembled reactive residual in unrolled format,\n            shape ``(2 * num_vars,)``.\n        - **jac_vals** \u2014 concatenated non-zero values of the four effective\n            Jacobian blocks (RR, RI, IR, II) in group-sorted order.\n\n    \"\"\"\n    sys_size = y_guess.shape[0]\n    half_size = sys_size // 2\n    y_real, y_imag = y_guess[:half_size], y_guess[half_size:]\n\n    total_f = jnp.zeros(sys_size, dtype=jnp.float64)\n    total_q = jnp.zeros(sys_size, dtype=jnp.float64)\n\n    vals_blocks: list[list[Array]] = [[], [], [], []]\n\n    for k in sorted(component_groups.keys()):\n        group = component_groups[k]\n        v_r, v_i = y_real[group.var_indices], y_imag[group.var_indices]\n\n        def physics_split(\n            vr: Array, vi: Array, p: Array\n        ) -&gt; tuple[Array, Array, Array, Array]:\n            v = vr + 1j * vi\n            f, q = group.physics_func(y=v, args=p, t=t1)\n            return f.real, f.imag, q.real, q.imag\n\n        fr, fi, qr, qi = jax.vmap(physics_split)(v_r, v_i, group.params)\n\n        idx_r, idx_i = group.eq_indices, group.eq_indices + half_size\n        total_f = total_f.at[idx_r].add(fr).at[idx_i].add(fi)\n        total_q = total_q.at[idx_r].add(qr).at[idx_i].add(qi)\n\n        jac_res = jax.vmap(jax.jacfwd(physics_split, argnums=(0, 1)))(\n            v_r, v_i, group.params\n        )\n        ((dfr_r, dfr_i), (dfi_r, dfi_i), (dqr_r, dqr_i), (dqi_r, dqi_i)) = jac_res\n\n        vals_blocks[0].append((dfr_r + dqr_r / dt).reshape(-1))  # RR\n        vals_blocks[1].append((dfr_i + dqr_i / dt).reshape(-1))  # RI\n        vals_blocks[2].append((dfi_r + dqi_r / dt).reshape(-1))  # IR\n        vals_blocks[3].append((dfi_i + dqi_i / dt).reshape(-1))  # II\n\n    all_vals = jnp.concatenate([jnp.concatenate(b) for b in vals_blocks])\n    return total_f, total_q, all_vals\n</code></pre>"},{"location":"references/solvers/#circulax.solvers.assemble_system_real","title":"assemble_system_real","text":"<pre><code>assemble_system_real(\n    y_guess: Array, component_groups: dict, t1: float, dt: float\n) -&gt; tuple[Array, Array, Array]\n</code></pre> <p>Assemble the residual vectors and effective Jacobian values for a real system.</p> <p>For each component group, evaluates the physics at <code>t1</code> and computes the forward-mode Jacobian via <code>jax.jacfwd</code>. The effective Jacobian combines the resistive and reactive contributions as <code>J_eff = df/dy + (1/dt) * dq/dy</code>, consistent with the implicit trapezoidal discretisation used by the solver.</p> <p>Components are processed in sorted key order to ensure a deterministic non-zero layout in the sparse Jacobian, which is required for the factorisation step.</p> <p>Parameters:</p> Name Type Description Default <code>y_guess</code> <code>Array</code> <p>Current state vector of shape <code>(sys_size,)</code>.</p> required <code>component_groups</code> <code>dict</code> <p>Compiled component groups returned by :func:<code>compile_netlist</code>, keyed by group name.</p> required <code>t1</code> <code>float</code> <p>Time at which the system is being evaluated.</p> required <code>dt</code> <code>float</code> <p>Timestep duration, used to scale the reactive Jacobian block.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>A three-tuple <code>(total_f, total_q, jac_vals)</code> where:</p> <code>Array</code> <ul> <li>total_f \u2014 assembled resistive residual, shape <code>(sys_size,)</code>.</li> </ul> <code>Array</code> <ul> <li>total_q \u2014 assembled reactive residual, shape <code>(sys_size,)</code>.</li> </ul> <code>tuple[Array, Array, Array]</code> <ul> <li>jac_vals \u2014 concatenated non-zero values of the effective Jacobian in group-sorted order, ready to be passed to the sparse linear solver.</li> </ul> Source code in <code>circulax/solvers/assembly.py</code> <pre><code>def assemble_system_real(\n    y_guess: Array,\n    component_groups: dict,\n    t1: float,\n    dt: float,\n) -&gt; tuple[Array, Array, Array]:\n    \"\"\"Assemble the residual vectors and effective Jacobian values for a real system.\n\n    For each component group, evaluates the physics at ``t1`` and computes the\n    forward-mode Jacobian via ``jax.jacfwd``. The effective Jacobian combines\n    the resistive and reactive contributions as ``J_eff = df/dy + (1/dt) * dq/dy``,\n    consistent with the implicit trapezoidal discretisation used by the solver.\n\n    Components are processed in sorted key order to ensure a deterministic\n    non-zero layout in the sparse Jacobian, which is required for the\n    factorisation step.\n\n    Args:\n        y_guess: Current state vector of shape ``(sys_size,)``.\n        component_groups: Compiled component groups returned by\n            :func:`compile_netlist`, keyed by group name.\n        t1: Time at which the system is being evaluated.\n        dt: Timestep duration, used to scale the reactive Jacobian block.\n\n    Returns:\n        A three-tuple ``(total_f, total_q, jac_vals)`` where:\n\n        - **total_f** \u2014 assembled resistive residual, shape ``(sys_size,)``.\n        - **total_q** \u2014 assembled reactive residual, shape ``(sys_size,)``.\n        - **jac_vals** \u2014 concatenated non-zero values of the effective Jacobian\n            in group-sorted order, ready to be passed to the sparse linear solver.\n\n    \"\"\"\n    sys_size = y_guess.shape[0]\n    total_f = jnp.zeros(sys_size, dtype=y_guess.dtype)\n    total_q = jnp.zeros(sys_size, dtype=y_guess.dtype)\n    vals_list = []\n\n    for k in sorted(component_groups.keys()):\n        group = component_groups[k]\n        v_locs = y_guess[group.var_indices]\n\n        def physics_at_t1(v: Array, p: Array) -&gt; tuple[Array, Array]:\n            return group.physics_func(y=v, args=p, t=t1)\n\n        (f_l, q_l) = jax.vmap(physics_at_t1)(v_locs, group.params)\n        (df_l, dq_l) = jax.vmap(jax.jacfwd(physics_at_t1))(v_locs, group.params)\n\n        total_f = total_f.at[group.eq_indices].add(f_l)\n        total_q = total_q.at[group.eq_indices].add(q_l)\n        j_eff = df_l + (dq_l / dt)\n        vals_list.append(j_eff.reshape(-1))\n\n    return total_f, total_q, jnp.concatenate(vals_list)\n</code></pre>"},{"location":"references/solvers/#circulax.solvers.setup_transient","title":"setup_transient","text":"<pre><code>setup_transient(\n    groups: list,\n    linear_strategy: CircuitLinearSolver,\n    transient_solver: AbstractSolver = None,\n) -&gt; Callable[..., Solution]\n</code></pre> <p>Configures and returns a function for executing transient analysis.</p> <p>This function acts as a factory, preparing a transient solver that is pre-configured with the circuit's linear strategy. It returns a callable that executes the time-domain simulation using <code>diffrax.diffeqsolve</code>.</p> <p>Parameters:</p> Name Type Description Default <code>groups</code> <code>list</code> <p>A list of component groups that define the circuit.</p> required <code>linear_strategy</code> <code>CircuitLinearSolver</code> <p>The configured linear solver strategy, typically obtained from <code>analyze_circuit</code>.</p> required <code>transient_solver</code> <code>optional</code> <p>The transient solver class to use. If None, <code>VectorizedTransientSolver</code> will be used.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[..., Solution]</code> <p>Callable[..., Any]: A function that executes the transient analysis.</p> <code>Callable[..., Solution]</code> <p>This returned function accepts the following arguments:</p> <p>t0 (float): The start time of the simulation. t1 (float): The end time of the simulation. dt0 (float): The initial time step for the solver. y0 (ArrayLike): The initial state vector of the system. saveat (diffrax.SaveAt, optional): Specifies time points at which     to save the solution. Defaults to None. max_steps (int, optional): The maximum number of steps the solver     can take. Defaults to 100000. throw (bool, optional): If True, the solver will raise an error on     failure. Defaults to False. term (diffrax.AbstractTerm, optional): The term defining the ODE.     Defaults to a zero-value ODETerm. stepsize_controller (diffrax.AbstractStepSizeController, optional):     The step size controller. Defaults to <code>ConstantStepSize()</code>. **kwargs: Additional keyword arguments to pass directly to     <code>diffrax.diffeqsolve</code>.</p> Source code in <code>circulax/solvers/transient.py</code> <pre><code>def setup_transient(\n    groups: list,\n    linear_strategy: CircuitLinearSolver,\n    transient_solver:AbstractSolver=None\n) -&gt; Callable[..., diffrax.Solution]:\n    \"\"\"Configures and returns a function for executing transient analysis.\n\n    This function acts as a factory, preparing a transient solver that is\n    pre-configured with the circuit's linear strategy. It returns a callable\n    that executes the time-domain simulation using `diffrax.diffeqsolve`.\n\n    Args:\n        groups (list): A list of component groups that define the circuit.\n        linear_strategy (CircuitLinearSolver): The configured linear solver\n            strategy, typically obtained from `analyze_circuit`.\n        transient_solver (optional): The transient solver class to use.\n            If None, `VectorizedTransientSolver` will be used.\n\n    Returns:\n        Callable[..., Any]: A function that executes the transient analysis.\n        This returned function accepts the following arguments:\n\n            t0 (float): The start time of the simulation.\n            t1 (float): The end time of the simulation.\n            dt0 (float): The initial time step for the solver.\n            y0 (ArrayLike): The initial state vector of the system.\n            saveat (diffrax.SaveAt, optional): Specifies time points at which\n                to save the solution. Defaults to None.\n            max_steps (int, optional): The maximum number of steps the solver\n                can take. Defaults to 100000.\n            throw (bool, optional): If True, the solver will raise an error on\n                failure. Defaults to False.\n            term (diffrax.AbstractTerm, optional): The term defining the ODE.\n                Defaults to a zero-value ODETerm.\n            stepsize_controller (diffrax.AbstractStepSizeController, optional):\n                The step size controller. Defaults to `ConstantStepSize()`.\n            **kwargs: Additional keyword arguments to pass directly to\n                `diffrax.diffeqsolve`.\n\n    \"\"\"\n    if transient_solver is None:\n        transient_solver = VectorizedTransientSolver\n\n    tsolver = transient_solver(linear_solver=linear_strategy)\n\n    sys_size = (\n        linear_strategy.sys_size // 2\n        if linear_strategy.is_complex\n        else linear_strategy.sys_size\n    )\n\n    def _execute_transient(\n        *,\n        t0: float,\n        t1: float,\n        dt0: float,\n        y0: ArrayLike,\n        saveat: diffrax.SaveAt = None,\n        max_steps: int = 100000,\n        throw: bool = False,\n        **kwargs: Any,\n    ) -&gt; diffrax.Solution:\n        \"\"\"Executes the transient simulation for the pre-configured circuit.\"\"\"\n        term = kwargs.pop(\"term\", diffrax.ODETerm(lambda t, y, args: jnp.zeros_like(y)))\n        solver = kwargs.pop(\"solver\", tsolver)\n        args = kwargs.pop(\"args\", (groups, sys_size))\n        stepsize_controller = kwargs.pop(\"stepsize_controller\", ConstantStepSize())\n\n        sol = diffrax.diffeqsolve(\n            terms=term,\n            solver=solver,\n            t0=t0,\n            t1=t1,\n            dt0=dt0,\n            y0=y0,\n            args=args,\n            saveat=saveat,\n            max_steps=max_steps,\n            throw=throw,\n            stepsize_controller=stepsize_controller,\n            **kwargs,\n        )\n\n        return sol\n\n    return _execute_transient\n</code></pre>"},{"location":"references/solvers/assembly/","title":"Assembly","text":""},{"location":"references/solvers/assembly/#circulax.solvers.assembly","title":"assembly","text":"<p>Assembly functions for the transient circuit solver.</p> <p>Provides functions for evaluating the residual vectors and effective Jacobian of the discretised circuit equations at each Newton iteration. Functions are provided in two variants:</p> <ul> <li> <p>Full assembly (:func:<code>assemble_system_real</code>, :func:<code>assemble_system_complex</code>)   \u2014 evaluates both the residual and the forward-mode Jacobian via   <code>jax.jacfwd</code>. Used once per timestep to assemble and factor the frozen   Jacobian in :class:<code>~circulax.solver.FactorizedTransientSolver</code>.</p> </li> <li> <p>Residual only (:func:<code>assemble_residual_only_real</code>,   :func:<code>assemble_residual_only_complex</code>) \u2014 evaluates only the primal   residual, with no Jacobian computation. Used inside the Newton loop where   the Jacobian has already been factored and only needs to be applied.</p> </li> </ul> <p>Each pair has a real and a complex variant. The complex variant operates on state vectors in unrolled block format \u2014 real parts concatenated with imaginary parts \u2014 allowing complex circuit analyses to reuse real-valued sparse linear algebra kernels.</p> <p>Functions:</p> Name Description <code>assemble_residual_only_complex</code> <p>Assemble the residual vectors for an unrolled complex system, without computing the Jacobian.</p> <code>assemble_residual_only_real</code> <p>Assemble the residual vectors for a real system, without computing the Jacobian.</p> <code>assemble_system_complex</code> <p>Assemble the residual vectors and effective Jacobian values for an unrolled complex system.</p> <code>assemble_system_real</code> <p>Assemble the residual vectors and effective Jacobian values for a real system.</p>"},{"location":"references/solvers/assembly/#circulax.solvers.assembly.assemble_residual_only_complex","title":"assemble_residual_only_complex","text":"<pre><code>assemble_residual_only_complex(\n    y_guess: Array, component_groups: dict, t1: float, dt: float\n) -&gt; tuple[Array, Array]\n</code></pre> <p>Assemble the residual vectors for an unrolled complex system, without computing the Jacobian.</p> <p>The complex counterpart of :func:<code>assemble_residual_only_real</code>. The state vector is expected in unrolled block format (real parts followed by imaginary parts) matching the layout used by :func:<code>assemble_system_complex</code>.</p> <p>Parameters:</p> Name Type Description Default <code>y_guess</code> <code>Array</code> <p>Unrolled state vector of shape <code>(2 * num_vars,)</code>.</p> required <code>component_groups</code> <code>dict</code> <p>Compiled component groups returned by :func:<code>compile_netlist</code>, keyed by group name.</p> required <code>t1</code> <code>float</code> <p>Time at which the system is being evaluated.</p> required <code>dt</code> <code>float</code> <p>Unused; present for signature symmetry with :func:<code>assemble_system_complex</code> so the two functions are interchangeable at call sites.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>A two-tuple <code>(total_f, total_q)</code> where both arrays have shape</p> <code>Array</code> <p><code>(2 * num_vars,)</code> and <code>dtype=float64</code>.</p> Source code in <code>circulax/solvers/assembly.py</code> <pre><code>def assemble_residual_only_complex(\n    y_guess: Array,\n    component_groups: dict,\n    t1: float,\n    dt: float,\n) -&gt; tuple[Array, Array]:\n    \"\"\"Assemble the residual vectors for an unrolled complex system, without computing the Jacobian.\n\n    The complex counterpart of :func:`assemble_residual_only_real`. The state\n    vector is expected in unrolled block format (real parts followed by imaginary\n    parts) matching the layout used by :func:`assemble_system_complex`.\n\n    Args:\n        y_guess: Unrolled state vector of shape ``(2 * num_vars,)``.\n        component_groups: Compiled component groups returned by\n            :func:`compile_netlist`, keyed by group name.\n        t1: Time at which the system is being evaluated.\n        dt: Unused; present for signature symmetry with\n            :func:`assemble_system_complex` so the two functions are\n            interchangeable at call sites.\n\n    Returns:\n        A two-tuple ``(total_f, total_q)`` where both arrays have shape\n        ``(2 * num_vars,)`` and ``dtype=float64``.\n\n    \"\"\"\n    sys_size = y_guess.shape[0]\n    half_size = sys_size // 2\n    y_real, y_imag = y_guess[:half_size], y_guess[half_size:]\n\n    total_f = jnp.zeros(sys_size, dtype=jnp.float64)\n    total_q = jnp.zeros(sys_size, dtype=jnp.float64)\n\n    for k in sorted(component_groups.keys()):\n        group = component_groups[k]\n        v_r, v_i = y_real[group.var_indices], y_imag[group.var_indices]\n\n        def physics_split(\n            vr: Array, vi: Array, p: Array\n        ) -&gt; tuple[Array, Array, Array, Array]:\n            v = vr + 1j * vi\n            f, q = group.physics_func(y=v, args=p, t=t1)\n            return f.real, f.imag, q.real, q.imag\n\n        fr, fi, qr, qi = jax.vmap(physics_split)(v_r, v_i, group.params)\n\n        idx_r, idx_i = group.eq_indices, group.eq_indices + half_size\n        total_f = total_f.at[idx_r].add(fr).at[idx_i].add(fi)\n        total_q = total_q.at[idx_r].add(qr).at[idx_i].add(qi)\n\n    return total_f, total_q\n</code></pre>"},{"location":"references/solvers/assembly/#circulax.solvers.assembly.assemble_residual_only_real","title":"assemble_residual_only_real","text":"<pre><code>assemble_residual_only_real(\n    y_guess: Array, component_groups: dict, t1: float, dt: float\n) -&gt; tuple[Array, Array]\n</code></pre> <p>Assemble the residual vectors for a real system, without computing the Jacobian.</p> <p>Cheaper than :func:<code>assemble_system_real</code> as it performs only primal evaluations. Used inside the frozen-Jacobian Newton loop where the Jacobian has already been factored and only the residual needs to be recomputed at each iteration.</p> <p>Parameters:</p> Name Type Description Default <code>y_guess</code> <code>Array</code> <p>Current state vector of shape <code>(sys_size,)</code>.</p> required <code>component_groups</code> <code>dict</code> <p>Compiled component groups returned by :func:<code>compile_netlist</code>, keyed by group name.</p> required <code>t1</code> <code>float</code> <p>Time at which the system is being evaluated.</p> required <code>dt</code> <code>float</code> <p>Unused; present for signature symmetry with :func:<code>assemble_system_real</code> so the two functions are interchangeable at call sites.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>A two-tuple <code>(total_f, total_q)</code> where both arrays have shape</p> <code>Array</code> <p><code>(sys_size,)</code> and <code>dtype=float64</code>.</p> Source code in <code>circulax/solvers/assembly.py</code> <pre><code>def assemble_residual_only_real(\n    y_guess: Array,\n    component_groups: dict,\n    t1: float,\n    dt: float,\n) -&gt; tuple[Array, Array]:\n    \"\"\"Assemble the residual vectors for a real system, without computing the Jacobian.\n\n    Cheaper than :func:`assemble_system_real` as it performs only primal\n    evaluations. Used inside the frozen-Jacobian Newton loop where the\n    Jacobian has already been factored and only the residual needs to be\n    recomputed at each iteration.\n\n    Args:\n        y_guess: Current state vector of shape ``(sys_size,)``.\n        component_groups: Compiled component groups returned by\n            :func:`compile_netlist`, keyed by group name.\n        t1: Time at which the system is being evaluated.\n        dt: Unused; present for signature symmetry with\n            :func:`assemble_system_real` so the two functions are\n            interchangeable at call sites.\n\n    Returns:\n        A two-tuple ``(total_f, total_q)`` where both arrays have shape\n        ``(sys_size,)`` and ``dtype=float64``.\n\n    \"\"\"\n    sys_size = y_guess.shape[0]\n    total_f = jnp.zeros(sys_size, dtype=jnp.float64)\n    total_q = jnp.zeros(sys_size, dtype=jnp.float64)\n\n    for k in sorted(component_groups.keys()):\n        group = component_groups[k]\n        v = y_guess[group.var_indices]\n\n        def physics_at_t1(v: Array, p: Array) -&gt; tuple[Array, Array]:\n            return group.physics_func(y=v, args=p, t=t1)\n\n        f_l, q_l = jax.vmap(physics_at_t1)(v, group.params)\n\n        total_f = total_f.at[group.eq_indices].add(f_l)\n        total_q = total_q.at[group.eq_indices].add(q_l)\n\n    return total_f, total_q\n</code></pre>"},{"location":"references/solvers/assembly/#circulax.solvers.assembly.assemble_system_complex","title":"assemble_system_complex","text":"<pre><code>assemble_system_complex(\n    y_guess: Array, component_groups: dict, t1: float, dt: float\n) -&gt; tuple[Array, Array, Array]\n</code></pre> <p>Assemble the residual vectors and effective Jacobian values for an unrolled complex system.</p> <p>The complex state vector is stored in unrolled (block) format: the first half of <code>y_guess</code> holds the real parts of all node voltages/states, the second half holds the imaginary parts. This avoids JAX's limited support for complex-valued sparse linear solvers by keeping all arithmetic real.</p> <p>The Jacobian is split into four real blocks \u2014 RR, RI, IR, II \u2014 representing the partial derivatives of the real and imaginary residual components with respect to the real and imaginary state components respectively. The blocks are concatenated in RR\u2192RI\u2192IR\u2192II order to match the sparsity index layout produced during compilation.</p> <p>Parameters:</p> Name Type Description Default <code>y_guess</code> <code>Array</code> <p>Unrolled state vector of shape <code>(2 * num_vars,)</code>, where <code>y_guess[:num_vars]</code> are real parts and <code>y_guess[num_vars:]</code> are imaginary parts.</p> required <code>component_groups</code> <code>dict</code> <p>Compiled component groups returned by :func:<code>compile_netlist</code>, keyed by group name.</p> required <code>t1</code> <code>float</code> <p>Time at which the system is being evaluated.</p> required <code>dt</code> <code>float</code> <p>Timestep duration, used to scale the reactive Jacobian blocks.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>A three-tuple <code>(total_f, total_q, jac_vals)</code> where:</p> <code>Array</code> <ul> <li>total_f \u2014 assembled resistive residual in unrolled format, shape <code>(2 * num_vars,)</code>.</li> </ul> <code>Array</code> <ul> <li>total_q \u2014 assembled reactive residual in unrolled format, shape <code>(2 * num_vars,)</code>.</li> </ul> <code>tuple[Array, Array, Array]</code> <ul> <li>jac_vals \u2014 concatenated non-zero values of the four effective Jacobian blocks (RR, RI, IR, II) in group-sorted order.</li> </ul> Source code in <code>circulax/solvers/assembly.py</code> <pre><code>def assemble_system_complex(\n    y_guess: Array,\n    component_groups: dict,\n    t1: float,\n    dt: float,\n) -&gt; tuple[Array, Array, Array]:\n    \"\"\"Assemble the residual vectors and effective Jacobian values for an unrolled complex system.\n\n    The complex state vector is stored in unrolled (block) format: the first\n    half of ``y_guess`` holds the real parts of all node voltages/states, the\n    second half holds the imaginary parts. This avoids JAX's limited support\n    for complex-valued sparse linear solvers by keeping all arithmetic real.\n\n    The Jacobian is split into four real blocks \u2014 RR, RI, IR, II \u2014 representing\n    the partial derivatives of the real and imaginary residual components with\n    respect to the real and imaginary state components respectively. The blocks\n    are concatenated in RR\u2192RI\u2192IR\u2192II order to match the sparsity index layout\n    produced during compilation.\n\n    Args:\n        y_guess: Unrolled state vector of shape ``(2 * num_vars,)``, where\n            ``y_guess[:num_vars]`` are real parts and ``y_guess[num_vars:]``\n            are imaginary parts.\n        component_groups: Compiled component groups returned by\n            :func:`compile_netlist`, keyed by group name.\n        t1: Time at which the system is being evaluated.\n        dt: Timestep duration, used to scale the reactive Jacobian blocks.\n\n    Returns:\n        A three-tuple ``(total_f, total_q, jac_vals)`` where:\n\n        - **total_f** \u2014 assembled resistive residual in unrolled format,\n            shape ``(2 * num_vars,)``.\n        - **total_q** \u2014 assembled reactive residual in unrolled format,\n            shape ``(2 * num_vars,)``.\n        - **jac_vals** \u2014 concatenated non-zero values of the four effective\n            Jacobian blocks (RR, RI, IR, II) in group-sorted order.\n\n    \"\"\"\n    sys_size = y_guess.shape[0]\n    half_size = sys_size // 2\n    y_real, y_imag = y_guess[:half_size], y_guess[half_size:]\n\n    total_f = jnp.zeros(sys_size, dtype=jnp.float64)\n    total_q = jnp.zeros(sys_size, dtype=jnp.float64)\n\n    vals_blocks: list[list[Array]] = [[], [], [], []]\n\n    for k in sorted(component_groups.keys()):\n        group = component_groups[k]\n        v_r, v_i = y_real[group.var_indices], y_imag[group.var_indices]\n\n        def physics_split(\n            vr: Array, vi: Array, p: Array\n        ) -&gt; tuple[Array, Array, Array, Array]:\n            v = vr + 1j * vi\n            f, q = group.physics_func(y=v, args=p, t=t1)\n            return f.real, f.imag, q.real, q.imag\n\n        fr, fi, qr, qi = jax.vmap(physics_split)(v_r, v_i, group.params)\n\n        idx_r, idx_i = group.eq_indices, group.eq_indices + half_size\n        total_f = total_f.at[idx_r].add(fr).at[idx_i].add(fi)\n        total_q = total_q.at[idx_r].add(qr).at[idx_i].add(qi)\n\n        jac_res = jax.vmap(jax.jacfwd(physics_split, argnums=(0, 1)))(\n            v_r, v_i, group.params\n        )\n        ((dfr_r, dfr_i), (dfi_r, dfi_i), (dqr_r, dqr_i), (dqi_r, dqi_i)) = jac_res\n\n        vals_blocks[0].append((dfr_r + dqr_r / dt).reshape(-1))  # RR\n        vals_blocks[1].append((dfr_i + dqr_i / dt).reshape(-1))  # RI\n        vals_blocks[2].append((dfi_r + dqi_r / dt).reshape(-1))  # IR\n        vals_blocks[3].append((dfi_i + dqi_i / dt).reshape(-1))  # II\n\n    all_vals = jnp.concatenate([jnp.concatenate(b) for b in vals_blocks])\n    return total_f, total_q, all_vals\n</code></pre>"},{"location":"references/solvers/assembly/#circulax.solvers.assembly.assemble_system_real","title":"assemble_system_real","text":"<pre><code>assemble_system_real(\n    y_guess: Array, component_groups: dict, t1: float, dt: float\n) -&gt; tuple[Array, Array, Array]\n</code></pre> <p>Assemble the residual vectors and effective Jacobian values for a real system.</p> <p>For each component group, evaluates the physics at <code>t1</code> and computes the forward-mode Jacobian via <code>jax.jacfwd</code>. The effective Jacobian combines the resistive and reactive contributions as <code>J_eff = df/dy + (1/dt) * dq/dy</code>, consistent with the implicit trapezoidal discretisation used by the solver.</p> <p>Components are processed in sorted key order to ensure a deterministic non-zero layout in the sparse Jacobian, which is required for the factorisation step.</p> <p>Parameters:</p> Name Type Description Default <code>y_guess</code> <code>Array</code> <p>Current state vector of shape <code>(sys_size,)</code>.</p> required <code>component_groups</code> <code>dict</code> <p>Compiled component groups returned by :func:<code>compile_netlist</code>, keyed by group name.</p> required <code>t1</code> <code>float</code> <p>Time at which the system is being evaluated.</p> required <code>dt</code> <code>float</code> <p>Timestep duration, used to scale the reactive Jacobian block.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>A three-tuple <code>(total_f, total_q, jac_vals)</code> where:</p> <code>Array</code> <ul> <li>total_f \u2014 assembled resistive residual, shape <code>(sys_size,)</code>.</li> </ul> <code>Array</code> <ul> <li>total_q \u2014 assembled reactive residual, shape <code>(sys_size,)</code>.</li> </ul> <code>tuple[Array, Array, Array]</code> <ul> <li>jac_vals \u2014 concatenated non-zero values of the effective Jacobian in group-sorted order, ready to be passed to the sparse linear solver.</li> </ul> Source code in <code>circulax/solvers/assembly.py</code> <pre><code>def assemble_system_real(\n    y_guess: Array,\n    component_groups: dict,\n    t1: float,\n    dt: float,\n) -&gt; tuple[Array, Array, Array]:\n    \"\"\"Assemble the residual vectors and effective Jacobian values for a real system.\n\n    For each component group, evaluates the physics at ``t1`` and computes the\n    forward-mode Jacobian via ``jax.jacfwd``. The effective Jacobian combines\n    the resistive and reactive contributions as ``J_eff = df/dy + (1/dt) * dq/dy``,\n    consistent with the implicit trapezoidal discretisation used by the solver.\n\n    Components are processed in sorted key order to ensure a deterministic\n    non-zero layout in the sparse Jacobian, which is required for the\n    factorisation step.\n\n    Args:\n        y_guess: Current state vector of shape ``(sys_size,)``.\n        component_groups: Compiled component groups returned by\n            :func:`compile_netlist`, keyed by group name.\n        t1: Time at which the system is being evaluated.\n        dt: Timestep duration, used to scale the reactive Jacobian block.\n\n    Returns:\n        A three-tuple ``(total_f, total_q, jac_vals)`` where:\n\n        - **total_f** \u2014 assembled resistive residual, shape ``(sys_size,)``.\n        - **total_q** \u2014 assembled reactive residual, shape ``(sys_size,)``.\n        - **jac_vals** \u2014 concatenated non-zero values of the effective Jacobian\n            in group-sorted order, ready to be passed to the sparse linear solver.\n\n    \"\"\"\n    sys_size = y_guess.shape[0]\n    total_f = jnp.zeros(sys_size, dtype=y_guess.dtype)\n    total_q = jnp.zeros(sys_size, dtype=y_guess.dtype)\n    vals_list = []\n\n    for k in sorted(component_groups.keys()):\n        group = component_groups[k]\n        v_locs = y_guess[group.var_indices]\n\n        def physics_at_t1(v: Array, p: Array) -&gt; tuple[Array, Array]:\n            return group.physics_func(y=v, args=p, t=t1)\n\n        (f_l, q_l) = jax.vmap(physics_at_t1)(v_locs, group.params)\n        (df_l, dq_l) = jax.vmap(jax.jacfwd(physics_at_t1))(v_locs, group.params)\n\n        total_f = total_f.at[group.eq_indices].add(f_l)\n        total_q = total_q.at[group.eq_indices].add(q_l)\n        j_eff = df_l + (dq_l / dt)\n        vals_list.append(j_eff.reshape(-1))\n\n    return total_f, total_q, jnp.concatenate(vals_list)\n</code></pre>"},{"location":"references/solvers/linear/","title":"Linear","text":""},{"location":"references/solvers/linear/#circulax.solvers.linear","title":"linear","text":"<p>Circuit Linear Solvers Strategy Pattern.</p> <p>This module defines the linear algebra strategies used by the circuit simulator. It leverages the <code>lineax</code> abstract base class to provide interchangeable solvers that work seamlessly with JAX transformations (JIT, VMAP, GRAD).</p>"},{"location":"references/solvers/linear/#circulax.solvers.linear--architecture","title":"Architecture","text":"<p>The core idea is to separate the physics assembly (calculating Jacobian values) from the linear solve (inverting the Jacobian).</p> <p>Classes:</p> Name Description <code>CircuitLinearSolver</code> <p>Abstract base defining the interface and common DC logic.</p> <code>DenseSolver</code> <p>Uses JAX's native dense solver (LU decomposition). Best for small circuits (N &lt; 2000) &amp; GPU.</p> <code>KLUSolver</code> <p>Uses the KLU sparse solver (via <code>klujax</code>). Best for large circuits on CPU.</p> <code>SparseSolver</code> <p>Uses JAX's iterative BiCGStab. Best for large transient simulations on GPU.</p> <p>Functions:</p> Name Description <code>analyze_circuit</code> <p>Initializes a linear solver strategy for circuit analysis.</p>"},{"location":"references/solvers/linear/#circulax.solvers.linear.CircuitLinearSolver","title":"CircuitLinearSolver","text":"<p>               Bases: <code>AbstractLinearSolver</code></p> <p>Abstract Base Class for all circuit linear solvers.</p> <p>This class provides the unified interface for: 1.  Storing static matrix structure (indices, rows, cols). 2.  Handling Real vs. Complex-Unrolled system configurations. 3.  Providing a robust Newton-Raphson DC Operating Point solver.</p> <p>Attributes:</p> Name Type Description <code>ground_indices</code> <code>Array</code> <p>Indices of nodes connected to ground (forced to 0V).</p> <code>is_complex</code> <code>bool</code> <p>Static flag. If True, the system is 2N x 2N (Real/Imag unrolled).                If False, the system is N x N (Real).</p> <p>Methods:</p> Name Description <code>assume_full_rank</code> <p>Indicate if the solver assumes the operator is full rank.</p> <code>compute</code> <p>Performs the computation of the component for each step.</p> <code>init</code> <p>Initialize the solver state (No-op for stateless solvers).</p> <code>solve_dc</code> <p>Performs a robust DC Operating Point analysis (Newton-Raphson).</p>"},{"location":"references/solvers/linear/#circulax.solvers.linear.CircuitLinearSolver.assume_full_rank","title":"assume_full_rank","text":"<pre><code>assume_full_rank() -&gt; bool\n</code></pre> <p>Indicate if the solver assumes the operator is full rank.</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def assume_full_rank(self) -&gt; bool:\n    \"\"\"Indicate if the solver assumes the operator is full rank.\"\"\"\n    return False\n</code></pre>"},{"location":"references/solvers/linear/#circulax.solvers.linear.CircuitLinearSolver.compute","title":"compute","text":"<pre><code>compute(state: Any, vector: Array, options: Any) -&gt; Solution\n</code></pre> <p>Performs the computation of the component for each step.</p> <p>In our case, we usually call <code>_solve_impl</code> directly to avoid overhead, but this satisfies the API.</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def compute(self, state: Any, vector: jax.Array, options: Any) -&gt; lx.Solution:\n    \"\"\"Performs the computation of the component for each step.\n\n    In our case, we usually call `_solve_impl` directly to avoid overhead,\n    but this satisfies the API.\n\n    \"\"\"\n    msg = \"Directly call _solve_impl for internal use.\"\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"references/solvers/linear/#circulax.solvers.linear.CircuitLinearSolver.init","title":"init","text":"<pre><code>init(operator: Any, options: Any) -&gt; Any\n</code></pre> <p>Initialize the solver state (No-op for stateless solvers).</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def init(self, operator: Any, options: Any) -&gt; Any:  # noqa: ARG002\n    \"\"\"Initialize the solver state (No-op for stateless solvers).\"\"\"\n    return None\n</code></pre>"},{"location":"references/solvers/linear/#circulax.solvers.linear.CircuitLinearSolver.solve_dc","title":"solve_dc","text":"<pre><code>solve_dc(component_groups: dict[str, Any], y_guess: Array) -&gt; Array\n</code></pre> <p>Performs a robust DC Operating Point analysis (Newton-Raphson).</p> <p>This method: 1.  Detects if the system is Real or Complex based on <code>self.is_complex</code>. 2.  Assembles the system with dt=infinity (to open capacitors). 3.  Applies ground constraints (setting specific rows/cols to identity). 4.  Solves the linear system J * delta = -Residual. 5.  Applies voltage damping to prevent exponential overshoot.</p> <p>Parameters:</p> Name Type Description Default <code>component_groups</code> <code>dict</code> <p>The circuit components and their parameters.</p> required <code>y_guess</code> <code>Array</code> <p>Initial guess vector (Shape: [N] or [2N]).</p> required <p>Returns:</p> Type Description <code>Array</code> <p>jax.Array: The converged solution vector (Flat).</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def solve_dc(\n    self, component_groups: dict[str, Any], y_guess: jax.Array\n) -&gt; jax.Array:\n    \"\"\"Performs a robust DC Operating Point analysis (Newton-Raphson).\n\n    This method:\n    1.  Detects if the system is Real or Complex based on `self.is_complex`.\n    2.  Assembles the system with dt=infinity (to open capacitors).\n    3.  Applies ground constraints (setting specific rows/cols to identity).\n    4.  Solves the linear system J * delta = -Residual.\n    5.  Applies voltage damping to prevent exponential overshoot.\n\n    Args:\n        component_groups (dict): The circuit components and their parameters.\n        y_guess (jax.Array): Initial guess vector (Shape: [N] or [2N]).\n\n    Returns:\n        jax.Array: The converged solution vector (Flat).\n\n    \"\"\"\n\n    def dc_step(y: jax.Array, _: Any) -&gt; jax.Array:\n        # 1. Assemble System (dt=1e18 effectively removes time-dependent terms like C*dv/dt)\n        if self.is_complex:\n            total_f, _, all_vals = assemble_system_complex(\n                y, component_groups, t1=0.0, dt=1e18\n            )\n        else:\n            total_f, _, all_vals = assemble_system_real(\n                y, component_groups, t1=0.0, dt=1e18\n            )\n\n        # 2. Apply Ground Constraints to Residual\n        #    We add a massive penalty (1e9 * V) to the residual at ground nodes.\n        #    This forces the solver to drive V -&gt; 0.\n        total_f_grounded = total_f\n        for idx in self.ground_indices:\n            total_f_grounded = total_f_grounded.at[idx].add(1e9 * y[idx])\n\n        # 3. Solve Linear System (J * delta = -R)\n        sol = self._solve_impl(all_vals, -total_f_grounded)\n        delta = sol.value\n\n        # 4. Apply Voltage Limiting (Damping)\n        #    Prevents the solver from taking huge steps that crash exponentials (diodes/transistors).\n        max_change = jnp.max(jnp.abs(delta))\n        damping = jnp.minimum(1.0, 0.5 / (max_change + 1e-9))\n\n        return y + delta * damping\n\n    # 5. Run Newton Loop (Optimistix)\n    solver = optx.FixedPointIteration(rtol=1e-6, atol=1e-6)\n    sol = optx.fixed_point(dc_step, solver, y_guess, max_steps=100, throw=False)\n    return sol.value\n</code></pre>"},{"location":"references/solvers/linear/#circulax.solvers.linear.DenseSolver","title":"DenseSolver","text":"<p>               Bases: <code>CircuitLinearSolver</code></p> <p>Solves the system using dense matrix factorization (LU).</p> Best For <ul> <li>Small to Medium circuits (N &lt; 2000).</li> <li>Wavelength sweeps (AC Analysis) on GPU.</li> <li>Systems where VMAP parallelism is critical.</li> </ul> <p>Attributes:</p> Name Type Description <code>static_rows</code> <code>Array</code> <p>Row indices for placing values into dense matrix.</p> <code>static_cols</code> <code>Array</code> <p>Column indices.</p> <code>g_leak</code> <code>float</code> <p>Leakage conductance added to diagonal to prevent singularity.</p> <p>Methods:</p> Name Description <code>assume_full_rank</code> <p>Indicate if the solver assumes the operator is full rank.</p> <code>compute</code> <p>Performs the computation of the component for each step.</p> <code>from_circuit</code> <p>Factory method to pre-calculate indices for the dense matrix.</p> <code>init</code> <p>Initialize the solver state (No-op for stateless solvers).</p> <code>solve_dc</code> <p>Performs a robust DC Operating Point analysis (Newton-Raphson).</p>"},{"location":"references/solvers/linear/#circulax.solvers.linear.DenseSolver.assume_full_rank","title":"assume_full_rank","text":"<pre><code>assume_full_rank() -&gt; bool\n</code></pre> <p>Indicate if the solver assumes the operator is full rank.</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def assume_full_rank(self) -&gt; bool:\n    \"\"\"Indicate if the solver assumes the operator is full rank.\"\"\"\n    return False\n</code></pre>"},{"location":"references/solvers/linear/#circulax.solvers.linear.DenseSolver.compute","title":"compute","text":"<pre><code>compute(state: Any, vector: Array, options: Any) -&gt; Solution\n</code></pre> <p>Performs the computation of the component for each step.</p> <p>In our case, we usually call <code>_solve_impl</code> directly to avoid overhead, but this satisfies the API.</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def compute(self, state: Any, vector: jax.Array, options: Any) -&gt; lx.Solution:\n    \"\"\"Performs the computation of the component for each step.\n\n    In our case, we usually call `_solve_impl` directly to avoid overhead,\n    but this satisfies the API.\n\n    \"\"\"\n    msg = \"Directly call _solve_impl for internal use.\"\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"references/solvers/linear/#circulax.solvers.linear.DenseSolver.from_circuit","title":"from_circuit  <code>classmethod</code>","text":"<pre><code>from_circuit(\n    component_groups: dict[str, Any], num_vars: int, *, is_complex: bool = False\n) -&gt; DenseSolver\n</code></pre> <p>Factory method to pre-calculate indices for the dense matrix.</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>@classmethod\ndef from_circuit(\n    cls, component_groups: dict[str, Any], num_vars: int, *, is_complex: bool = False\n) -&gt; \"DenseSolver\":\n    \"\"\"Factory method to pre-calculate indices for the dense matrix.\"\"\"\n    all_rows, all_cols = [], []\n    for k in sorted(component_groups.keys()):\n        g = component_groups[k]\n        all_rows.append(np.array(g.jac_rows).reshape(-1))\n        all_cols.append(np.array(g.jac_cols).reshape(-1))\n\n    static_rows = np.concatenate(all_rows)\n    static_cols = np.concatenate(all_cols)\n\n    sys_size = num_vars\n    ground_idxs = np.array([0], dtype=np.int32)\n\n    if is_complex:\n        # Expand to 2N x 2N Block Structure:\n        # [ RR  RI ]\n        # [ IR  II ]\n        sys_size = num_vars * 2\n        r, c = static_rows, static_cols\n        N = num_vars\n\n        static_rows = np.concatenate([r, r, r + N, r + N])\n        static_cols = np.concatenate([c, c + N, c, c + N])\n        ground_idxs = np.array([0, num_vars], dtype=np.int32)\n\n    return cls(\n        static_rows=jnp.array(static_rows),\n        static_cols=jnp.array(static_cols),\n        sys_size=sys_size,\n        ground_indices=jnp.array(ground_idxs),\n        is_complex=is_complex,\n    )\n</code></pre>"},{"location":"references/solvers/linear/#circulax.solvers.linear.DenseSolver.init","title":"init","text":"<pre><code>init(operator: Any, options: Any) -&gt; Any\n</code></pre> <p>Initialize the solver state (No-op for stateless solvers).</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def init(self, operator: Any, options: Any) -&gt; Any:  # noqa: ARG002\n    \"\"\"Initialize the solver state (No-op for stateless solvers).\"\"\"\n    return None\n</code></pre>"},{"location":"references/solvers/linear/#circulax.solvers.linear.DenseSolver.solve_dc","title":"solve_dc","text":"<pre><code>solve_dc(component_groups: dict[str, Any], y_guess: Array) -&gt; Array\n</code></pre> <p>Performs a robust DC Operating Point analysis (Newton-Raphson).</p> <p>This method: 1.  Detects if the system is Real or Complex based on <code>self.is_complex</code>. 2.  Assembles the system with dt=infinity (to open capacitors). 3.  Applies ground constraints (setting specific rows/cols to identity). 4.  Solves the linear system J * delta = -Residual. 5.  Applies voltage damping to prevent exponential overshoot.</p> <p>Parameters:</p> Name Type Description Default <code>component_groups</code> <code>dict</code> <p>The circuit components and their parameters.</p> required <code>y_guess</code> <code>Array</code> <p>Initial guess vector (Shape: [N] or [2N]).</p> required <p>Returns:</p> Type Description <code>Array</code> <p>jax.Array: The converged solution vector (Flat).</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def solve_dc(\n    self, component_groups: dict[str, Any], y_guess: jax.Array\n) -&gt; jax.Array:\n    \"\"\"Performs a robust DC Operating Point analysis (Newton-Raphson).\n\n    This method:\n    1.  Detects if the system is Real or Complex based on `self.is_complex`.\n    2.  Assembles the system with dt=infinity (to open capacitors).\n    3.  Applies ground constraints (setting specific rows/cols to identity).\n    4.  Solves the linear system J * delta = -Residual.\n    5.  Applies voltage damping to prevent exponential overshoot.\n\n    Args:\n        component_groups (dict): The circuit components and their parameters.\n        y_guess (jax.Array): Initial guess vector (Shape: [N] or [2N]).\n\n    Returns:\n        jax.Array: The converged solution vector (Flat).\n\n    \"\"\"\n\n    def dc_step(y: jax.Array, _: Any) -&gt; jax.Array:\n        # 1. Assemble System (dt=1e18 effectively removes time-dependent terms like C*dv/dt)\n        if self.is_complex:\n            total_f, _, all_vals = assemble_system_complex(\n                y, component_groups, t1=0.0, dt=1e18\n            )\n        else:\n            total_f, _, all_vals = assemble_system_real(\n                y, component_groups, t1=0.0, dt=1e18\n            )\n\n        # 2. Apply Ground Constraints to Residual\n        #    We add a massive penalty (1e9 * V) to the residual at ground nodes.\n        #    This forces the solver to drive V -&gt; 0.\n        total_f_grounded = total_f\n        for idx in self.ground_indices:\n            total_f_grounded = total_f_grounded.at[idx].add(1e9 * y[idx])\n\n        # 3. Solve Linear System (J * delta = -R)\n        sol = self._solve_impl(all_vals, -total_f_grounded)\n        delta = sol.value\n\n        # 4. Apply Voltage Limiting (Damping)\n        #    Prevents the solver from taking huge steps that crash exponentials (diodes/transistors).\n        max_change = jnp.max(jnp.abs(delta))\n        damping = jnp.minimum(1.0, 0.5 / (max_change + 1e-9))\n\n        return y + delta * damping\n\n    # 5. Run Newton Loop (Optimistix)\n    solver = optx.FixedPointIteration(rtol=1e-6, atol=1e-6)\n    sol = optx.fixed_point(dc_step, solver, y_guess, max_steps=100, throw=False)\n    return sol.value\n</code></pre>"},{"location":"references/solvers/linear/#circulax.solvers.linear.KLUSolver","title":"KLUSolver","text":"<p>               Bases: <code>CircuitLinearSolver</code></p> <p>Solves the system using the KLU sparse solver (via <code>klujax</code>).</p> Best For <ul> <li>Large circuits (N &gt; 5000) running on CPU.</li> <li>DC Operating Points of massive meshes.</li> <li>Cases where DenseSolver runs out of memory (OOM).</li> </ul> Note <p>Does NOT support <code>vmap</code> (batching) automatically.</p> <p>Methods:</p> Name Description <code>assume_full_rank</code> <p>Indicate if the solver assumes the operator is full rank.</p> <code>compute</code> <p>Performs the computation of the component for each step.</p> <code>from_circuit</code> <p>Factory method to pre-hash indices for sparse coalescence.</p> <code>init</code> <p>Initialize the solver state (No-op for stateless solvers).</p> <code>solve_dc</code> <p>Performs a robust DC Operating Point analysis (Newton-Raphson).</p>"},{"location":"references/solvers/linear/#circulax.solvers.linear.KLUSolver.assume_full_rank","title":"assume_full_rank","text":"<pre><code>assume_full_rank() -&gt; bool\n</code></pre> <p>Indicate if the solver assumes the operator is full rank.</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def assume_full_rank(self) -&gt; bool:\n    \"\"\"Indicate if the solver assumes the operator is full rank.\"\"\"\n    return False\n</code></pre>"},{"location":"references/solvers/linear/#circulax.solvers.linear.KLUSolver.compute","title":"compute","text":"<pre><code>compute(state: Any, vector: Array, options: Any) -&gt; Solution\n</code></pre> <p>Performs the computation of the component for each step.</p> <p>In our case, we usually call <code>_solve_impl</code> directly to avoid overhead, but this satisfies the API.</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def compute(self, state: Any, vector: jax.Array, options: Any) -&gt; lx.Solution:\n    \"\"\"Performs the computation of the component for each step.\n\n    In our case, we usually call `_solve_impl` directly to avoid overhead,\n    but this satisfies the API.\n\n    \"\"\"\n    msg = \"Directly call _solve_impl for internal use.\"\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"references/solvers/linear/#circulax.solvers.linear.KLUSolver.from_circuit","title":"from_circuit  <code>classmethod</code>","text":"<pre><code>from_circuit(\n    component_groups: dict[str, Any], num_vars: int, *, is_complex: bool = False\n) -&gt; KLUSolver\n</code></pre> <p>Factory method to pre-hash indices for sparse coalescence.</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>@classmethod\ndef from_circuit(\n    cls, component_groups: dict[str, Any], num_vars: int, *, is_complex: bool = False\n) -&gt; \"KLUSolver\":\n    \"\"\"Factory method to pre-hash indices for sparse coalescence.\"\"\"\n    all_rows, all_cols = [], []\n    for k in sorted(component_groups.keys()):\n        g = component_groups[k]\n        all_rows.append(np.array(g.jac_rows).reshape(-1))\n        all_cols.append(np.array(g.jac_cols).reshape(-1))\n\n    static_rows = np.concatenate(all_rows)\n    static_cols = np.concatenate(all_cols)\n\n    sys_size = num_vars\n    ground_idxs = np.array([0], dtype=np.int32)\n\n    if is_complex:\n        sys_size = num_vars * 2\n        r, c = static_rows, static_cols\n        N = num_vars\n        static_rows = np.concatenate([r, r, r + N, r + N])\n        static_cols = np.concatenate([c, c + N, c, c + N])\n        ground_idxs = np.array([0, num_vars], dtype=np.int32)\n\n    # We must include indices for the full leakage diagonal\n    leak_rows = np.arange(sys_size, dtype=np.int32)\n    leak_cols = np.arange(sys_size, dtype=np.int32)\n\n    # Combine Circuit + Ground + Leakage indices\n    full_rows = np.concatenate([static_rows, ground_idxs, leak_rows])\n    full_cols = np.concatenate([static_cols, ground_idxs, leak_cols])\n\n    # Hashing to find unique entries for coalescence\n    rc_hashes = full_rows.astype(np.int64) * sys_size + full_cols.astype(np.int64)\n    unique_hashes, map_indices = np.unique(rc_hashes, return_inverse=True)\n\n    u_rows = (unique_hashes // sys_size).astype(np.int32)\n    u_cols = (unique_hashes % sys_size).astype(np.int32)\n    n_unique = len(unique_hashes)\n\n    return cls(\n        u_rows=jnp.array(u_rows),\n        u_cols=jnp.array(u_cols),\n        map_idx=jnp.array(map_indices),\n        n_unique=n_unique,\n        ground_indices=jnp.array(ground_idxs),\n        sys_size=sys_size,\n        is_complex=is_complex,\n    )\n</code></pre>"},{"location":"references/solvers/linear/#circulax.solvers.linear.KLUSolver.init","title":"init","text":"<pre><code>init(operator: Any, options: Any) -&gt; Any\n</code></pre> <p>Initialize the solver state (No-op for stateless solvers).</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def init(self, operator: Any, options: Any) -&gt; Any:  # noqa: ARG002\n    \"\"\"Initialize the solver state (No-op for stateless solvers).\"\"\"\n    return None\n</code></pre>"},{"location":"references/solvers/linear/#circulax.solvers.linear.KLUSolver.solve_dc","title":"solve_dc","text":"<pre><code>solve_dc(component_groups: dict[str, Any], y_guess: Array) -&gt; Array\n</code></pre> <p>Performs a robust DC Operating Point analysis (Newton-Raphson).</p> <p>This method: 1.  Detects if the system is Real or Complex based on <code>self.is_complex</code>. 2.  Assembles the system with dt=infinity (to open capacitors). 3.  Applies ground constraints (setting specific rows/cols to identity). 4.  Solves the linear system J * delta = -Residual. 5.  Applies voltage damping to prevent exponential overshoot.</p> <p>Parameters:</p> Name Type Description Default <code>component_groups</code> <code>dict</code> <p>The circuit components and their parameters.</p> required <code>y_guess</code> <code>Array</code> <p>Initial guess vector (Shape: [N] or [2N]).</p> required <p>Returns:</p> Type Description <code>Array</code> <p>jax.Array: The converged solution vector (Flat).</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def solve_dc(\n    self, component_groups: dict[str, Any], y_guess: jax.Array\n) -&gt; jax.Array:\n    \"\"\"Performs a robust DC Operating Point analysis (Newton-Raphson).\n\n    This method:\n    1.  Detects if the system is Real or Complex based on `self.is_complex`.\n    2.  Assembles the system with dt=infinity (to open capacitors).\n    3.  Applies ground constraints (setting specific rows/cols to identity).\n    4.  Solves the linear system J * delta = -Residual.\n    5.  Applies voltage damping to prevent exponential overshoot.\n\n    Args:\n        component_groups (dict): The circuit components and their parameters.\n        y_guess (jax.Array): Initial guess vector (Shape: [N] or [2N]).\n\n    Returns:\n        jax.Array: The converged solution vector (Flat).\n\n    \"\"\"\n\n    def dc_step(y: jax.Array, _: Any) -&gt; jax.Array:\n        # 1. Assemble System (dt=1e18 effectively removes time-dependent terms like C*dv/dt)\n        if self.is_complex:\n            total_f, _, all_vals = assemble_system_complex(\n                y, component_groups, t1=0.0, dt=1e18\n            )\n        else:\n            total_f, _, all_vals = assemble_system_real(\n                y, component_groups, t1=0.0, dt=1e18\n            )\n\n        # 2. Apply Ground Constraints to Residual\n        #    We add a massive penalty (1e9 * V) to the residual at ground nodes.\n        #    This forces the solver to drive V -&gt; 0.\n        total_f_grounded = total_f\n        for idx in self.ground_indices:\n            total_f_grounded = total_f_grounded.at[idx].add(1e9 * y[idx])\n\n        # 3. Solve Linear System (J * delta = -R)\n        sol = self._solve_impl(all_vals, -total_f_grounded)\n        delta = sol.value\n\n        # 4. Apply Voltage Limiting (Damping)\n        #    Prevents the solver from taking huge steps that crash exponentials (diodes/transistors).\n        max_change = jnp.max(jnp.abs(delta))\n        damping = jnp.minimum(1.0, 0.5 / (max_change + 1e-9))\n\n        return y + delta * damping\n\n    # 5. Run Newton Loop (Optimistix)\n    solver = optx.FixedPointIteration(rtol=1e-6, atol=1e-6)\n    sol = optx.fixed_point(dc_step, solver, y_guess, max_steps=100, throw=False)\n    return sol.value\n</code></pre>"},{"location":"references/solvers/linear/#circulax.solvers.linear.KLUSplitFactorSolver","title":"KLUSplitFactorSolver","text":"<p>               Bases: <code>KLUSplitSolver</code></p> <p>Solves the system using the KLU sparse solver (via <code>klujax</code>) with split interface.</p> <p>This solver performs symbolic analysis ONCE during initialization and reuses the symbolic handle for subsequent solves, significantly speeding up non-linear simulations (Newton-Raphson iterations). This version of the solver is further enhanced but calculting the numeric part of the KLU solution only once</p> Best For <ul> <li>Large circuits (N &gt; 5000) running on CPU.</li> <li>DC Operating Points of massive meshes.</li> </ul> <p>Attributes:</p> Name Type Description <code>Bp,</code> <code>Bi</code> <p>CSC format indices (fixed structure).</p> <code>csc_map_idx</code> <code>Bi</code> <p>Mapping from raw value indices to CSC value vector.</p> <code>symbolic_handle</code> <code>Bi</code> <p>Pointer to the pre-computed KLU symbolic analysis.</p> <p>Methods:</p> Name Description <code>assume_full_rank</code> <p>Indicate if the solver assumes the operator is full rank.</p> <code>compute</code> <p>Performs the computation of the component for each step.</p> <code>factor_jacobian</code> <p>Factor the Jacobian and return numeric handle.</p> <code>from_circuit</code> <p>Factory method to pre-hash indices for sparse coalescence.</p> <code>init</code> <p>Initialize the solver state (No-op for stateless solvers).</p> <code>solve_dc</code> <p>Performs a robust DC Operating Point analysis (Newton-Raphson).</p> <code>solve_with_frozen_jacobian</code> <p>Solve using pre-computed numeric factorization (for frozen Jacobian Newton).</p>"},{"location":"references/solvers/linear/#circulax.solvers.linear.KLUSplitFactorSolver.assume_full_rank","title":"assume_full_rank","text":"<pre><code>assume_full_rank() -&gt; bool\n</code></pre> <p>Indicate if the solver assumes the operator is full rank.</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def assume_full_rank(self) -&gt; bool:\n    \"\"\"Indicate if the solver assumes the operator is full rank.\"\"\"\n    return False\n</code></pre>"},{"location":"references/solvers/linear/#circulax.solvers.linear.KLUSplitFactorSolver.compute","title":"compute","text":"<pre><code>compute(state: Any, vector: Array, options: Any) -&gt; Solution\n</code></pre> <p>Performs the computation of the component for each step.</p> <p>In our case, we usually call <code>_solve_impl</code> directly to avoid overhead, but this satisfies the API.</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def compute(self, state: Any, vector: jax.Array, options: Any) -&gt; lx.Solution:\n    \"\"\"Performs the computation of the component for each step.\n\n    In our case, we usually call `_solve_impl` directly to avoid overhead,\n    but this satisfies the API.\n\n    \"\"\"\n    msg = \"Directly call _solve_impl for internal use.\"\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"references/solvers/linear/#circulax.solvers.linear.KLUSplitFactorSolver.factor_jacobian","title":"factor_jacobian","text":"<pre><code>factor_jacobian(all_vals: Array) -&gt; Array\n</code></pre> <p>Factor the Jacobian and return numeric handle.</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def factor_jacobian(self, all_vals: jax.Array) -&gt; jax.Array:\n    \"\"\"Factor the Jacobian and return numeric handle.\"\"\"\n    g_vals = jnp.full(self.ground_indices.shape[0], 1e9, dtype=all_vals.dtype)\n    l_vals = jnp.full(self.sys_size, self.g_leak, dtype=all_vals.dtype)\n\n    raw_vals = jnp.concatenate([all_vals, g_vals, l_vals])\n    coalesced_vals = jax.ops.segment_sum(\n        raw_vals, self.map_idx, num_segments=self.n_unique\n    )\n\n    return klujax.factor(\n        self.u_rows, self.u_cols, coalesced_vals, self.symbolic_handle\n    )\n</code></pre>"},{"location":"references/solvers/linear/#circulax.solvers.linear.KLUSplitFactorSolver.from_circuit","title":"from_circuit  <code>classmethod</code>","text":"<pre><code>from_circuit(\n    component_groups: dict[str, Any], num_vars: int, *, is_complex: bool = False\n) -&gt; KLUSolver\n</code></pre> <p>Factory method to pre-hash indices for sparse coalescence.</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>@classmethod\ndef from_circuit(\n    cls, component_groups: dict[str, Any], num_vars: int, *, is_complex: bool = False\n) -&gt; \"KLUSolver\":\n    \"\"\"Factory method to pre-hash indices for sparse coalescence.\"\"\"\n    all_rows, all_cols = [], []\n    for k in sorted(component_groups.keys()):\n        g = component_groups[k]\n        all_rows.append(np.array(g.jac_rows).reshape(-1))\n        all_cols.append(np.array(g.jac_cols).reshape(-1))\n\n    static_rows = np.concatenate(all_rows)\n    static_cols = np.concatenate(all_cols)\n\n    sys_size = num_vars\n    ground_idxs = np.array([0], dtype=np.int32)\n\n    if is_complex:\n        sys_size = num_vars * 2\n        r, c = static_rows, static_cols\n        N = num_vars\n        static_rows = np.concatenate([r, r, r + N, r + N])\n        static_cols = np.concatenate([c, c + N, c, c + N])\n        ground_idxs = np.array([0, num_vars], dtype=np.int32)\n\n    # We must include indices for the full leakage diagonal\n    leak_rows = np.arange(sys_size, dtype=np.int32)\n    leak_cols = np.arange(sys_size, dtype=np.int32)\n\n    # Combine Circuit + Ground + Leakage indices\n    full_rows = np.concatenate([static_rows, ground_idxs, leak_rows])\n    full_cols = np.concatenate([static_cols, ground_idxs, leak_cols])\n\n    # Hashing to find unique entries for coalescence\n    rc_hashes = full_rows.astype(np.int64) * sys_size + full_cols.astype(np.int64)\n    unique_hashes, map_indices = np.unique(rc_hashes, return_inverse=True)\n\n    u_rows = (unique_hashes // sys_size).astype(np.int32)\n    u_cols = (unique_hashes % sys_size).astype(np.int32)\n    n_unique = len(unique_hashes)\n\n    symbolic = klujax.analyze(u_rows, u_cols, sys_size)\n\n    return cls(\n        u_rows=jnp.array(u_rows),\n        u_cols=jnp.array(u_cols),\n        map_idx=jnp.array(map_indices),\n        n_unique=n_unique,\n        _handle_wrapper=symbolic,\n        ground_indices=jnp.array(ground_idxs),\n        sys_size=sys_size,\n        is_complex=is_complex,\n    )\n</code></pre>"},{"location":"references/solvers/linear/#circulax.solvers.linear.KLUSplitFactorSolver.init","title":"init","text":"<pre><code>init(operator: Any, options: Any) -&gt; Any\n</code></pre> <p>Initialize the solver state (No-op for stateless solvers).</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def init(self, operator: Any, options: Any) -&gt; Any:  # noqa: ARG002\n    \"\"\"Initialize the solver state (No-op for stateless solvers).\"\"\"\n    return None\n</code></pre>"},{"location":"references/solvers/linear/#circulax.solvers.linear.KLUSplitFactorSolver.solve_dc","title":"solve_dc","text":"<pre><code>solve_dc(component_groups: dict[str, Any], y_guess: Array) -&gt; Array\n</code></pre> <p>Performs a robust DC Operating Point analysis (Newton-Raphson).</p> <p>This method: 1.  Detects if the system is Real or Complex based on <code>self.is_complex</code>. 2.  Assembles the system with dt=infinity (to open capacitors). 3.  Applies ground constraints (setting specific rows/cols to identity). 4.  Solves the linear system J * delta = -Residual. 5.  Applies voltage damping to prevent exponential overshoot.</p> <p>Parameters:</p> Name Type Description Default <code>component_groups</code> <code>dict</code> <p>The circuit components and their parameters.</p> required <code>y_guess</code> <code>Array</code> <p>Initial guess vector (Shape: [N] or [2N]).</p> required <p>Returns:</p> Type Description <code>Array</code> <p>jax.Array: The converged solution vector (Flat).</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def solve_dc(\n    self, component_groups: dict[str, Any], y_guess: jax.Array\n) -&gt; jax.Array:\n    \"\"\"Performs a robust DC Operating Point analysis (Newton-Raphson).\n\n    This method:\n    1.  Detects if the system is Real or Complex based on `self.is_complex`.\n    2.  Assembles the system with dt=infinity (to open capacitors).\n    3.  Applies ground constraints (setting specific rows/cols to identity).\n    4.  Solves the linear system J * delta = -Residual.\n    5.  Applies voltage damping to prevent exponential overshoot.\n\n    Args:\n        component_groups (dict): The circuit components and their parameters.\n        y_guess (jax.Array): Initial guess vector (Shape: [N] or [2N]).\n\n    Returns:\n        jax.Array: The converged solution vector (Flat).\n\n    \"\"\"\n\n    def dc_step(y: jax.Array, _: Any) -&gt; jax.Array:\n        # 1. Assemble System (dt=1e18 effectively removes time-dependent terms like C*dv/dt)\n        if self.is_complex:\n            total_f, _, all_vals = assemble_system_complex(\n                y, component_groups, t1=0.0, dt=1e18\n            )\n        else:\n            total_f, _, all_vals = assemble_system_real(\n                y, component_groups, t1=0.0, dt=1e18\n            )\n\n        # 2. Apply Ground Constraints to Residual\n        #    We add a massive penalty (1e9 * V) to the residual at ground nodes.\n        #    This forces the solver to drive V -&gt; 0.\n        total_f_grounded = total_f\n        for idx in self.ground_indices:\n            total_f_grounded = total_f_grounded.at[idx].add(1e9 * y[idx])\n\n        # 3. Solve Linear System (J * delta = -R)\n        sol = self._solve_impl(all_vals, -total_f_grounded)\n        delta = sol.value\n\n        # 4. Apply Voltage Limiting (Damping)\n        #    Prevents the solver from taking huge steps that crash exponentials (diodes/transistors).\n        max_change = jnp.max(jnp.abs(delta))\n        damping = jnp.minimum(1.0, 0.5 / (max_change + 1e-9))\n\n        return y + delta * damping\n\n    # 5. Run Newton Loop (Optimistix)\n    solver = optx.FixedPointIteration(rtol=1e-6, atol=1e-6)\n    sol = optx.fixed_point(dc_step, solver, y_guess, max_steps=100, throw=False)\n    return sol.value\n</code></pre>"},{"location":"references/solvers/linear/#circulax.solvers.linear.KLUSplitFactorSolver.solve_with_frozen_jacobian","title":"solve_with_frozen_jacobian","text":"<pre><code>solve_with_frozen_jacobian(residual: Array, numeric: Array) -&gt; Solution\n</code></pre> <p>Solve using pre-computed numeric factorization (for frozen Jacobian Newton).</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def solve_with_frozen_jacobian(\n    self, residual: jax.Array, numeric: jax.Array\n) -&gt; lx.Solution:\n    \"\"\"Solve using pre-computed numeric factorization (for frozen Jacobian Newton).\"\"\"\n    solution = klujax.solve_with_numeric(\n        numeric, residual, self._handle_wrapper.handle\n    )\n    return lx.Solution(\n        value=solution.reshape(residual.shape),\n        result=lx.RESULTS.successful,\n        state=None,\n        stats={},\n    )\n</code></pre>"},{"location":"references/solvers/linear/#circulax.solvers.linear.KLUSplitSolver","title":"KLUSplitSolver","text":"<p>               Bases: <code>CircuitLinearSolver</code></p> <p>Solves the system using the KLU sparse solver (via <code>klujax</code>) with split interface.</p> <p>This solver performs symbolic analysis ONCE during initialization and reuses the symbolic handle for subsequent solves, significantly speeding up non-linear simulations (Newton-Raphson iterations).</p> Best For <ul> <li>Large circuits (N &gt; 5000) running on CPU.</li> <li>DC Operating Points of massive meshes.</li> </ul> <p>Attributes:</p> Name Type Description <code>Bp,</code> <code>Bi</code> <p>CSC format indices (fixed structure).</p> <code>csc_map_idx</code> <code>Bi</code> <p>Mapping from raw value indices to CSC value vector.</p> <code>symbolic_handle</code> <code>Bi</code> <p>Pointer to the pre-computed KLU symbolic analysis.</p> <p>Methods:</p> Name Description <code>assume_full_rank</code> <p>Indicate if the solver assumes the operator is full rank.</p> <code>compute</code> <p>Performs the computation of the component for each step.</p> <code>from_circuit</code> <p>Factory method to pre-hash indices for sparse coalescence.</p> <code>init</code> <p>Initialize the solver state (No-op for stateless solvers).</p> <code>solve_dc</code> <p>Performs a robust DC Operating Point analysis (Newton-Raphson).</p>"},{"location":"references/solvers/linear/#circulax.solvers.linear.KLUSplitSolver.assume_full_rank","title":"assume_full_rank","text":"<pre><code>assume_full_rank() -&gt; bool\n</code></pre> <p>Indicate if the solver assumes the operator is full rank.</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def assume_full_rank(self) -&gt; bool:\n    \"\"\"Indicate if the solver assumes the operator is full rank.\"\"\"\n    return False\n</code></pre>"},{"location":"references/solvers/linear/#circulax.solvers.linear.KLUSplitSolver.compute","title":"compute","text":"<pre><code>compute(state: Any, vector: Array, options: Any) -&gt; Solution\n</code></pre> <p>Performs the computation of the component for each step.</p> <p>In our case, we usually call <code>_solve_impl</code> directly to avoid overhead, but this satisfies the API.</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def compute(self, state: Any, vector: jax.Array, options: Any) -&gt; lx.Solution:\n    \"\"\"Performs the computation of the component for each step.\n\n    In our case, we usually call `_solve_impl` directly to avoid overhead,\n    but this satisfies the API.\n\n    \"\"\"\n    msg = \"Directly call _solve_impl for internal use.\"\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"references/solvers/linear/#circulax.solvers.linear.KLUSplitSolver.from_circuit","title":"from_circuit  <code>classmethod</code>","text":"<pre><code>from_circuit(\n    component_groups: dict[str, Any], num_vars: int, *, is_complex: bool = False\n) -&gt; KLUSolver\n</code></pre> <p>Factory method to pre-hash indices for sparse coalescence.</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>@classmethod\ndef from_circuit(\n    cls, component_groups: dict[str, Any], num_vars: int, *, is_complex: bool = False\n) -&gt; \"KLUSolver\":\n    \"\"\"Factory method to pre-hash indices for sparse coalescence.\"\"\"\n    all_rows, all_cols = [], []\n    for k in sorted(component_groups.keys()):\n        g = component_groups[k]\n        all_rows.append(np.array(g.jac_rows).reshape(-1))\n        all_cols.append(np.array(g.jac_cols).reshape(-1))\n\n    static_rows = np.concatenate(all_rows)\n    static_cols = np.concatenate(all_cols)\n\n    sys_size = num_vars\n    ground_idxs = np.array([0], dtype=np.int32)\n\n    if is_complex:\n        sys_size = num_vars * 2\n        r, c = static_rows, static_cols\n        N = num_vars\n        static_rows = np.concatenate([r, r, r + N, r + N])\n        static_cols = np.concatenate([c, c + N, c, c + N])\n        ground_idxs = np.array([0, num_vars], dtype=np.int32)\n\n    # We must include indices for the full leakage diagonal\n    leak_rows = np.arange(sys_size, dtype=np.int32)\n    leak_cols = np.arange(sys_size, dtype=np.int32)\n\n    # Combine Circuit + Ground + Leakage indices\n    full_rows = np.concatenate([static_rows, ground_idxs, leak_rows])\n    full_cols = np.concatenate([static_cols, ground_idxs, leak_cols])\n\n    # Hashing to find unique entries for coalescence\n    rc_hashes = full_rows.astype(np.int64) * sys_size + full_cols.astype(np.int64)\n    unique_hashes, map_indices = np.unique(rc_hashes, return_inverse=True)\n\n    u_rows = (unique_hashes // sys_size).astype(np.int32)\n    u_cols = (unique_hashes % sys_size).astype(np.int32)\n    n_unique = len(unique_hashes)\n\n    symbolic = klujax.analyze(u_rows, u_cols, sys_size)\n\n    return cls(\n        u_rows=jnp.array(u_rows),\n        u_cols=jnp.array(u_cols),\n        map_idx=jnp.array(map_indices),\n        n_unique=n_unique,\n        _handle_wrapper=symbolic,\n        ground_indices=jnp.array(ground_idxs),\n        sys_size=sys_size,\n        is_complex=is_complex,\n    )\n</code></pre>"},{"location":"references/solvers/linear/#circulax.solvers.linear.KLUSplitSolver.init","title":"init","text":"<pre><code>init(operator: Any, options: Any) -&gt; Any\n</code></pre> <p>Initialize the solver state (No-op for stateless solvers).</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def init(self, operator: Any, options: Any) -&gt; Any:  # noqa: ARG002\n    \"\"\"Initialize the solver state (No-op for stateless solvers).\"\"\"\n    return None\n</code></pre>"},{"location":"references/solvers/linear/#circulax.solvers.linear.KLUSplitSolver.solve_dc","title":"solve_dc","text":"<pre><code>solve_dc(component_groups: dict[str, Any], y_guess: Array) -&gt; Array\n</code></pre> <p>Performs a robust DC Operating Point analysis (Newton-Raphson).</p> <p>This method: 1.  Detects if the system is Real or Complex based on <code>self.is_complex</code>. 2.  Assembles the system with dt=infinity (to open capacitors). 3.  Applies ground constraints (setting specific rows/cols to identity). 4.  Solves the linear system J * delta = -Residual. 5.  Applies voltage damping to prevent exponential overshoot.</p> <p>Parameters:</p> Name Type Description Default <code>component_groups</code> <code>dict</code> <p>The circuit components and their parameters.</p> required <code>y_guess</code> <code>Array</code> <p>Initial guess vector (Shape: [N] or [2N]).</p> required <p>Returns:</p> Type Description <code>Array</code> <p>jax.Array: The converged solution vector (Flat).</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def solve_dc(\n    self, component_groups: dict[str, Any], y_guess: jax.Array\n) -&gt; jax.Array:\n    \"\"\"Performs a robust DC Operating Point analysis (Newton-Raphson).\n\n    This method:\n    1.  Detects if the system is Real or Complex based on `self.is_complex`.\n    2.  Assembles the system with dt=infinity (to open capacitors).\n    3.  Applies ground constraints (setting specific rows/cols to identity).\n    4.  Solves the linear system J * delta = -Residual.\n    5.  Applies voltage damping to prevent exponential overshoot.\n\n    Args:\n        component_groups (dict): The circuit components and their parameters.\n        y_guess (jax.Array): Initial guess vector (Shape: [N] or [2N]).\n\n    Returns:\n        jax.Array: The converged solution vector (Flat).\n\n    \"\"\"\n\n    def dc_step(y: jax.Array, _: Any) -&gt; jax.Array:\n        # 1. Assemble System (dt=1e18 effectively removes time-dependent terms like C*dv/dt)\n        if self.is_complex:\n            total_f, _, all_vals = assemble_system_complex(\n                y, component_groups, t1=0.0, dt=1e18\n            )\n        else:\n            total_f, _, all_vals = assemble_system_real(\n                y, component_groups, t1=0.0, dt=1e18\n            )\n\n        # 2. Apply Ground Constraints to Residual\n        #    We add a massive penalty (1e9 * V) to the residual at ground nodes.\n        #    This forces the solver to drive V -&gt; 0.\n        total_f_grounded = total_f\n        for idx in self.ground_indices:\n            total_f_grounded = total_f_grounded.at[idx].add(1e9 * y[idx])\n\n        # 3. Solve Linear System (J * delta = -R)\n        sol = self._solve_impl(all_vals, -total_f_grounded)\n        delta = sol.value\n\n        # 4. Apply Voltage Limiting (Damping)\n        #    Prevents the solver from taking huge steps that crash exponentials (diodes/transistors).\n        max_change = jnp.max(jnp.abs(delta))\n        damping = jnp.minimum(1.0, 0.5 / (max_change + 1e-9))\n\n        return y + delta * damping\n\n    # 5. Run Newton Loop (Optimistix)\n    solver = optx.FixedPointIteration(rtol=1e-6, atol=1e-6)\n    sol = optx.fixed_point(dc_step, solver, y_guess, max_steps=100, throw=False)\n    return sol.value\n</code></pre>"},{"location":"references/solvers/linear/#circulax.solvers.linear.KlursSplitSolver","title":"KlursSplitSolver","text":"<p>               Bases: <code>KLUSplitSolver</code></p> <p>Solves the system using the rust wrapped KLU sparse solver (via <code>klu-rs</code>) with split interface.</p> <p>This solver performs symbolic analysis ONCE during initialization and reuses the symbolic handle for subsequent solves, significantly speeding up non-linear simulations (Newton-Raphson iterations).</p> Best For <ul> <li>Large circuits (N &gt; 5000) running on CPU.</li> <li>DC Operating Points of massive meshes.</li> </ul> <p>Attributes:</p> Name Type Description <code>Bp,</code> <code>Bi</code> <p>CSC format indices (fixed structure).</p> <code>csc_map_idx</code> <code>Bi</code> <p>Mapping from raw value indices to CSC value vector.</p> <code>symbolic_handle</code> <code>Bi</code> <p>Pointer to the pre-computed KLU symbolic analysis.</p> <p>Methods:</p> Name Description <code>assume_full_rank</code> <p>Indicate if the solver assumes the operator is full rank.</p> <code>compute</code> <p>Performs the computation of the component for each step.</p> <code>from_circuit</code> <p>Factory method to pre-hash indices for sparse coalescence.</p> <code>init</code> <p>Initialize the solver state (No-op for stateless solvers).</p> <code>solve_dc</code> <p>Performs a robust DC Operating Point analysis (Newton-Raphson).</p>"},{"location":"references/solvers/linear/#circulax.solvers.linear.KlursSplitSolver.assume_full_rank","title":"assume_full_rank","text":"<pre><code>assume_full_rank() -&gt; bool\n</code></pre> <p>Indicate if the solver assumes the operator is full rank.</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def assume_full_rank(self) -&gt; bool:\n    \"\"\"Indicate if the solver assumes the operator is full rank.\"\"\"\n    return False\n</code></pre>"},{"location":"references/solvers/linear/#circulax.solvers.linear.KlursSplitSolver.compute","title":"compute","text":"<pre><code>compute(state: Any, vector: Array, options: Any) -&gt; Solution\n</code></pre> <p>Performs the computation of the component for each step.</p> <p>In our case, we usually call <code>_solve_impl</code> directly to avoid overhead, but this satisfies the API.</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def compute(self, state: Any, vector: jax.Array, options: Any) -&gt; lx.Solution:\n    \"\"\"Performs the computation of the component for each step.\n\n    In our case, we usually call `_solve_impl` directly to avoid overhead,\n    but this satisfies the API.\n\n    \"\"\"\n    msg = \"Directly call _solve_impl for internal use.\"\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"references/solvers/linear/#circulax.solvers.linear.KlursSplitSolver.from_circuit","title":"from_circuit  <code>classmethod</code>","text":"<pre><code>from_circuit(\n    component_groups: dict[str, Any], num_vars: int, is_complex: bool = False\n) -&gt; KLUSolver\n</code></pre> <p>Factory method to pre-hash indices for sparse coalescence.</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>@classmethod\ndef from_circuit(\n    cls, component_groups: dict[str, Any], num_vars: int, is_complex: bool = False\n) -&gt; \"KLUSolver\":\n    \"\"\"Factory method to pre-hash indices for sparse coalescence.\"\"\"\n    all_rows, all_cols = [], []\n    for k in sorted(component_groups.keys()):\n        g = component_groups[k]\n        all_rows.append(np.array(g.jac_rows).reshape(-1))\n        all_cols.append(np.array(g.jac_cols).reshape(-1))\n\n    static_rows = np.concatenate(all_rows)\n    static_cols = np.concatenate(all_cols)\n\n    sys_size = num_vars\n    ground_idxs = np.array([0], dtype=np.int32)\n\n    if is_complex:\n        sys_size = num_vars * 2\n        r, c = static_rows, static_cols\n        N = num_vars\n        static_rows = np.concatenate([r, r, r + N, r + N])\n        static_cols = np.concatenate([c, c + N, c, c + N])\n        ground_idxs = np.array([0, num_vars], dtype=np.int32)\n\n    # We must include indices for the full leakage diagonal\n    leak_rows = np.arange(sys_size, dtype=np.int32)\n    leak_cols = np.arange(sys_size, dtype=np.int32)\n\n    # Combine Circuit + Ground + Leakage indices\n    full_rows = np.concatenate([static_rows, ground_idxs, leak_rows])\n    full_cols = np.concatenate([static_cols, ground_idxs, leak_cols])\n\n    # Hashing to find unique entries for coalescence\n    rc_hashes = full_rows.astype(np.int64) * sys_size + full_cols.astype(np.int64)\n    unique_hashes, map_indices = np.unique(rc_hashes, return_inverse=True)\n\n    u_rows = (unique_hashes // sys_size).astype(np.int32)\n    u_cols = (unique_hashes % sys_size).astype(np.int32)\n    n_unique = len(unique_hashes)\n\n    symbol = klurs.analyze(u_rows, u_cols, sys_size)\n\n    return cls(\n        u_rows=jnp.array(u_rows),\n        u_cols=jnp.array(u_cols),\n        map_idx=jnp.array(map_indices),\n        n_unique=n_unique,\n        _handle_wrapper=symbol,\n        ground_indices=jnp.array(ground_idxs),\n        sys_size=sys_size,\n        is_complex=is_complex,\n    )\n</code></pre>"},{"location":"references/solvers/linear/#circulax.solvers.linear.KlursSplitSolver.init","title":"init","text":"<pre><code>init(operator: Any, options: Any) -&gt; Any\n</code></pre> <p>Initialize the solver state (No-op for stateless solvers).</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def init(self, operator: Any, options: Any) -&gt; Any:  # noqa: ARG002\n    \"\"\"Initialize the solver state (No-op for stateless solvers).\"\"\"\n    return None\n</code></pre>"},{"location":"references/solvers/linear/#circulax.solvers.linear.KlursSplitSolver.solve_dc","title":"solve_dc","text":"<pre><code>solve_dc(component_groups: dict[str, Any], y_guess: Array) -&gt; Array\n</code></pre> <p>Performs a robust DC Operating Point analysis (Newton-Raphson).</p> <p>This method: 1.  Detects if the system is Real or Complex based on <code>self.is_complex</code>. 2.  Assembles the system with dt=infinity (to open capacitors). 3.  Applies ground constraints (setting specific rows/cols to identity). 4.  Solves the linear system J * delta = -Residual. 5.  Applies voltage damping to prevent exponential overshoot.</p> <p>Parameters:</p> Name Type Description Default <code>component_groups</code> <code>dict</code> <p>The circuit components and their parameters.</p> required <code>y_guess</code> <code>Array</code> <p>Initial guess vector (Shape: [N] or [2N]).</p> required <p>Returns:</p> Type Description <code>Array</code> <p>jax.Array: The converged solution vector (Flat).</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def solve_dc(\n    self, component_groups: dict[str, Any], y_guess: jax.Array\n) -&gt; jax.Array:\n    \"\"\"Performs a robust DC Operating Point analysis (Newton-Raphson).\n\n    This method:\n    1.  Detects if the system is Real or Complex based on `self.is_complex`.\n    2.  Assembles the system with dt=infinity (to open capacitors).\n    3.  Applies ground constraints (setting specific rows/cols to identity).\n    4.  Solves the linear system J * delta = -Residual.\n    5.  Applies voltage damping to prevent exponential overshoot.\n\n    Args:\n        component_groups (dict): The circuit components and their parameters.\n        y_guess (jax.Array): Initial guess vector (Shape: [N] or [2N]).\n\n    Returns:\n        jax.Array: The converged solution vector (Flat).\n\n    \"\"\"\n\n    def dc_step(y: jax.Array, _: Any) -&gt; jax.Array:\n        # 1. Assemble System (dt=1e18 effectively removes time-dependent terms like C*dv/dt)\n        if self.is_complex:\n            total_f, _, all_vals = assemble_system_complex(\n                y, component_groups, t1=0.0, dt=1e18\n            )\n        else:\n            total_f, _, all_vals = assemble_system_real(\n                y, component_groups, t1=0.0, dt=1e18\n            )\n\n        # 2. Apply Ground Constraints to Residual\n        #    We add a massive penalty (1e9 * V) to the residual at ground nodes.\n        #    This forces the solver to drive V -&gt; 0.\n        total_f_grounded = total_f\n        for idx in self.ground_indices:\n            total_f_grounded = total_f_grounded.at[idx].add(1e9 * y[idx])\n\n        # 3. Solve Linear System (J * delta = -R)\n        sol = self._solve_impl(all_vals, -total_f_grounded)\n        delta = sol.value\n\n        # 4. Apply Voltage Limiting (Damping)\n        #    Prevents the solver from taking huge steps that crash exponentials (diodes/transistors).\n        max_change = jnp.max(jnp.abs(delta))\n        damping = jnp.minimum(1.0, 0.5 / (max_change + 1e-9))\n\n        return y + delta * damping\n\n    # 5. Run Newton Loop (Optimistix)\n    solver = optx.FixedPointIteration(rtol=1e-6, atol=1e-6)\n    sol = optx.fixed_point(dc_step, solver, y_guess, max_steps=100, throw=False)\n    return sol.value\n</code></pre>"},{"location":"references/solvers/linear/#circulax.solvers.linear.SparseSolver","title":"SparseSolver","text":"<p>               Bases: <code>CircuitLinearSolver</code></p> <p>Solves the system using JAX's Iterative BiCGStab solver.</p> Best For <ul> <li>Large Transient Simulations on GPU (uses previous step as warm start).</li> <li>Systems where N is too large for Dense, but we need VMAP support.</li> </ul> <p>Attributes:</p> Name Type Description <code>diag_mask</code> <code>Array</code> <p>Mask to extract diagonal elements for preconditioning.</p> <p>Methods:</p> Name Description <code>assume_full_rank</code> <p>Indicate if the solver assumes the operator is full rank.</p> <code>compute</code> <p>Performs the computation of the component for each step.</p> <code>from_circuit</code> <p>Factory method to prepare indices and diagonal mask.</p> <code>init</code> <p>Initialize the solver state (No-op for stateless solvers).</p> <code>solve_dc</code> <p>Performs a robust DC Operating Point analysis (Newton-Raphson).</p>"},{"location":"references/solvers/linear/#circulax.solvers.linear.SparseSolver.assume_full_rank","title":"assume_full_rank","text":"<pre><code>assume_full_rank() -&gt; bool\n</code></pre> <p>Indicate if the solver assumes the operator is full rank.</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def assume_full_rank(self) -&gt; bool:\n    \"\"\"Indicate if the solver assumes the operator is full rank.\"\"\"\n    return False\n</code></pre>"},{"location":"references/solvers/linear/#circulax.solvers.linear.SparseSolver.compute","title":"compute","text":"<pre><code>compute(state: Any, vector: Array, options: Any) -&gt; Solution\n</code></pre> <p>Performs the computation of the component for each step.</p> <p>In our case, we usually call <code>_solve_impl</code> directly to avoid overhead, but this satisfies the API.</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def compute(self, state: Any, vector: jax.Array, options: Any) -&gt; lx.Solution:\n    \"\"\"Performs the computation of the component for each step.\n\n    In our case, we usually call `_solve_impl` directly to avoid overhead,\n    but this satisfies the API.\n\n    \"\"\"\n    msg = \"Directly call _solve_impl for internal use.\"\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"references/solvers/linear/#circulax.solvers.linear.SparseSolver.from_circuit","title":"from_circuit  <code>classmethod</code>","text":"<pre><code>from_circuit(\n    component_groups: dict[str, Any], num_vars: int, *, is_complex: bool = False\n) -&gt; SparseSolver\n</code></pre> <p>Factory method to prepare indices and diagonal mask.</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>@classmethod\ndef from_circuit(\n    cls, component_groups: dict[str, Any], num_vars: int, *, is_complex: bool = False\n) -&gt; \"SparseSolver\":\n    \"\"\"Factory method to prepare indices and diagonal mask.\"\"\"\n    all_rows, all_cols = [], []\n    for k in sorted(component_groups.keys()):\n        g = component_groups[k]\n        all_rows.append(np.array(g.jac_rows).reshape(-1))\n        all_cols.append(np.array(g.jac_cols).reshape(-1))\n\n    static_rows = np.concatenate(all_rows)\n    static_cols = np.concatenate(all_cols)\n\n    sys_size = num_vars\n    ground_idxs = np.array([0], dtype=np.int32)\n\n    if is_complex:\n        sys_size = num_vars * 2\n        r, c = static_rows, static_cols\n        N = num_vars\n        static_rows = np.concatenate([r, r, r + N, r + N])\n        static_cols = np.concatenate([c, c + N, c, c + N])\n        ground_idxs = np.array([0, num_vars], dtype=np.int32)\n\n    # Create mask to identify diagonal elements (row == col) efficiently\n    diag_mask = static_rows == static_cols\n\n    return cls(\n        static_rows=jnp.array(static_rows),\n        static_cols=jnp.array(static_cols),\n        diag_mask=jnp.array(diag_mask),\n        sys_size=sys_size,\n        ground_indices=jnp.array(ground_idxs),\n        is_complex=is_complex,\n    )\n</code></pre>"},{"location":"references/solvers/linear/#circulax.solvers.linear.SparseSolver.init","title":"init","text":"<pre><code>init(operator: Any, options: Any) -&gt; Any\n</code></pre> <p>Initialize the solver state (No-op for stateless solvers).</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def init(self, operator: Any, options: Any) -&gt; Any:  # noqa: ARG002\n    \"\"\"Initialize the solver state (No-op for stateless solvers).\"\"\"\n    return None\n</code></pre>"},{"location":"references/solvers/linear/#circulax.solvers.linear.SparseSolver.solve_dc","title":"solve_dc","text":"<pre><code>solve_dc(component_groups: dict[str, Any], y_guess: Array) -&gt; Array\n</code></pre> <p>Performs a robust DC Operating Point analysis (Newton-Raphson).</p> <p>This method: 1.  Detects if the system is Real or Complex based on <code>self.is_complex</code>. 2.  Assembles the system with dt=infinity (to open capacitors). 3.  Applies ground constraints (setting specific rows/cols to identity). 4.  Solves the linear system J * delta = -Residual. 5.  Applies voltage damping to prevent exponential overshoot.</p> <p>Parameters:</p> Name Type Description Default <code>component_groups</code> <code>dict</code> <p>The circuit components and their parameters.</p> required <code>y_guess</code> <code>Array</code> <p>Initial guess vector (Shape: [N] or [2N]).</p> required <p>Returns:</p> Type Description <code>Array</code> <p>jax.Array: The converged solution vector (Flat).</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def solve_dc(\n    self, component_groups: dict[str, Any], y_guess: jax.Array\n) -&gt; jax.Array:\n    \"\"\"Performs a robust DC Operating Point analysis (Newton-Raphson).\n\n    This method:\n    1.  Detects if the system is Real or Complex based on `self.is_complex`.\n    2.  Assembles the system with dt=infinity (to open capacitors).\n    3.  Applies ground constraints (setting specific rows/cols to identity).\n    4.  Solves the linear system J * delta = -Residual.\n    5.  Applies voltage damping to prevent exponential overshoot.\n\n    Args:\n        component_groups (dict): The circuit components and their parameters.\n        y_guess (jax.Array): Initial guess vector (Shape: [N] or [2N]).\n\n    Returns:\n        jax.Array: The converged solution vector (Flat).\n\n    \"\"\"\n\n    def dc_step(y: jax.Array, _: Any) -&gt; jax.Array:\n        # 1. Assemble System (dt=1e18 effectively removes time-dependent terms like C*dv/dt)\n        if self.is_complex:\n            total_f, _, all_vals = assemble_system_complex(\n                y, component_groups, t1=0.0, dt=1e18\n            )\n        else:\n            total_f, _, all_vals = assemble_system_real(\n                y, component_groups, t1=0.0, dt=1e18\n            )\n\n        # 2. Apply Ground Constraints to Residual\n        #    We add a massive penalty (1e9 * V) to the residual at ground nodes.\n        #    This forces the solver to drive V -&gt; 0.\n        total_f_grounded = total_f\n        for idx in self.ground_indices:\n            total_f_grounded = total_f_grounded.at[idx].add(1e9 * y[idx])\n\n        # 3. Solve Linear System (J * delta = -R)\n        sol = self._solve_impl(all_vals, -total_f_grounded)\n        delta = sol.value\n\n        # 4. Apply Voltage Limiting (Damping)\n        #    Prevents the solver from taking huge steps that crash exponentials (diodes/transistors).\n        max_change = jnp.max(jnp.abs(delta))\n        damping = jnp.minimum(1.0, 0.5 / (max_change + 1e-9))\n\n        return y + delta * damping\n\n    # 5. Run Newton Loop (Optimistix)\n    solver = optx.FixedPointIteration(rtol=1e-6, atol=1e-6)\n    sol = optx.fixed_point(dc_step, solver, y_guess, max_steps=100, throw=False)\n    return sol.value\n</code></pre>"},{"location":"references/solvers/linear/#circulax.solvers.linear.analyze_circuit","title":"analyze_circuit","text":"<pre><code>analyze_circuit(\n    groups: list, num_vars: int, backend: str = \"default\", *, is_complex: bool = False\n) -&gt; CircuitLinearSolver\n</code></pre> <p>Initializes a linear solver strategy for circuit analysis.</p> <p>This function serves as a factory and wrapper to select and configure the appropriate numerical backend for solving the linear system of equations derived from a circuit's topology.</p> <p>Parameters:</p> Name Type Description Default <code>groups</code> <code>list</code> <p>A list of component groups that define the circuit's structure and properties.</p> required <code>num_vars</code> <code>int</code> <p>The total number of variables in the linear system.</p> required <code>backend</code> <code>str</code> <p>The name of the solver backend to use. Supported backends are 'klu', 'klu_split', 'dense', and 'sparse'. Defaults to 'default', which uses the 'klu' solver.</p> <code>'default'</code> <code>is_complex</code> <code>bool</code> <p>A flag indicating whether the circuit analysis involves complex numbers. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>CircuitLinearSolver</code> <code>CircuitLinearSolver</code> <p>An instance of a circuit linear solver strategy</p> <code>CircuitLinearSolver</code> <p>configured for the specified backend and circuit parameters.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the specified backend is not supported.</p> Source code in <code>circulax/solvers/linear.py</code> <pre><code>def analyze_circuit(\n    groups: list, num_vars: int, backend: str = \"default\", *, is_complex: bool = False\n) -&gt; CircuitLinearSolver:\n    \"\"\"Initializes a linear solver strategy for circuit analysis.\n\n    This function serves as a factory and wrapper to select and configure the\n    appropriate numerical backend for solving the linear system of equations\n    derived from a circuit's topology.\n\n    Args:\n        groups (list): A list of component groups that define the circuit's\n            structure and properties.\n        num_vars (int): The total number of variables in the linear system.\n        backend (str, optional): The name of the solver backend to use.\n            Supported backends are 'klu', 'klu_split', 'dense', and 'sparse'.\n            Defaults to 'default', which uses the 'klu' solver.\n        is_complex (bool, optional): A flag indicating whether the circuit\n            analysis involves complex numbers. Defaults to False.\n\n    Returns:\n        CircuitLinearSolver: An instance of a circuit linear solver strategy\n        configured for the specified backend and circuit parameters.\n\n    Raises:\n        ValueError: If the specified backend is not supported.\n\n    \"\"\"\n    solver_class = backends.get(backend)\n    if solver_class is None:\n        msg = (\n            f\"Unknown backend: '{backend}'. \"\n            f\"Available backends are {list(backends.keys())}\"\n        )\n        raise ValueError(\n            msg\n        )\n\n    linear_strategy = solver_class.from_circuit(groups, num_vars, is_complex=is_complex)\n\n    return linear_strategy\n</code></pre>"},{"location":"references/solvers/transient/","title":"Transient","text":""},{"location":"references/solvers/transient/#circulax.solvers.transient","title":"transient","text":"<p>Transient solvers to be used with Diffrax.</p> <p>Classes:</p> Name Description <code>VectorizedTransientSolver</code> <p>Transient solver that works strictly on FLAT (Real) vectors.</p> <p>Functions:</p> Name Description <code>setup_transient</code> <p>Configures and returns a function for executing transient analysis.</p>"},{"location":"references/solvers/transient/#circulax.solvers.transient.VectorizedTransientSolver","title":"VectorizedTransientSolver","text":"<p>               Bases: <code>AbstractSolver</code></p> <p>Transient solver that works strictly on FLAT (Real) vectors.</p> <p>Delegates complexity handling to the 'linear_solver' strategy.</p>"},{"location":"references/solvers/transient/#circulax.solvers.transient.setup_transient","title":"setup_transient","text":"<pre><code>setup_transient(\n    groups: list,\n    linear_strategy: CircuitLinearSolver,\n    transient_solver: AbstractSolver = None,\n) -&gt; Callable[..., Solution]\n</code></pre> <p>Configures and returns a function for executing transient analysis.</p> <p>This function acts as a factory, preparing a transient solver that is pre-configured with the circuit's linear strategy. It returns a callable that executes the time-domain simulation using <code>diffrax.diffeqsolve</code>.</p> <p>Parameters:</p> Name Type Description Default <code>groups</code> <code>list</code> <p>A list of component groups that define the circuit.</p> required <code>linear_strategy</code> <code>CircuitLinearSolver</code> <p>The configured linear solver strategy, typically obtained from <code>analyze_circuit</code>.</p> required <code>transient_solver</code> <code>optional</code> <p>The transient solver class to use. If None, <code>VectorizedTransientSolver</code> will be used.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[..., Solution]</code> <p>Callable[..., Any]: A function that executes the transient analysis.</p> <code>Callable[..., Solution]</code> <p>This returned function accepts the following arguments:</p> <p>t0 (float): The start time of the simulation. t1 (float): The end time of the simulation. dt0 (float): The initial time step for the solver. y0 (ArrayLike): The initial state vector of the system. saveat (diffrax.SaveAt, optional): Specifies time points at which     to save the solution. Defaults to None. max_steps (int, optional): The maximum number of steps the solver     can take. Defaults to 100000. throw (bool, optional): If True, the solver will raise an error on     failure. Defaults to False. term (diffrax.AbstractTerm, optional): The term defining the ODE.     Defaults to a zero-value ODETerm. stepsize_controller (diffrax.AbstractStepSizeController, optional):     The step size controller. Defaults to <code>ConstantStepSize()</code>. **kwargs: Additional keyword arguments to pass directly to     <code>diffrax.diffeqsolve</code>.</p> Source code in <code>circulax/solvers/transient.py</code> <pre><code>def setup_transient(\n    groups: list,\n    linear_strategy: CircuitLinearSolver,\n    transient_solver:AbstractSolver=None\n) -&gt; Callable[..., diffrax.Solution]:\n    \"\"\"Configures and returns a function for executing transient analysis.\n\n    This function acts as a factory, preparing a transient solver that is\n    pre-configured with the circuit's linear strategy. It returns a callable\n    that executes the time-domain simulation using `diffrax.diffeqsolve`.\n\n    Args:\n        groups (list): A list of component groups that define the circuit.\n        linear_strategy (CircuitLinearSolver): The configured linear solver\n            strategy, typically obtained from `analyze_circuit`.\n        transient_solver (optional): The transient solver class to use.\n            If None, `VectorizedTransientSolver` will be used.\n\n    Returns:\n        Callable[..., Any]: A function that executes the transient analysis.\n        This returned function accepts the following arguments:\n\n            t0 (float): The start time of the simulation.\n            t1 (float): The end time of the simulation.\n            dt0 (float): The initial time step for the solver.\n            y0 (ArrayLike): The initial state vector of the system.\n            saveat (diffrax.SaveAt, optional): Specifies time points at which\n                to save the solution. Defaults to None.\n            max_steps (int, optional): The maximum number of steps the solver\n                can take. Defaults to 100000.\n            throw (bool, optional): If True, the solver will raise an error on\n                failure. Defaults to False.\n            term (diffrax.AbstractTerm, optional): The term defining the ODE.\n                Defaults to a zero-value ODETerm.\n            stepsize_controller (diffrax.AbstractStepSizeController, optional):\n                The step size controller. Defaults to `ConstantStepSize()`.\n            **kwargs: Additional keyword arguments to pass directly to\n                `diffrax.diffeqsolve`.\n\n    \"\"\"\n    if transient_solver is None:\n        transient_solver = VectorizedTransientSolver\n\n    tsolver = transient_solver(linear_solver=linear_strategy)\n\n    sys_size = (\n        linear_strategy.sys_size // 2\n        if linear_strategy.is_complex\n        else linear_strategy.sys_size\n    )\n\n    def _execute_transient(\n        *,\n        t0: float,\n        t1: float,\n        dt0: float,\n        y0: ArrayLike,\n        saveat: diffrax.SaveAt = None,\n        max_steps: int = 100000,\n        throw: bool = False,\n        **kwargs: Any,\n    ) -&gt; diffrax.Solution:\n        \"\"\"Executes the transient simulation for the pre-configured circuit.\"\"\"\n        term = kwargs.pop(\"term\", diffrax.ODETerm(lambda t, y, args: jnp.zeros_like(y)))\n        solver = kwargs.pop(\"solver\", tsolver)\n        args = kwargs.pop(\"args\", (groups, sys_size))\n        stepsize_controller = kwargs.pop(\"stepsize_controller\", ConstantStepSize())\n\n        sol = diffrax.diffeqsolve(\n            terms=term,\n            solver=solver,\n            t0=t0,\n            t1=t1,\n            dt0=dt0,\n            y0=y0,\n            args=args,\n            saveat=saveat,\n            max_steps=max_steps,\n            throw=throw,\n            stepsize_controller=stepsize_controller,\n            **kwargs,\n        )\n\n        return sol\n\n    return _execute_transient\n</code></pre>"}]}